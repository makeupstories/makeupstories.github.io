<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python——configparser模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94configparser%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[configparser 模块configparser 用于解析配置文件的模块，我们会在配置文件中，放入一些配置程序的信息，通常而言，这些配置信息是我们不需要经常去改动的信息，例如数据文件的路径 DB_PATH 在配置文件中，只有两种内容： section分区 option 选项 通常我们用get功能，从配置文件中获取一个配置选项。 Case12345678910# file: test.cfg# 路径相关的配置[path]db_path = /a/b/c/test.txt# 用户相关的配置[user]name = oOC# 服务相关的配置[server]url = 192.168.0.0 123456789101112131415161718192021222324252627282930313233343536373839404142434445# file: configparser模块.pyimport configparserconfig = configparser.ConfigParser()config.read('test.cfg',encoding='utf-8')# 获取需要的信息# 获取所有的分区print(config.sections())# ['path', 'user', 'server']# 获取所有选项print(config.options('user'))# ['name']# 获取路径print(config.get('path','db_path'))# /a/b/c/test.txt# 获取用户名print(config.get('user','name'))# oOC# get返回的都是字符串类型 如果需要转换类型 # 直接使用get+对应的类型(bool int float)getfloat()getint()getbool()# 是否由某个选项config.has_option()# 是否由某个分区config.has_section()# 返回布尔值# 添加config.add_section("server")config.set("server","url","192.168.1.2")# 删除config.remove_option("user")# 修改config.set("server","url","192.168.1.2")# 写回文件中with open("test.cfg", "wt", encoding="utf-8") as f: config.write(f)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——XML模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94XML%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[XML 模块参考文档链接： 什么是XML 模块？ XML 指可扩展标记语言（EXtensible Markup Language） XML 的设计宗旨是传输数据，而不是显示数据 XML 标签没有被预定义，我们需要自行定义标签 XML 的语法格式12345678910&lt;?xml version="1.0" encoding = "UTF-8"?&gt;&lt;!-- XML 声明文件的可选部分，如果存在需要放在文档的第一行 --&gt;&lt;root&gt; &lt;!-- 根元素 --&gt; &lt;child name = 'ooc'&gt; &lt;!-- 元素 应该还包含 有属性 'category' --&gt; &lt;!--XML 属性值必须加引号 --&gt;&lt;!--在 XML 中，应该尽量避免使用属性。如果信息感觉起来很像数据才使用元素吧--&gt; &lt;subchild&gt;......&lt;/subchild&gt; &lt;!-- 同时，层级必须明确，不可以混乱--&gt; &lt;subchild1&gt;.....&lt;/subchild1&gt; &lt;!-- 同级 --&gt; &lt;/child&gt;&lt;/root&gt; &lt;!--与第三行&lt;root&gt;对应&lt;/root&gt;是关闭标签，必须有这样的一对 --&gt; Case11234567891011121314&lt;bookstore&gt; &lt;book category="CHILDREN"&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category="WEB"&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XML 命名规则XML 元素必须遵循以下命名规则： 名称可以包含字母、数字以及其他字符 不能以数字或者标点符号开始 不能以字母xml、XML、Xml等开始 名称不能包含空格 Case212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# file: c.xml&lt;studentinfo&gt; &lt;stu1&gt; &lt;name1&gt; 张三 &lt;/name1&gt; &lt;age1&gt; 20 &lt;/age1&gt; &lt;girlfriend11&gt; &lt;name11&gt; 张三的女朋友 &lt;/name11&gt; &lt;age11&gt; 19 &lt;/age11&gt; &lt;/girlfriend11&gt; &lt;/stu1&gt; &lt;stu2&gt; &lt;name2&gt; 李四 &lt;/name2&gt; &lt;age2&gt; 23 &lt;/age2&gt; &lt;girlfriend22&gt; &lt;name22&gt; 李四的女朋友 &lt;/name22&gt; &lt;age22&gt; 18 &lt;/age22&gt; &lt;/girlfriend22&gt; &lt;/stu2&gt;&lt;/studentinfo&gt;# file:xml模块.pyimport xml.etree.ElementTree as ElementTree# 解析c.xmltree = ElementTree.parse('c.xml')print(tree)# 获取根标签rootTree = tree.getroot()print(rootTree)# iter是用于在全文范围获取标签for item in rootTree.iter('age22'): print(item.text) print(item.text.strip())# 输出 &lt;xml.etree.ElementTree.ElementTree object at 0x10462a7f0&gt;&lt;Element 'studentinfo' at 0x1045cbe08&gt; 1818]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——JSON模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94JSON%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[JSON 模块 什么是JSON模块？如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。JSON表示的对象就是标准的JavaScript语言的对象。 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象 JSON格式的语法规范JSON模块提供了四个方法：dumps, dump, loads, load (不带s 封装write 和 read) case1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import json# file: a.json&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;# 反序列化 # file: json模块.pywith open('a.json','rt',encoding = 'utf-8') as f: res = json.loads(f.read()) print(type(res))# &lt;class 'dict'&gt;with open('a.json',encoding='utf-8') as f: print(json,load(f)) # 不带s 封装 write 和 read功能 # &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;json_info = '''&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;'''res = json.loads(json_info)print(res)# &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;with open('b.json','wt',encoding='utf-8') as f: f.wrtie(json.dumps(json_info)) with open('b.json','wt',encoding='utf-8') as f: json.dump(json_info,f) # 不带s 封装 write 和 read功能]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shelve模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shelve%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shelve 模块shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型。 case12345678910import shelveuser = &#123;'name':'ooc'&#125;f = shelve.open(r'user_info.shv',writeback = True)f['user'] = userf.close() # 关闭时，把添加的内容写回到原文件中f = shelve.open(r'user_info.shv')print(f['user'])f.close()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——pickle模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[pickle 模块序列化的模块 序列化是什么？序列化就是将内存中的数据结构转化成为一种中间格式，并储存到硬盘上。我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。 为什么要序列化？就是为了将数据持久储存，还为了实现跨平台数据交互。 反序列化是什么？把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 case123456789101112131415161718import pickledic = &#123;'name':'ooc','age':23,'gender':'male'&#125;print(type(dic)) # &lt;class 'dict'&gt;a = pickle.dumps(dic) # dumps 直接序列化到文件print(type(a)) # &lt;class 'bytes'&gt;f = open('user_info.pkl','wb') # 因为a是'bytes' ，wb是写入bytesf.write(a) # f.write(pickle.dumps(dic))序列化f.close()f = open('user_info.pkl','rb')info = pickle.loads(f.read()) # 从文件中反序列化print(info['age'])# 23]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shutil模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shutil%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shutil 模块shutil 模块提供了一个易于使用的高级接口，用于处理文件、文件夹、压缩包、处理模块等 1234567891011121314151617181920212223242526272829303132333435363738# 将文件内容拷贝到另一个文件中# shutil.copyfileobj(fsrc,fdst[,length])&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.copyfileobj(open('old.txt','r'),open('new.txt','w'))# 拷贝文件 和 shutil.copyfileobj(fsrc,fdst[,length]) 差不多# shutil.copyfile(src,dst)&gt;&gt;&gt; shutil.copyfile('old.txt','new.txt') # 目标无需存在# 仅拷贝权限，内容、组、用户均不变# shutil.copymode(src,dst)&gt;&gt;&gt; shutil.copymode('old.txt','new.txt') # 目标文件必须存在# 拷贝文件和权限# shutil.copy(src,dst)&gt;&gt;&gt; shutil.copy('old.txt','new.txt')# 拷贝文件和状态信息# shutil.copy2(src,dst)&gt;&gt;&gt; shutil.copy2('old.txt','new.txt')# 压缩文件# 创建压缩包并返回文件路径# shutil.make_archive(base_name, format,...)# base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，# 如：data_bak =&gt;保存至当前路径# 如：/tmp/data_bak =&gt;保存至/tmp/# format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”# root_dir： 要压缩的文件夹路径（默认当前目录）# owner： 用户，默认当前用户# group： 组，默认当前组# logger： 用于记录日志，通常是logging.Logger对象&gt;&gt;&gt; shutil.make_archive('compression','zip',r'\a\b\c')&gt;&gt;&gt; shutil.make_archive('compression1','rar',r'\a\b\c')# shutil直接解压&gt;&gt;&gt; shutil.unpack_archive('\a\b\c\compression.zip')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os.path模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94os.path%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os.path 模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; import os# 返回path规范化的绝对路径&gt;&gt;&gt; os.path.abspath('a.txt') '/Users/ooc/makeupstories.github.io/a.txt'# 将path分割成目录和文件名二元组返回&gt;&gt;&gt; os.path.split('/Users/ooc/makeupstories.github.io/a.txt')('/Users/ooc/makeupstories.github.io', 'a.txt')# 返回path的目录。其实就是os.path.split(path)的第一个元素 [0]&gt;&gt;&gt; os.path.dirname('/Users/ooc/makeupstories.github.io/a.txt')'/Users/ooc/makeupstories.github.io'# 返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。# 即os.path.split(path)的第二个元素&gt;&gt;&gt; os.path.basename('/Users/ooc/makeupstories.github.io/a.txt') 'a.txt'# 如果path存在，返回True；如果path不存在，返回False&gt;&gt;&gt; os.path.exists('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 如果path是绝对路径，返回True&gt;&gt;&gt; os.path.isabs('/Users/ooc/makeupstories.github.io/no_exist.txt')True# 如果path是一个存在的文件，返回True。否则返回False&gt;&gt;&gt; os.path.isfile('/Users/ooc/makeupstories.github.io/no_exist.txt')False# 如果path是一个存在的目录，则返回True。否则返回False&gt;&gt;&gt; os.path.isdir('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 将多个名称拼接为路径 &gt;&gt;&gt; os.path.join('a/','b/','c') 'a/b/c'# 返回path所指向的文件或者目录的最后存取时间&gt;&gt;&gt; os.path.getatime('/Users/ooc/makeupstories.github.io')1539767358.083225# 返回path所指向的文件或者目录的最后修改时间&gt;&gt;&gt; os.path.getmtime('/Users/ooc/makeupstories.github.io') 1539500860.4628224# 返回path的大小&gt;&gt;&gt; os.path.getsize('/Users/ooc/makeupstories.github.io') 448]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块这个模块提供了一种方便的使用操作系统函数的方法。 获取当前的工作目录123&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc' 切换当前工作目录123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc'&gt;&gt;&gt; os.chdir('/Users/ooc/Desktop/')&gt;&gt;&gt; os.getcwd()'/Users/ooc/Desktop' 当前目录 &amp; 上一级目录12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.curdir # 当前目录 '.''.'&gt;&gt;&gt; os.pardir # 上一级目录 '..''..' 系统环境变量12&gt;&gt;&gt; os.environ # 与sys.path不同的是 sys.path加载的是包的环境变量 # os.environ加载的是系统的环境变量 执行系统命令12&gt;&gt;&gt; os.system('cd') # 会执行括号中的命令，如果命令成功执行，返回0，否则返回10 创建目录123&gt;&gt;&gt; os.mkdir('d') # mkdir 一级一级的创建目录&gt;&gt;&gt; os.mkdir('j/a') # 上一级目录必须存在，否则报错&gt;&gt;&gt; os.makedirs('a/b/c') # 创建目录，可以连同子目录一同创建 删除目录12&gt;&gt;&gt; os.removedirs('a/b/c') # 递归删除，如果文件夹内没有文件就删掉，有文件就保留&gt;&gt;&gt; os.rmdir('d') 删除文件1&gt;&gt;&gt; os.remove(r'/Users/ooc/Desktop/a/b/c.txt') # 仅仅删除文件 列出所有文件和文件夹名称1&gt;&gt;&gt; os.listdir(r'/Users/ooc/Desktop/a/b') # 列出所有文件和文件夹名称 获取当前平台的路径分隔符12&gt;&gt;&gt; os.sep # 不同系统会有所差异/ 获取当前平台换行符12&gt;&gt;&gt; os.linesep'\n']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python————random模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94%E2%80%94%E2%80%94random%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[random 模块Random variable generators. 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; random.random() # 0-1 不包括1 输出一个随机浮点数0.026446419370216523&gt;&gt;&gt; random.random()0.5107952377575242&gt;&gt;&gt; random.random()0.8535785412460167&gt;&gt;&gt; random.randint(1,10) # 取1-10 中的随机一个整数2&gt;&gt;&gt; random.randint(1,10) # 取得到10 因为 return self.randrange(a, b+1)3&gt;&gt;&gt; random.randrange(1,10)# 取1-10 中的随机一个整数6 # 但是取不到10# 原文档# This fixes the problem with randint() which includes the endpoint; in Python this is usually not what you want.&gt;&gt;&gt; random.sample(['1','2','3','4'],2)['3', '4'] #sample(指定一个范围，随机个数)&gt;&gt;&gt; l = ['1','2','3','4'] # 打乱原列表的顺序&gt;&gt;&gt; random.shuffle(l)&gt;&gt;&gt; l['4', '2', '1', '3']&gt;&gt;&gt; random.choice([1,2,3]) # 随机选一个1&gt;&gt;&gt; random.choices([1,2,3,4,5,6,7],k = 2) # 随机选择两个[5, 7] 随机验证码长度自定义 包括0-9 a-z A-Z 123456789101112def get_auth_code(length): res = "" for i in range(length): a = random.randint(0,9) b = chr(random.randint(65,90)) c = chr(random.randint(97,122)) s = random.choice([a,b,c]) res += str(s) return resprint(get_auth_code(4))# 5V3l 输出]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——sys模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94sys%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[sys 模块This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter. 环境变量12345&gt;&gt;&gt; import sys # 记住要调用模块 此文章后边不再写&gt;&gt;&gt; sys.path['', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python37.zip', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload', '/usr/local/lib/python3.7/site-packages']# 环境变量# 可以通过 sys.path.append() 来添加 查看已经加载的模块12&gt;&gt;&gt; sys.modules# 你就可以看到你已经加载的模块，由于我这边加载的模块巨多，不写了 获取终端调用时的参数1234567891011121314151617&gt;&gt;&gt; sys.argv[''] # 这里我在terminal中测试的代码# 在pycharm, file:sys_argv.pyprint(sys.argv) 这里我们可以看到 sys.argv 是一个列表# ['/Users/ooc/Desktop/Python/sys模块.py']print(sys.argv[0])# /Users/ooc/Desktop/Python/sys模块.py# file:sys_argv.py# import sysprint(sys.argv[2])# file: sys_argv.py# file_path: /Users/ooc/Desktop/Python/sys_argv.py# terminaloOCs-MBP:~ ooc$ python3 /Users/ooc/Desktop/Python/sys_argv.py 1 4 9 104 # 获取终端调用时的参数 第一个元素是程序本身路径 获取解释器的版本信息1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.version'3.7.0 (default, Aug 22 2018, 15:22:33) \n[Clang 9.1.0 (clang-902.0.39.2)]'# 当前解释器使用的信息 获取当前平台名称12&gt;&gt;&gt; sys.platformdarwin # MacOS int类型支持的最大值12&gt;&gt;&gt; sys.maxsize # 貌似python2中好像是，sys.maxint9223372036854775807 最大的Unicode值12&gt;&gt;&gt; sys.maxunicode1114111 中间结束程序12345&gt;&gt;&gt; sys.exit() # 默认为0# 执行到这行代码时就退出程序If the status is omitted or None, it defaults to zero (i.e., success).If the status is an integer, it will be used as the system exit status.If it is another kind of object, it will be printed and the system 终端复制文件工具123456789# 原文件路径source = sys.argv[1]# 目标文件路径dispath = sys.argv[2]with open(source,'rb') as f: data = f.read() with open(dispatch,'wb') as f2: f2.write(data)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——datetime模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94datetime%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[datetimedatetime 主要对时间和日期的处理 获取当前详细时间12345678910111213141516171819202122232425262728&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2018, 10, 15, 19, 45, 9, 841259)&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; print(a)2018-10-15 19:45:24.502984 # 获取时间的某一部分&gt;&gt;&gt; print(a.hour)19&gt;&gt;&gt; print(a.year)2018# 替换时间的某一部分&gt;&gt;&gt; a = a.replace(year=2019)&gt;&gt;&gt; print(a)2019-10-15 19:45:24.502984&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; b = datetime.datetime.now()&gt;&gt;&gt; print(a + b) # 不支持的操作类型 + 个人猜测是因为最大只能计算到2038年Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'datetime.datetime' and 'datetime.datetime'&gt;&gt;&gt; print(a - b)-1 day, 23:59:52.248296&gt;&gt;&gt; print(b - a)0:00:07.751704]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——time模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94time%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[time与时间相关的一个模块 更多了解：http://www.runoob.com/python3/python3-date-time.html 时间的三类时间戳时间戳是指从 1970年1月1日 0:0:0 开始到现在的秒数，但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。（不知道有没有更新过） 12345678&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1539595862.1039639&gt;&gt;&gt; time1 = time.time()&gt;&gt;&gt; time.sleep(10)&gt;&gt;&gt; time2 = time.time()&gt;&gt;&gt; time2 - time110.00250792503357 结构化时间123456789101112131415161718192021&gt;&gt;&gt; time.localtime()# 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组。time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=18, tm_min=43, tm_sec=5, tm_wday=0, tm_yday=288, tm_isdst=0)# tm_year 年# tm_mon 月# tm_mday 日# tm_hour 小时# tm_min 分钟# tm_sec 0 到 61 (60或61 是闰秒)# tm_wday 0到6 (0是周一) # tm_yday 一年中的第几天# tm_isdst 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的时候， tm_isdst为0；不了解情况时，tm_isdst()为负。# 单独取值&gt;&gt;&gt; time.localtime().tm_year2018&gt;&gt;&gt; time.localtime().tm_mon10&gt;&gt;&gt; time.gmtime() time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=10, tm_min=58, tm_sec=45, tm_wday=0, tm_yday=288, tm_isdst=0)# gmtime() 函数将一个时间戳转换为UTC时区（0时区）的struct_time，可选的参数sec表示从1970年1月1日以来的秒数。其默认值为time.time()，函数返回time.struct_time类型的对象。 格式化字符串时间12345&gt;&gt;&gt; time.strftime('%Y-%m-%d %H:%M:%S %p') # 注意大小写不然会报语法错误'2018-10-15 19:01:40 PM'&gt;&gt;&gt;time.strftime('%Y-%m-%d %X %p')'2018-10-15 19:02:11 PM' 三种格式之间的相互转换123456789101112131415# 时间戳转为结构化&gt;&gt;&gt; time.localtime(time.time())time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=19, tm_min=4, tm_sec=25, tm_wday=0, tm_yday=288, tm_isdst=0)# 结构化转字符串&gt;&gt;&gt; time.strftime('%Y-%m-%d',time.localtime(time.time()))'2018-10-15'# 字符串转为结构化&gt;&gt;&gt; time.strptime('2018-10-15','%Y-%m-%d')time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1)# 结构化转时间戳&gt;&gt;&gt; time.mktime(time.strptime('2018-10-15','%Y-%m-%d'))1539532800.0 格林威治时间123&gt;&gt;&gt; time.altzone # 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。-28800 # 暂时我也不知道有啥用 time.ctime([secs])12&gt;&gt;&gt; time.ctime() # 偏外国友人使用的时间格式'Mon Oct 15 19:12:30 2018']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——目录规范]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[标准目录规范在学习模块和包之前，就已经写过了ATM和购物车的项目，但是当时我们没有学习模块和包，所以当时是所有的函数功能都写在一个.py文件当中，虽然实现了功能，但是当时就发现，在实际写代码时，过程非常的复杂，看起来比较乱，所以在学习模块和包以后呢，我们应该根据项目，应该分什么文件，分什么样的文件夹，那么在初期呢，我们有一个固定的文件结构，就是今天的要说的开发的标准目录规范。 配置文件e.g. case : ATM 123456789101112131415161718# 此代码块用于表示我的目录# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范标准目录规范 ———————— | # 文件和模块 bin-------------- start.py | config----------- settings.py | core------------- ATM.py | db--------------- db.txt | lib-------------- common.py | log-------------- log.txt | readme.txt（说明文档） 1234567891011121314151617181920212223242526272829303132# file: 'start.py' # 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') start() 在case中，可以发现我们使用到了文件的路径，在之后的功能中，日志文件，或者数据文件等，我们会不止一次的使用到文件路径，那么我们每一次直接将路径写在代码中，效率是非常低的，不可取，因为这只是在我们自己的电脑上用时，路径是这样的，但是当移植到别人的电脑上时，路径就会发生改变，所以我们不可避免的会需要修改这些路径。 所以不要直接写在代码中，我们可以通过定义一个变量，然后在修改的时候只需要修改一次，其次，也简化了书写。 12345678# file: 'start.py'# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt'# 在python中的常量，通常通过全部大写的变量名来定义，但是其本质和一个普通变量没有区别，但是大家统一用全部大写来定义一个常量 ​ 通常这类用于配置程序的变量，我们应该将它们都统一的放到单独的配置文件当中，不应该与我们的函数功能存放在一起。所以更好的做法是新建一个文件，将配置文件放进去。 12345678# 所以我们有了config这个文件夹，并在里边创建一个settings.py文件# file:'settings.py'# 将配置信息写入settings.py# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt' 公共模块通常我们还会在很多时候，在进行关键操作之前需要进行验证，也就是说例如在atm功能中，在转账、提现、存款时，无论想要操作哪一步都需要先进行登陆验证，那么这时候这个验证功能的函数，就属于公共模块。 1234# file: 'common.py'# 登陆验证装饰器def login_auth(): pass 日志文件 log.txt 和 数据文件 db.txt区分业务逻辑和启动代码另外我们可以将程序的业务逻辑和启动代码，进行分离，创建一个start.py 和 将业务逻辑模块放入core文件夹中（e.g. ATM.py） 1234567891011121314151617181920212223242526272829303132# file: 'ATM.py'# 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') # file: 'start.py'start() 执行文件最后start.py就是一个执行文件通常我们放在bin文件夹中，即使有多个执行文件，我们也可以将其统一到bin文件夹中。 定制程序的入口为了给用户提供便利，我们程序的入口应该从core业务逻辑中转移到start.py文件中，所以我们需要将start.py中导入core下的ATM并执行start。 123456789# file:'start.py'import core.ATMcore.ATM.start()# 运行结果Traceback (most recent call last): File "/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.py", line 16, in &lt;module&gt; import core.ATMModuleNotFoundError: No module named 'core' 很显然这样配置之后，我们以为导入了 ‘core’ 模块，但是运行结果很明确的告诉我们没有找到名字叫 ‘core’ 的模块，所以我们需要导入模块。 1234567891011121314151617# file: 'start.py'import sys,osprint(__file__)# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.pyprint(os.path.dirname(__file__))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/binprint(os.path.dirname(os.path.dirname(__file__)))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范 # 为了能够找到所有模块，把‘标准目录规范’下的下的所有文件夹导入到环境变量中BASE_DIC = os.path.dirname(os.path.dirname(__file__))sys.path.append(BASE_DIC)import core.ATMcore.ATM.start()# 定制程序的入口就结束啦 使用标准目录后引用配置文件在上述的case中，我们把文件的路径等配置文件，放在了 settings.py 文件中，那么我们在ATM中要使用这些配置文件，就需要导入config下的settings.py 12345678910# file: 'ATM.py'# 导入配置文件 settings.pyfrom config import settingsdef login(): with open(settings.DB_PATH,'rt',encoding='utf-8') as read_f: # 这里用settings.DB_PATH来调用读取文件路径 print(read_f.read()) ... 引用自定义模块为之前的功能添加日志功能 12345678910111213141516# file: 'common.py'# 导入配置文件 config 下的 settings 模块from config import settings# 新增一个日志功能def logger(msg): with open(settings.LOG_PATH,'at',encoding='utf-8') as write_f: write_f.write(msg) # file: 'ATM.py'from lib import commondef login(): with open(DB_PATH,'rt',encoding='utf-8') as read_f: print(read_f.read()) print('Login') common.logger('XXX登陆系统\n')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——字典dict]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8dict%2F</url>
    <content type="text"><![CDATA[什么是字典字典是一种可变容器模型，且可以储存任意类型对象。为什么称之为字典，是因为，在使用过程中就像查字典，你要查 ‘apple’ 这个单词，你通过首字母，会先查找 ‘a’ ——&gt; ‘p’——&gt;’p’ 然后你就找到了 ‘apple’ ,而不需要像列表一样从第一个元素开始找到最后一个元素，所以某种程度上来说，字典要比列表快的多，而 list 越大，查找就越慢。 定义：在{}内用 ‘,’ 分隔开多个 key:value ，通常 key 必须是一个不可变的类型，而通常呢我们使用字符串来表达key，用来描述 value 的特征， 而value可以是任意数据类型。 12345678# e.g.info=&#123; 'name':'David', 'age':18, 'gender':'male', 'height':180, 'hobbies':['programming','read','fitness']&#125; 字典的特性 字典value可以是任何的python对象，但key不行。 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个值会被记住 key必须不可变， 所以可以用数字，字符串或元组充当，而用列表就不行 能存多个值 无序 可变（值可以变，id不变） 不可hash 字典的使用####访问字典里的值 123456789101112131415&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['name'] # 按key取值'David'&gt;&gt;&gt; info['age']18&gt;&gt;&gt; info['hobbies']['programming', 'read', 'fitness']&gt;&gt;&gt; info['hobbies'][2] # 先按key取值，再按列表取值'fitness' 计算字典元素个数，即计算key的总数123456789&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; len(info)5 按key存取值：可存可取123456789101112131415161718&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['weight']=130 # 往字典里添加元素&gt;&gt;&gt; info&#123;'name': 'David', 'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness'], 'weight': 130&#125;# get&gt;&gt;&gt; a = info.get('name')&gt;&gt;&gt; a'David'&gt;&gt;&gt; a = info.get('nameXXX') # 取不到值 不会报错 会返回一个None&gt;&gt;&gt; print(a)None 删除元素12345678910111213141516&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; del info['name'] # 直接修改原值&gt;&gt;&gt; info&#123;'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness']&#125;&gt;&gt;&gt; info.clear() # 清空字典&#123;&#125;&gt;&gt;&gt; del info # 删除字典Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'info' is not defined 成员运算 in 和 not in1234567891011&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; 18 in info # 查看的是key是否在字典中False&gt;&gt;&gt; 'age' in infoTrue 循环12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; for k in info.keys() # 取key... print(k)...nameagegenderheighthobbies&gt;&gt;&gt; for k in info: # 默认输出key... print(k)... nameagegenderheighthobbies# 取value&gt;&gt;&gt; for v in info.values():... print(v)... David18male180['programming', 'read', 'fitness']&gt;&gt;&gt; for k,v in info.items(): # 同时取出key 和 value... print(k,v)...name Davidage 18gender maleheight 180hobbies ['programming', 'read', 'fitness'] 快速创造一个字典123456789# fromkeys:需求是快速新造出一个字典，value的初始值全部都为None# key来自一个列表&gt;&gt;&gt; keys = ['name','age','gender']&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; for k in keys:... d[k] = None&gt;&gt;&gt; d=&#123;&#125;.fromkeys(keys,None)&gt;&gt;&gt; print(d)&#123;'name': None, 'age': None, 'gender': None&#125; setdefault12345678910&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; res = info.setdefault('age', 123456) # 在key存在的情况下不修改值,会返回原值&gt;&gt;&gt; res 18]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——列表list]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8list%2F</url>
    <content type="text"><![CDATA[1. 什么是列表 list列表 list 是 Python 内置的一种数据类型。在[]用逗号分隔开多个任意类型的值，通常用来描述同一种类型的值，放入列表。 list 的特点： 有序 存多个值 可以按索引村取值 可以随时添加和删除其中的元素 可变类型（可变：值可变，id不变） 不可hash 2. 如何使用列表 list 获取列表 list中元素的个数 12345&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# len() 是 Python 的内置函数之一,主要功能是返回对象的长度或者项目个数# 对象可以是（字符串、列表、元祖、集合、字典）&gt;&gt;&gt; len(name) 4 取列表中重复的元素 123&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose','Nick']&gt;&gt;&gt; name.count('Nick')2 按索引取值 12345678910111213141516&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0] # 按索引来访问list中每一个位置的元素，位置从0开始计算'David'&gt;&gt;&gt; name[1]'Nick'&gt;&gt;&gt; name[-1] # 索引 -1 代表直接取到列表的最后一个值 也就是倒数第一个值'Rose'&gt;&gt;&gt; name[-2] # 依次类推 可以取倒数第二个值'Rachel'&gt;&gt;&gt; name[4] # 当索引取4时，列表索引超过了范围，就会提示你列表索引超过了范围Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range# 最后一个元素的索引可以 可以用 元素个数减1 也可以表示为 len(name)-1 按值找索引 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.index('Rachel')2&gt;&gt;&gt; name.index('Lily')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'Lily' is not in list 添加元素 123456789101112131415161718192021222324252627&gt;&gt;&gt; name = [] # 声明一个空列表# append&gt;&gt;&gt; name.append('David')&gt;&gt;&gt; name # 打印列表['David'] &gt;&gt;&gt; name.append('Nick')&gt;&gt;&gt; name['David', 'Nick'] # .append()追加 在列表最后一个元素后边追加元素&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.append(new_name)['David', 'Nick', ['Jack', 'Lily']]# 我们看到结果是append 将一整个new_name作为一个整体传入name中作为一个元素# extend# 那其实我们还有另外一种添加的方法 .extend()# .extend()可以把new_name中的元素一个一个加入到name中&gt;&gt;&gt; name = ['David','Nick']&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.extend(new_name)['David', 'Nick', 'Jack', 'Lily']# 那么如果想要在指定位置追加元素呢&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name.insert(1,'Jim') # insert(你想插入的位置，插入的内容)&gt;&gt;&gt; name['David', 'Jim', 'Nick', 'Rachel'] 删除元素 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# pop&gt;&gt;&gt; name.pop() # 默认删除列表最后一个元素 并且有返回值 ‘Rose’ 改变原列表'Rose'&gt;&gt;&gt; name['David', 'Nick', 'Rachel']&gt;&gt;&gt; name.pop(1) # pop写入索引 按索引删除指定位置的元素'Nick'&gt;&gt;&gt; name&gt;&gt;&gt; ['David', 'Rachel']# del&gt;&gt;&gt; del name[0] # 按索引删除 name列表中的元素&gt;&gt;&gt; name['Rachel']# remove&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.remove(0) # 尝试用索引Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# 报错 参数x 不在list中&gt;&gt;&gt; name.remove('Rachel')&gt;&gt;&gt; name # 可以看出remove的参数 传入的必须是是list中的元素内容['David', 'Nick', 'Rose']# clear&gt;&gt;&gt; name.clear() # 不会返回一个列表，而是返回给你一个内存地址 &lt;built-in method clear of list object at 0x1048b0148&gt;&gt;&gt;&gt; name.clear()&gt;&gt;&gt; name[] # 清空列表 替换元素 123456&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[1] = 'Mary' # 将索引[1]位置的元素替换成 'Mary'&gt;&gt;&gt; name['David', 'Mary', 'Rachel', 'Rose']&gt;&gt;&gt; name[-1] = 'Jack' # 同理正反取索引 都以用来替换元素['David', 'Mary', 'Rachel', 'Jack'] 列表的嵌套 1234567891011&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name_2 = ['Rose', name]&gt;&gt;&gt; name_2['Rose', ['David', 'Nick', 'Rachel']]# 如何取值 取到'Nick'# name_2 = ['Rose', name] 其实就是在name_2的列表中套了一个name# 在这里可以把name看作是name_2中的元素# 我们要取到name中的'Nick' 就需要先取值 取到name_2中的 name元素# 然后再取 name 中的'Nick'元素 所以我们就可以怎么干&gt;&gt;&gt; name_2[1][1]'Nick' 切片（有头，无尾，步长默认为1） 12345678910111213141516171819202122&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[0:3] # 返回值可以通过声明一个变量去接收['David', 'Nick', 'Rachel']# 有头指的是从索引[0]开始，无尾是取不到索引[3]= 'Rose'位置的值&gt;&gt;&gt; name # 不会改变原列表 ['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0:4:2] # 这里没有报超出索引范围的错误，可以看出只取到了[3]# 默认步长为1，这里改为2，意思就是为 一个 隔 一个 取值['David', 'Rachel']&gt;&gt;&gt; name[0:] # 意思为 从列表的头，取到列表的尾巴，就是取到元素最后一个值['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[1:]['Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[-2:] # 从倒数第二个值开始取，取到列表的尾巴['Rachel', 'Rose']&gt;&gt;&gt; name[:-1] # 从最开头，取到倒数第一个值，有头无尾，所以不会取最后一个值['David', 'Nick', 'Rachel']&gt;&gt;&gt; name[:-2]['David', 'Nick']&gt;&gt;&gt; name[:] # 不传入任何参数，就是从头取到尾['David', 'Nick', 'Rachel', 'Rose'] 成员运算 in和not in 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; 'David' in name # 判断name这个列表中是否有'David',然后返回一个布尔值True&gt;&gt;&gt; 'Lily' in nameFalse&gt;&gt;&gt; 'Lily' not in name # 判断name这个列表中 没有'Lily',然后返回一个布尔值True 循环 12345678&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; for item in name: ... # for 循环通常用来取值 这里将name列表中的元素一个一个取出来... print(item)DavidNickRachelRose 排序 1234567891011121314151617181920&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# reverse 反转列表&gt;&gt;&gt; name.reverse() # 直接改变原列表，反转&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[::-1] # 通过切片的方式反转列表['Rose', 'Rachel', 'Nick', 'David']# sort 对原列表排序&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.sort(reverse = True) # 直接改变原列表，反转，无返回值&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']# 默认参数 sort(cmp = None,key = None,reverse = False)# cmp: 按照传入参数的方法进行排序，还没学到# key：主要用来进行排序，只有一个参数，具体的函数参数取自可迭代对象中，指定可迭# 代对象中的一个元素来进行排序（先不管，还没法理解）# reverse = False(默认序列) reverse = True (反转序列)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LoveMyCountry]]></title>
    <url>%2F2018%2F10%2F11%2FLoveMyCountry%2F</url>
    <content type="text"><![CDATA[I Love My Country前言​ 今天讲的这个话题其实可以说比较敏感的，得益于github pages拒绝百度爬虫，让我在这里敢写下这篇blog——关于‘爱国上网’。写这篇帖子的初衷非常简单，希望大家能多用于学习和开拓眼界。 申明须知严格禁止任何人使用海外、国内VPS主机、服务器用于违规、违法用途。严禁个人售卖行为！严禁个人售卖行为！严禁个人售卖行为！重要的事说三遍！正文由于我个人正在使用的服务器是来自Bwh,个人建议是优先选择CN2机房方案，因为联通和电信都是直连，白天和晚上的速度都比较稳定，虽然偶尔也会抽风但是相比普通线路机房会好很多。但是如果我们不追求速度要求的话，普通KVM和OVZ方案也是可以选择的。那么在这篇文章里呢我推荐大家购买kvm，由于前几年都是使用kvm方案，网速并没有什么大碍且在Bwh中性价比极高。其实服务器有很多，但是bwh对于新手和不想深入了解只想自己使用的人而言，无疑非常容易上手，因为它服务器有一键式的ss安装。其实曾今在国内我购买过阿里云的香港服务器，很不幸没活过2个月。 一、新注册搬瓦工账户入口 点击此处进入注册网址 我们可以看到下图所示，看到当前所有的搬瓦工VPS可购买的配置型号。我们直接创建账户是不行的，我们需要先找一个可以购买的机器，Order Now购买，在这里我们选择购买，但是我们最后不付款，只进行注册！不付款！只进行注册！ 下一步 点击Add to Cart 接着点击 Check out 这里不会支付，放心点吧！只是为了假装支付进入他的注册页面，因为正常的注册界面有验证码，无法验收所以必须要曲线救国。 这里就比较关键，我们需要输入新注册账户的个人信息。全部用拼音填写，尽量真实一点，尤其是国家和地区部分需要真实。你乱写容易出现欺诈订单和不通过。其次，也可以看到付款方式有paypal和alipay，相比较而言国内小伙伴应该alipay用的比较多。 在这里我们可以选择好alipay，然后下方的 terms of service打勾，点击complete order，这里回跳转到支付页面只要退出，回到主页就可以通过登陆，登陆新账号啦。 二、选择服务器这里的话，我只推荐Basic VPS - Self-managed - SPECIAL 10G KVM PROMO V3 - LOS ANGELES - CN2大家可以直接点击这个网址进入网址挑选购买，每个月500g的流量，机房是losangeles-cn2，年费为29.99美金/年，对于我上社交软件，查资料，甚至看视频，几乎没有障碍，十分稳定，流量也足够我挥霍。 这里点几Order Now进入购买页面 ————&gt; 下一页面点击Add to Cart 然后进入购物车页面，点击Checkout，记得要登陆后购买！支持支付宝alipay付款 三、配置服务器付款成功后，进入主页，在主页点击client area 点击你的服务器services中 选择 my services 然后你会看见你刚刚购买的服务器，点击KiwiVM Control Panel进入控制台 如果你发现你的operating system和我不一样 不是Centos 6 x86_64 bbr,请点击这个页面中的stop停止你的服务器，然后进入左边Install new OS，找到相印的版本安装。 安装完成后点击 四 配置上网Win10/macos用户看这里： 你获取了你的加密、端口和密钥后，只要进行最后一步配置就可以啦。我们需要下载shadowsocks,那么根据不同用户呢有不同的下载地址，点击下方地址就可以啦。 win10: https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E macos： https://github.com/shadowsocks/ShadowsocksX-NG 至于 安卓和ios下的安装和使用，你可以直接联系我啊！实在是太复杂了，就不一一赘述啦。 看不懂请谷歌百度 下载完成后我们要进行配置啦 大同小异，这里我统一用mac版来做范例了 打开那个纸飞机，它会出现在你的菜单栏上 找到servers——&gt;进入 server preferences 其中ip地址在你的刚刚服务器的控制台的main controls中找的到，ip地址后的端口和其余的都在shadowsocks server中能找到。 当你把所有的东西都弄好后，你就可以享受全世界啦！ Hello world! 然后稍微介绍一下这个小飞机的用途： 它分 PAC模式 和 Global 模式，意思也很简单，pac模式下，国内能打开的网址走国内，打不开的网址走服务器，global模式下所有网址一律走服务器。建议使用pac，有特殊情况使用global，开了global也别忘了关。 有任何问题联系我哦 完结]]></content>
      <categories>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages & Hexo 搭建个人blog]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BAblog%E2%80%94%E2%80%94Github%20Pages%26Hexo%2F</url>
    <content type="text"><![CDATA[前言趁着今天自习的机会，本着想花费一上午的时间来解决github pages&amp;hexo搭建个人blog，结果啊整整花了一天，头一低一抬，8点又8点了。之所以有这个欲望是因为，之前都是用博客园写blog，第一天被学长瞅见，学长：low 逼！我也觉得low，苦在真的没空抽身搭建这个github pages，今天总算是忙里偷闲。 这个真的超级酷！！！！ 其实搭建差不多花了俩三个小时吧，踩了不少坑。不过最让人兴奋的就是搭建好的时候，开始慢慢美化自己的blog的过程，真是美妙啊。那么这次和我一起研究搭建个人blog的呢，还有我的室友Musibii。那么当然不出意外的，我们也是借鉴了许许多多过去的经验贴啊，没想到还是踩了一个又一个的坑啊。好了，废话不多说，那么开始我们的表演吧。 Github注册那么既然我们要使用github pages，肯定就需要一个github的账号。点击 Github 这个进入主页，然后点击右上角 sign up 一通操作后……恭喜你，成为了全球最大的同性交友网站的一员。（建议注册时用户名最好不要有大写字母！） 注册后，你就需要搭建一个库，点击左下方new repository，开始建库。 点击下边的create repository就注册成功啦。 这时候点击右上角的头像，选择your repositories，就可以看见你的库里有一个项目啦。 Hexo这里我和Musibii在Hexo和Jekyll两个最流行的blog框架中，选择了Hexo(js速度比较快吧，其次据说学习成本低，没感觉低) Hexo 基于Nodejs，如果你不是很熟悉这些不知道什么玩意的东西的话呢，暂时也不用深究，接下来的每一步都要小心小心仔细仔细，就ok啦。 安装git $ brew install git // 安装Git brew 是 homebrew 的功能之一，所以你需要install homebrew，这些安装都在你的终端/terminal当中完成，具体的安装homebrew命令官方网站中有。 安装nodejs 安装nodejs呢，需要先安装nvm，nvm是nodejs的版本管理器，用来切换nodejs的版本，这里建议用curl方式安装，homebrew安装的方式会少文件夹，导致后边无法正常安装。 $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装完成后重启你的terimal，再安装nodejs。 $ nvm install 8 需要注意的是后边的8是nodejs的版本号，如果你隔了很久搜到了这篇帖子，请去查寻最新的nodejs的版本，否则会导致你的版本过低而在安装过程中出现warning，最后导致error。 安装hexo 完成以上安装再安装hexo $ sudo npm install hexo-cli -g 到这里呢所有的工具都已经安装好了 编写发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(你的用户名.github.io) 创建博客 下边出现的所有username都需替换成你自己的username $ hexo init username.github.io 成功后会创建出一个名为 username.github.io的文件夹 更改配置 主题安装 我们为了使博客好看点，这里我们需要安装一个主题，在terminal中，进入刚刚生成username.github.io的文件夹目录，安装主题。 $ cd username.github.io $ git clone https://github.com/iissnan/hexo-theme-next themes/next 这是我现在用的主题。 基础配置：我们可以在 文件夹中 打开username.github.io的文件夹 如果你不会vim之类的话，macos就是通过finder，找到username.github.io的文件夹下的_config.yml修改几个基础配置，注意配置的：后必须要有空格 title: MakeUpStories //你博客的名字 author: oOC //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改。 可以先去hexo next官网中，查看官方文档，把基础的看完，你就可以去简书啊之类的查看更加进阶的设置，目前我的设置页十分的基础。 写文章 写文章的话我这里直接用的内置username.github.io/source/_posts下的helloworld.md文件进行测试。 测试 $ hexo s 进行服务器测试，在终端中你会收到返回信息，在https://localhost:4000中你可以查看当前的blog是什么样子的。 安装hero-deployer-git工具 如果之前一切都顺利的话，在这里就可以设置自动部署发布工具啦 $ npm install hexo-deployer-git --save 发布 最后的最后，如果你的测试一切都ok，没有问题的话，我们就生成一个静态网页文件发布至我们的github pages当中啦。 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在输入命令之后，会让你输入github的邮箱！！一定是邮箱和密码，别以为用户名能登陆就用用户名，一定要用邮箱啊！然后你的blog就被上传至github了，以后写完blog，都要执行一下这个命令上传blog。 最后：我的bloghttps://makeupstories.github.io/ 这是我的第一篇blog，之后有空的话，我还会更新如何搭建科学上网，以及在mac系统上比较好用的app和小插件，另外还有我的python学习之路。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
