<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[re 正则表达式]]></title>
    <url>%2F2019%2F04%2F02%2Fre%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式入门参考match()match()方法会从 字符串的起始位置匹配正则表达式 ，如果匹配，就返回匹配成功的结果，如果不匹配，就返回none。 基本使用12345678import recontent = 'Hello 123_456_789 World! This is a Regex Demo!'result = re.match('^Hello\s\d&#123;3&#125;_\d&#123;3&#125;_\d&#123;3&#125;\s\w&#123;5&#125;!\s\w&#123;4&#125;',content)print(result) # 返回SRE_Match object 对象 证明匹配成功print(result.group()) # group()方法输出匹配到的内容print(result.span()) # 输出匹配的范围 匹配目标1234567# 匹配目标result = re.match('^Hello\s(\d&#123;3&#125;_\d&#123;3&#125;_\d&#123;3&#125;)\s\w&#123;5&#125;!\s(\w&#123;4&#125;)',content)# 用括号将想提取的子字符串括起来，再使用group()方法传入分组的索引即可获取print(result)print(result.group(0)) # 索引0 为匹配到的所有内容print(result.group(1)) # 分组的索引从1开始获取print(result.group(2)) 通用匹配 &amp; 贪婪与非贪婪12345678# 通用匹配# . 可以匹配任意字符# * 可以匹配前面的字符无限次# .*可以匹配任意字符任意次数result = re.match('Hello.*is',content) # 贪婪匹配 一直匹配到最后一个isprint(result.group())result =re.match('Hello.*?is',content) # 非贪婪 匹配到第一个is就结束print(result.group()) 修饰符1result = re.match('Hello.*is',content,re.S) # 传入修饰符 re.I：忽视大小写 re.L：做本地化识别匹配 re.M：多行匹配，影响^和$ re.S：使.匹配包括换行在内的所有字符 re.U：根据Unicode字符集解析字符，影响\w,\W,\b,\B re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 转义匹配当遇到使用正则匹配模式的特殊字符时，在前面加上 ’ \ ’ ，来匹配原始字符。 search()search()在匹配时，会扫描整个字符串，然后返回第一个成功匹配的结果，成功匹配返回匹配内容，如果匹配失败返回None。和match()的区别，match更适合用来检测字符串是不是符合正则表达式的规则，而search匹配字符串内是否有符合正则表的是规则的内容。使用方法与match()大同小异。 findall()findall()是爬虫用到最多的方法，它会搜索整个字符串，然后返回匹配正则表达式的所有内容。爬虫是爬数据，所以返回内容才是最关键的。如果有返回的话，就是返回一个列表类型，列表内的元素是元组类型，所以需要遍历来依次获取每组内容。 sub()12345678import recontent = '123abc456def789ghi'# re.sub(正则表达式，替换的字符串，原字符串)content = re.sub('\d+','',content)# 可以在提取html文本时，去除某些标签，再处理print(content)# abcdefghi compile()可以将正则表达式编译成正则表达式对象，可以在之后的匹配中复用。 123content = 'aabcdefg'pattern = re.compile('.*')result = pattern.findall(content)]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests —— 高级用法]]></title>
    <url>%2F2019%2F04%2F01%2Frequests%20%E2%80%94%E2%80%94%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[文件上传假设网站需要上传文件 1234567891011import requestsurl = 'http://httpbin.org/post'files = &#123;'file': open('zhihu.ico','rb')&#125;response = requests.post(url,files=files)print(response.content.decode('utf-8'))'''返回结果中，会包含files这个字段，文件上传部分会有单独的一个files字段来标识''' Cookies获取cookies12345678910111213import requestsurl = 'https://www.baidu.com'response = requests.get(url)cookies = response.cookies # 调用属性，就可以获取cookiesprint(cookies)print(type(cookies)) # &lt;class 'requests.cookies.RequestsCookieJar'&gt;print(cookies.items())for key,value in cookies.items(): # items() 函数以列表返回可遍历的(键, 值) 元组数组 print(key + '=' + value) 设置cookies12345678910111213141516171819202122232425262728293031import requests# 方法一# 在请求头中设置cookiesurl = 'https://www.zhihu.com/'headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'Cookie':'_zap=0df13f80-d87a-49b2-96cc-9d6d273f2885; _xsrf=pb7rDOJOaTLuBJHwyXnmXgN5xymEnBRq; d_c0="ACCnyLQ1Mw-PTt2OEfvgHr-AOdrHqMaxN48=|1553914668"; capsion_ticket="2|1:0|10:1553914672|14:capsion_ticket|44:NzFjMTUxOTIxNGI5NGQwM2E3MGY3YTdhZDQ2MmRjYjI=|660aaad910034e33b82ace8e93e26c42a8c1a1a516c69a7dfddf46aa0437d5fd"; z_c0="2|1:0|10:1553914680|4:z_c0|92:Mi4xVEFGbUFnQUFBQUFBSUtmSXREVXpEeVlBQUFCZ0FsVk5PQ21NWFFDcGFpT1VNbDFkcGJGN3JuUE1NVEUzdXh0Ql9n|d5e16e9f0689f70cde64fbaa325cf91a8c45560e39baa148de87afe1dcac42bc"; q_c1=ead1b63c011541af9c216e9547d4f107|1553914681000|1553914681000; __utma=51854390.919096901.1554105033.1554105033.1554105033.1; __utmb=51854390.0.10.1554105033; __utmc=51854390; __utmz=51854390.1554105033.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmv=51854390.100--|2=registration_date=20151221=1^3=entry_date=20151221=1; tgw_l7_route=116a747939468d99065d12a386ab1c5f; tst=r', 'referer': 'https://www.zhihu.com/'&#125;response = requests.get(url,headers=headers)print(response.status_code) # 200# 方法二# 设置cookies参数cookies = '_zap=0df13f80-d87a-49b2-96cc-9d6d273f2885; _xsrf=pb7rDOJOaTLuBJHwyXnmXgN5xymEnBRq; d_c0="ACCnyLQ1Mw-PTt2OEfvgHr-AOdrHqMaxN48=|1553914668"; capsion_ticket="2|1:0|10:1553914672|14:capsion_ticket|44:NzFjMTUxOTIxNGI5NGQwM2E3MGY3YTdhZDQ2MmRjYjI=|660aaad910034e33b82ace8e93e26c42a8c1a1a516c69a7dfddf46aa0437d5fd"; z_c0="2|1:0|10:1553914680|4:z_c0|92:Mi4xVEFGbUFnQUFBQUFBSUtmSXREVXpEeVlBQUFCZ0FsVk5PQ21NWFFDcGFpT1VNbDFkcGJGN3JuUE1NVEUzdXh0Ql9n|d5e16e9f0689f70cde64fbaa325cf91a8c45560e39baa148de87afe1dcac42bc"; q_c1=ead1b63c011541af9c216e9547d4f107|1553914681000|1553914681000; __utma=51854390.919096901.1554105033.1554105033.1554105033.1; __utmb=51854390.0.10.1554105033; __utmc=51854390; __utmz=51854390.1554105033.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmv=51854390.100--|2=registration_date=20151221=1^3=entry_date=20151221=1; tgw_l7_route=116a747939468d99065d12a386ab1c5f; tst=r'headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'referer': 'https://www.zhihu.com/'&#125;# 构造RequestsCookieJar对象jar = requests.cookies.RequestsCookieJar()# 分割cookiesfor cookie in cookies.split(';'): key,value = cookie.split('=',1) jar.set(key,value) # 利用set()方法设置好每个cookie的key和valueresponse = requests.get(url,cookies=jar,headers=headers)print(response.status_code) Session 会话维持直接利用get或者post方法的确可以模拟登陆，但是实际上，每一次的get或者post相当于打开了不同的会话。例如当你第一次使用post()登陆了知乎后；第二次想获取登陆成功后的个人信息页面，实际上你是打开了一个新的会话窗口，与第一次会话无关，所以你无法获取个人信息页面，当然你可以在第二次的请求中携带cookies，但是每次请求都要携带十分的繁琐，这时候我们就可以利用Session来维持会话。Session对象会帮你维护一个会话，自动处理cookies。 12345678910111213141516171819202122import requestsurl = 'https://www.zhihu.com'headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3683.86 Safari/537.36', 'Cookie':'_zap=0df13f80-d87a-49b2-96cc-9d6d273f2885;', 'referer': 'https://www.zhihu.com/'&#125;response = requests.get(url,headers=headers)print(response.status_code)url_userinfo = 'https://www.zhihu.com/settings/account'headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36', 'referer': 'https://www.zhihu.com/'&#125;response = requests.get(url_userinfo,headers=headers)print(response.status_code)session = requests.Session()response = session.get(url_userinfo,headers=headers)print(response.status_code) SSL 证书当发送http请求的时候，会检查ssl证书，使用verify参数来控制是否检查这个证书，默认是True，会自动检验。 1234567891011import requestsurl = 'https://www.12306.cn'response = requests.get(url,verfiy=False)print(response.status_code) #200# 它会给我们发送一个警告，我们还可以通过设置忽略警告来屏蔽他from requests.packages import urllib3urllib3.disable_warnings()response = requests.get('https://www.12306.cn',verify=False)print(response.status_code) 代理大规模爬取数据的时候，需要设置代理，以免客户端直接封禁我们的ip。 12345678910import requestsurl = 'https://www.taobao.com'proxies = &#123; 'http':'0.0.0.1:0000', 'https':'0.0.0.1:0000'&#125;response = requests.get(url,proxies=proxies)print(response.status_code) 超时设置12345678import requestsurl = 'https://www.taobao.com'response = requests.get(url,timeout= 0.1)print(response.status_code)response = requests.get(url,timeout=(5,30)) # timeout=(connect,read)response = requests.get(url,timeout=None) # 永久等待 默认为None 身份认证1234567891011import requestsurl = 'https://localhost:5000'response = requests.get(url, auth=('username', 'password')) # 简写'''本质是：from requests.auth import HTTPBasicAuthresponse = requests.get(url,auth=HTTPBasicAuth('username','password'))'''print(response.status_code) Prepared Request讲请求表示为数据结构，其中各个参数都可以通过一个Request对象来表示。 1234567891011121314from requests import Request,Sessionurl = 'http://httpbin.org/post'data = &#123; 'name':'David'&#125;headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36',&#125;s = Session()request = Request('POST',url,data=data,headers=headers)prepped = s.prepare_request(request)r = s.send(prepped)print(r.status_code)]]></content>
      <categories>
        <category>requests</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests —— 基本用法]]></title>
    <url>%2F2019%2F04%2F01%2Frequests%20%E2%80%94%E2%80%94%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[请求类型requests可以用一句话来处理请求的类型。 12345r = requests.get('http://httpbin.org/get')r = requests.post('http://httpbin.org/post')r = requests.delete('http://httpbin.org/delete')r = requests.head('http://httpbin.org/get')r = requests.options('http://httpbin.org/get') GET请求基本使用1234567891011121314151617import requestsurl = 'http://httpbin.org/get'r = requests.get(url)print(type(r)) # &lt;class 'requests.models.Response'&gt;print(r.text)print(type(r.text)) # &lt;class 'str'&gt;print(r.content)print(type(r.content)) # &lt;class 'bytes'&gt;print(r.content.decode())print(r.status_code) # 状态码print(r.headers) # 响应头print(type(r.headers))print(r.cookies)print(type(r.cookies)) # &lt;class 'requests.cookies.RequestsCookieJar'&gt;print(r.url)print(r.history) # 得到请求历史 GET请求添加参数1234567891011121314151617181920212223242526import requestsdata = &#123; 'name':'David', 'age':22&#125;response = requests.get('http://httpbin.org/get',params=data)print(response.text) # 返回的是'str'类型，并且是JSON格式print(response.json())print(type(response.json())) # 返回的是'dict'类型'''&#123; "args": &#123; "age": "22", "name": "David" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Host": "httpbin.org", "User-Agent": "python-requests/2.21.0" &#125;, "origin": "61.171.88.179, 61.171.88.179", "url": "https://httpbin.org/get?name=David&amp;age=22"&#125;''' 添加请求头1234567891011121314import requestsurl = 'https://www.zhihu.com/explore'# 直接请求response = requests.get(url)print(response.status_code) # 400，不添加请求头的情况下，知乎会禁止你访问# 添加请求头headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'&#125;response = requests.get(url,headers=headers) # 添加请求头print(response.status_code) # 200 抓取二进制数据抓取图片、音频、视频等文件是二进制数据 1234567891011121314import requestsurl = 'https://static.zhihu.com/static/favicon.ico'response = requests.get(url)print(response.text) # 乱码# If Response.encoding is None, encoding will be guessed using# 编码格式没有设置的话，靠猜print(response.text.encode('utf-8')) # 就与content返回的数据一样print(response.content) # 二进制数据 bytes类型 无论怎么样最好都使用contentwith open('zhihu.ico','wb') as f: f.write(response.content) POST请求基本实例12345678910111213import requestsurl = 'http://httpbin.org/post'data = &#123; 'name':'David', 'age':'22'&#125;response = requests.post(url,data=data)print(response.content)print(response.content.decode('utf-8'))# 返回结果中的form部分就是我们提交的数据，这就证明了post请求成功了]]></content>
      <categories>
        <category>requests</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests]]></title>
    <url>%2F2019%2F04%2F01%2Frequests%2F</url>
    <content type="text"><![CDATA[requests —— 基本用法requests —— 高级用法]]></content>
      <categories>
        <category>requests</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib —— 解析]]></title>
    <url>%2F2019%2F03%2F31%2Furllib%20%E2%80%94%E2%80%94%20%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[urllib库还提供了parse模块，实现了URL个部分的抽取、合并以及链接转换。 解析方法： urlparse() urlunparse() urlsplit() urlunsplit() urljoin() urlencode()：用于构造GET请求参数 123456789from ullib.parse import urlencodeparams = &#123; 'name':'germey', 'age':22&#125;base_url = 'http://www.baidu.com'url = base_url + urlencode(params)print(url) parse_qs() parse_qsl() quote()：将内容转化成URL编码的格式，URL中带有中文时，会导致乱码的问题，用这个方法可以将中文字符转化为URL编码。 12345from urllib.parse import quotekeyword='爬虫'url = 'https://www.baidu.com/s?wd=' + quote(keyword)print(url) unquote()]]></content>
      <categories>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发送请求 —— urllib.request]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%20%E2%80%94%E2%80%94%20urllib.request%2F</url>
    <content type="text"><![CDATA[发送请求 - urllib.request使用urllib.request模块，提供了最基本的构造HTTP请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时还带有处理授权验证（authentication）、重定向（redirection）、浏览器Cookies 以及其他内容。 urlopen()urlopen() 的基本使用1234567import urllib.requestresponse = urllib.request.urlopen('https://www.baidu.com') # 报错print(response)print(type(response))print(response.read())print(response.read().decode('utf-8')) 报错：urllib.error.URLError: 解决：Python 坑之CERTIFICATE_VERIFY_FAILED 12345678910111213141516171819import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com/')# 完成最基本的简单网页的GET请求# 当然你也可以直接访问http://www.baidu.com,不带有ssl证书验证的http# 同时你访问带有ssl证书验证的网址时，有可能会拿不到htmlprint(response)print(type(response)) # &lt;class 'http.client.HTTPResponse'&gt;response = response.read()print(response)print(type(response)) # &lt;class 'bytes'&gt;response = response.decode('utf-8')print(response)print(type(response)) # &lt;class 'str'&gt;with open('baidu.html','w',encoding='utf-8') as f: f.write(response) class ‘http.client.HTTPResponse’ 是一个HTTPResponse类型的对象 包含read()、readinto()、getheader(name)、getheaders()、fileno()等方法 包含msg、version、status、reason、debuglevel、closed等属性 urlopen()函数的API123urllib.request.urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, *, cafile=None, capath=None, cadefault=False, context=None) data data=bytes(data),data接收的内容必须是bytes类型 一旦使用这个参数，请求方式变为POST 123456import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode(&#123;'Hello':'World'&#125;),encoding='utf-8')response = urllib.request.urlopen('http://httpbin.org/post',data=data)print(response.read()) timeout timeout参数用于设置超时时间，单位为秒，请求超过这个设置时间，还没有得到响应，就会抛出异常。 123456789101112import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get',timeout=0.1)print(response.read())'''运行结果： urllib.error.URLError: &lt;urlopen error timed out&gt; 错误原因超时 设置为超时时间为0.1秒，0.1秒过后，程序无响应，于是抛出URLError异常 URLError属于urllib.error模块，''' 设置超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。 123456789101112131415161718192021import urllib.requestimport urllib.errorimport sockettry: response = urllib.request.urlopen('http://httpbin.org/get',timeout=0.1)except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print('TIME OUT')'''判断异常是不是socket.timeout类型，就是超时异常，从而确定它确实是因为超时而报错isinstance(object,classinfo): 判断一个对象是否是一个已知的类型 object == classinfo isinstance 和 type() 的区别： type()不能判断子类的实例化对象是不是属于父类 推荐使用isinstance()''' context：必须是ssl.SSLContext类型，用来指定SSL设置 cafile：指定CA证书 capth：指定CA证书的路径 Request()使用urlopen()方法可以实现最基本的请求的发起，在之前的学习中， 就已经发现，它有一定的限制条件，并且可以从它的API接口中发现，参数也十分的简单，不足以构建一个完整的请求，那么Request类就能构建一个完整的需求。 Request()的基本使用1234567import urllib.request# 将请求独立成一个对象，这样可以丰富、灵活的配置参数request = urllib.request.Request('http://httpbin.org/get')# 依然使用urlopen来发送请求response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) Request()函数的API123urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None) url: 请求url，必传参数，其他都是可选 data: 和urllib.request.urlopen()中一样，必须传bytes类型 如果传的类型是字典，可以先用urllib.parse.urlencode()编码 headers： 是字典类型，请求头 可以在构造请求时通过headers参数直接构造 另一种方式通过调用add_headers()方法添加，动态添加 origin_req_host: 请求方的host名称或者ip地址 unverifiable: 表示这个请求是否是无法验证的，默认为False，意思就是用户没有足够的权限来选择接受这个请求的结果 method: 用来指示请求使用的方法，比如GET、POST、PUT等 1234567891011121314151617181920212223242526272829303132333435363738394041from urllib import request,parse# urlurl = 'http://httpbin.org/post'# 请求头headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'&#125;# post请求数据data = &#123; 'name':'David'&#125;# 传的类型是字典，所以要先用urllib.parse.urlencode()编码，指定编码格式为utf-8data = bytes(parse.urlencode(data),encoding='utf-8')# 构建POST请求request = request.Request(url=url,data=data,headers=headers,method='POST')response = request.urlopen(request)# bytes用utf-8解码print(response.read().decode('utf-8'))'''返回结果：&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "name": "David" # data传入的数据出现在form中，只有post请求才有 &#125;, "headers": &#123; "Accept-Encoding": "identity", "Content-Length": "10", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" &#125;, "json": null, "origin": "61.171.88.179, 61.171.88.179", "url": "https://httpbin.org/post"&#125;''' HandlerHandler中有各种处理器，例如专门处理登陆验证，处理cookies的，处理代理设置等，利用这些我们可以做到HTTP请求中的所有事情。 BaseHandler类BaseHandler类是，所有其他Handler的父类，它提供了最基本的方法，例如：default_open()、protocol_request()等 HTTPDefaultErrorHandler: 用于处理http响应错误，错误抛出HTTPError类型的异常 HTTPRedirectHandler:用于处理重定向 HTTPCookieProcessor:用于处理Cookies ProxyHandler:用于设置代理，默认代理为空 HTTPPasswordMgr:用于管理密码，它维护用户名和密码表 HTTPBasicAuthHandler:用于管理认证，当链接需要认证时，它可以解决认证问题 OpenerDirector类通常称OpenerDirector为Opener，之前的urlopen()和Request就是urllib为我们封装了极其常用的请求方法，更多功能需要用到底层的实例来完成操作，所以要用到Opener。 验证请求网站时，弹出提示框，提示你需要输入用户名和密码，验证后才能查看页面 12345678910111213141516171819202122from urllib.request import HTTPPasswordMgrWithDefaultRealm,HTTPBasicAuthHandler,build_openerfrom urllib.error import URLErrorusername = 'username'password = 'password'url = 'http://0.0.0.0/#/Auth/get_basic_auth__user___passwd_'p = HTTPPasswordMgrWithDefaultRealm()# 利用add_password添加进去用户名和密码p.add_password(None,url,username,password)# 建立一个处理验证的Handler# 实例化HTTPBasicAuthHandler对象，其参数是HTTPPasswordMgrWithDefaultRealm对象auth_handler = HTTPBasicAuthHandler(p)# 利用Handler使用build_opener()方法构建一个Openeropener = build_opener(auth_handler)try: result = opener.open(url) html = result.read().decode('utf-8') print(html)except URLError as e: print(e.reason) 代理爬虫免费代理 1234567891011121314from urllib.request import ProxyHandler,build_openerfrom urllib.error import URLErrorproxy_handler = ProxyHandler(&#123; 'http':'http://0.0.0.0:9999', # 可以去西刺copy两个注意区分http和https，当然还有socks服务器 'https':'https://0.0.0.0:9999'&#125;)opener = build_opener(proxy_handler)try: response = opener.open('http://www.baidu.com') print(response.read().decode('utf-8'))except URLError as e: print(e.reason) 爬虫付费代理 1234567891011121314151617# 方式一import urllib.request#1.用户名密码和代理username = 'username'password = 'password'proxy = '127.0.0.1:8080'#2.创建密码管理器,添加用户名和密码password_manager = urllib.request.HTTPPasswordMgrWithDefaultRealm()password_manager.add_password(None,proxy_money,use_name,pwd)#3.创建可以验证代理ip的处理器handle_auth_proxy = urllib.request.ProxyBasicAuthHandler(password_manager)#4.根据处理器创建openeropener_auth = urllib.request.build_opener(handle_auth_proxy)#5.发送请求response = opener_auth.open("http://www.baidu.com")print(response.read()) 123456789# 方式二#1.代理ipmoney_proxy =&#123;"http":"username:password@192.168.12.11:8080"&#125;#2.代理的处理器proxy_handler=urllib.request.ProxyHandler(money_proxy)#3.通过处理器创建openeropener = urllib.request.build_opener(proxy_handler)#4.open发送请求opener.open("http://www.baidu.com") Cookies获取网站cookies 12345678910111213import http.cookiejarimport urllib.request# 声明一个CookieJar对象cookies = http.cookiejar.CookieJar()# 利用HTTPCookieProcessor构建一个handlerhandler = urllib.request.HTTPCookieProcessor(cookies)# 构建openeropener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(type(cookies))for cookie in cookies: print(cookie.name + '=' + cookie.value) 将cookies保存为文件 1234567891011import urllib.requestimport http.cookiejar# 保存cookies的文件名filename = 'cookies.txt'# 生成文件时，需要用到MozillaCookieJar 是 CookieJar的子类，处理和cookies和文件有关的事件cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 从文件中读取cookies 1234567891011import urllib.requestimport http.cookiejar# 什么格式存的 就选什么格式cookie = http.cookiejar.MozillaCookieJar()# 用load()方法读取本地的cookies文件，获取cookies内容cookie.load('cookies.txt', ignore_expires=True, ignore_discard=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf-8'))]]></content>
      <categories>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib —— 处理异常]]></title>
    <url>%2F2019%2F03%2F30%2Furllib%20%E2%80%94%E2%80%94%20%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[处理异常URLErrorURLError类来自urllib库的error模块（urllib.error.URLError）,它继承自OSError类，是error异常模块的基类，处理由request模块产生的异常。1234567from urllib import request, errortry: response = request.urlopen('https://www.baidu.com')except error.URLError as e: print(e.reason)# [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847) HTTPErrorHTPError是URLError的子类，专门用来处理HTTP请求的错误，它有3个属性： code:返回HTTP状态码 reason:同父类一样返回错误的原因 headers:返回请求头 特性：因为URLError是HTTPError的父类，所以先捕获子类的错误再捕获父类错误 12345678910from urllib import error,requesttry: response = request.urlopen('https://www.baidu.com')except error.HTTPError as e: print(e.reason,e.code,e.headers,sep='\n')except error.URLError as e: print(e.reason)else: print('Request Successfully')]]></content>
      <categories>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib]]></title>
    <url>%2F2019%2F03%2F30%2Furllib%2F</url>
    <content type="text"><![CDATA[Python 3.6.7 Python3中整合了Python2中的urllib和urllib2两个库，统一为urllib，它是内置的HTTP请求库。 包含以下四个模块： request:最基本的HTTP请求模块，用来模拟发送请求。 error:异常处理模块。 parse:工具模块，提供了许多URL的处理方法，比如拆分、解析、合并等。 robotparser:用来是识别网站的robots.txt文件，判断哪些网站可以爬，哪些网站不可以爬，基本上忽视它。 发送请求 - urllib.request处理异常解析]]></content>
      <categories>
        <category>urllib</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取猫眼TOP100电影]]></title>
    <url>%2F2019%2F02%2F17%2FPython%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BCTOP100%E7%9A%84%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[目标提取出猫眼电影 TOP100 的电影名称、时间、评分、图片等信息，提取的站点为 http://maoyan.com/board/4，并将提取的结果以文件的形式保存下来。 抓取分析打开抓取的站点，发现第一页显示排行1-10的电影，第二页显示排行11-20的电影，但是url发生明显改变变为https://maoyan.com/board/4?offset=10比之前的多了一个参数offset=10，再点击第三页发现offset=20，可以推断出规律，offset代表偏移量值，如果偏移量为n，那么电影序号就为（n+1） ~（n+10），所以当我们想获取top100的电影，就需要分开10次请求，这样获取不同的页面后，再通过正则表达式提取出相关的信息，就可以了获取TOP100的所有电影信息了。 抓取首页抓取首页的源代码 1234567891011121314151617import requestsdef get_one_page(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36' &#125; response = requests.get(url, headers = headers) if response.status_code == 200: return response.text return Nonedef run(): url = 'http://maoyan.com/board/4' html = get_one_page(url) print(html) run() 正则提取获取首页的源代码之后，通过正则提取我们需要的信息。回到浏览器，再开发者模式下的Network监听组件中，查看源代码，我们可以发现一部电影的信息对应的源代码就是一个dd节点，我们用正则表达式来提取这里的一些电影信息。 提取它的排名信息，排名第一的电影为“霸王别姬”，它的排名信息在 class 为 board-index / board-index-1 的 i 节点内，这里采用非贪婪匹配提取 i 节点内的信息，正则表达式为：&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt; 提取电影的图片，在后边的 a 标签内发现有两个 img 节点，经检查后发现，第二个 img 节点是电影封面，故这里提取第二个节点的 data-src 属性，正则表达式为：&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot; 提取电影的名称，可以发现在后边的 class 为 name 的 p 节点中，其实这里有好几个地方都可以进行提取，书上提取了 a 节点中的文本信息，正则表达式为：&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name.*?a.*?&gt;(.*?)&lt;/a&gt; 再提取主演、发布时间、评分等内容时，都是同样的原理，最后的完整的正则表达式为：&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt; 接下来，通过调用findall()方法提取出所有的内容： 123456def parse_one_page(html): pattern = re.compile( '&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S ) items = re.findall(pattern, html) print(items) 可以看出当前提取出来的数据，还十分的乱，所以我们需要将匹配结果再处理一下，遍历提取结果并生成字典： 123456789101112def parse_one_page(html): pattern = re.compile('&lt;dd&gt;.*board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern, html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2].strip(), 'actor': item[3].strip()[3:], 'time': item[4].strip()[5:], 'score': item[5].strip() + item[6].strip() &#125; 写入文件将提取的结果写入文件，通过 JSON库的 dumps() 方法实现字典的序列化，并指定 ensure_ascii 参数为 False，这样可以保证输出结果是中文形式而不是 Unicode编码。 123456import jsondef write_to_file(content): with open('result.txt', 'a', encoding = 'utf-8') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii = False) + '\n') run()通过 run() 方法来调用前面实现的方法，将单页的电影结果写入文件。 12345def main(): url = 'http://maoyan.com/board/4' html = get_one_page(url) for item in parse_one_page(html): write_to_file(item) 分页爬取因为抓取的是 猫眼TOP100 的电影，所以还需要遍历一下，给这个链接传入offset的参数 12345678910def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_file(item)if __name__=='__main__': for i in range(10): main(offset=i * 10) 整合代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import jsonimport requestsimport refrom requests.exceptions import RequestExceptionimport timedef get_one_page(url): try: headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36' &#125; response = requests.get(url, headers=headers) if response.status_code == 200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern, html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2].strip(), 'actor': item[3].strip()[3:], 'time': item[4].strip()[5:], 'score': item[5].strip() + item[6].strip() &#125;def write_to_file(content): with open('result.txt', 'a', encoding='utf-8') as f: f.write(json.dumps(content, ensure_ascii=False) + '\n')def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_file(item)if __name__ == '__main__': for i in range(10): main(offset=i * 10) time.sleep(1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 坑之CERTIFICATE_VERIFY_FAILED]]></title>
    <url>%2F2019%2F02%2F17%2FPython-%E5%9D%91%E4%B9%8BCERTIFICATE-VERIFY-FAILED%2F</url>
    <content type="text"><![CDATA[最近跟着《Python3 网络爬虫开发实践》学习，在 “第3章 基本库的使用 =&gt; 3.1.1 发送请求 =&gt; urlopen()” 中遇到问题，当我使用书中的示例时，爆出一个错误如下图： 产生的原因，是因为Python升级2.7.9之后引入了一个新特性，当你urllib.urlopen一个 https 的时候，会验证一次 SSL 证书，当目标网站使用的是自签名的证书时就会爆出一个 urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:581)&gt; 的错误消息。 具体错误查看这里CERTIFICATE_VERIFY_FAILED 那么Python 提供了两个方法解决问题： 全局取消整数验证（当项目对安全性问题不太重视时，推荐使用，可以全局取消证书的验证，简易方便） 123import ssl ssl._create_default_https_context = ssl._create_unverified_context 使用ssl创建未验证的上下文，在url中传入上下文参数（当项目整体非常重视安全问题时，推荐这种方式，可以局部取消证书验证） 1234567import ssl import urllib2 # This restores the same behavior as before. context = ssl._create_unverified_context() # 将context传入url函数的context参数中print urllib2.urlopen("https://www.12306.cn/mormhweb/",context=context).read() 参考原文]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 基本原理]]></title>
    <url>%2F2019%2F01%2F24%2FHTTP%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[URI和URLURI (Uniform Resource Identifier)，即统一资源标志符。 URL(Universal Resource Locator)，即统一资源定位符。 URL 是 URI 的子集，每个 URL 都是 URI，但不是每个 URI 都是 URL。因为 URI 还包括一个子类叫做 URN(Universal Resource Name) ，即统一资源名称。所以 URL、URN 和 URI 的关系可以表示为如图： 目前在互联网中，URN 用的非常少，几乎所有的 URI 都是 URL ，一般的网页链接我们既可以称为 URL，也可以称为 URI，普遍大家都称之为 URL。 超文本超文本，叫做 hypertext [美: ‘haɪpɚ’tɛkst] [英: ‘haɪpətekst]。 网页的源代码 HTML 就可以称之为超文本。 HTTP 和 HTTPSURL 的开头有 http 和 https，这就是访问资源需要的协议类型，其他协议类型还有 ftp、sftp、smb 。 HTTPHTTP(Hyper Text Transfer Protocol)，中文名叫作超文本传输协议，HTTP 协议是用于从网络传输超文本数据到本地浏览的传送协议，它能保证高效而准确地传送超文本文档。 HTTPSHTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的 HTTP 通道，简单讲就是 HTTP 的安全版本，即 HTTP 下加入 SSL 层，简称为 HTTPS。 HTTPS 的安全基础是 SSL，因此通过 HTTPS 传输的内容都是经过 SSL 加密的，它的主要作用可以分为两种： 建立一个信息安全通道来保证数据传输的安全 确认网站的真实性 Chrome 下 f12 进入开发者模式Network当我们访问 www.baidu.com 时，Network会产生很多条目，其中一个条目就代表一次发送请求和接收相应的过程。 其中各列含义如下： Name：请求的名称，一般是 URL 最后一部分内容当做名称。 Status：响应的状态码，200表示响应正常，通过状态码，我们可以判断请求发送后是否得到了正常的响应。 Type：请求的文档类型。document，代表这次请求的是一个 HTML 文档。 Initiator：请求源。用来标记请求是由哪个对象或进程发起的。 Size：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 from cache。 Time：发起请求到获取相应所用的总时间。 Waterfall：网络请求的可视化瀑布。 点击 Name 下的条目 ，查看详细信息： 请求请求的方法常见的请求的方法有两种：GET 和 POST。 在浏览器中直接输入 URL 并回车，就发起了一个 GET 请求，请求的参数会直接包含到 URL 中。POST 请求大多在表单提交时发起，例如登录表单，那么传输的数据通常会通过表单的形式进行传输，而不会体现在 URL 中。 GET 和 POST 区别： GET 请求中的参数包含在 URL 中，数据可以在 URL 中看到，而 POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。 GET 请求提交的数据最多只有1024字节，而 POST 方式没有限制。 一般包含敏感信息，使用POST发送，文件较大时，也会选用POST方式。 其他请求方法参考 请求的网址请求的网址，即 URL 统一资源定位符，它可以唯一确定我们想请求的资源 请求头请求头用来说明服务器要使用的附加信息，比较重要的有 Cookie、Referer、User-Agent 等。 Accept：请求报头域，用于指定客户端可以接受哪些类型的信息。 Accept-Language：客户端可接收的语言类型。 Accept-Encoding：客户端可接收的编码类型。 Host：指定请求资源的主机 IP 和 端口号，内容为请求 URL 的原始服务器或网关位置。 Cookie：网站为了辨别用户进行会话跟踪而存储在用户本地的数据，主要功能是维持当前访问会话。 Referer：识别这个请求是从哪个页面发过来的，服务器拿到这个信息做处理，用来做源统计、防盗链处理等。 User-Agent：简称 UA。可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时，加上这个信息可以伪装成浏览器。 Content-Type：叫做互联网媒体类型，他用来表示具体请求中的媒体类型信息。如：text/html 代表 HTML 格式，image/gif 代表 GIF 图片等等。参考 请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。 请求体请求体一般承载的内容是 POST 请求中的表单数据。GET请求时，请求体中为空。 在 Request Headers 中指定 Content-Type 为 application/x-www-form-urlencoded 时，才会以表单的形式提交，当设置为 application/json 时，是用来提交 JSON 数据，设置为 multipart/form-data时，是用来上传文件。 爬虫时，需要使用正确的 Content-Type，否则会导致 POST 提交后无法正常响应。 响应响应，由服务器返回给客户端，可以分为三个部分：响应状态码(Response Status Code)、响应头(Response Headers)和响应体(Response Body)。 响应状态码参考 响应头 响应头包含了服务器对请求的应答信息： Date：标识响应产生的时间 Last-Modified：标识资源的最后修改时间 Content-Encoding：响应内容的编码 Server：包含服务器的信息，名称和版本号 Content-Type：文档类型，指定返回的数据类型是什么。 Set-Cookie：设置 Cookies，告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。 Expires：指定响应的过期时间，让浏览器将加载的内容更新到缓存中，如果再次访问，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。 响应体在浏览器开发者工具中，Response中可以看到网页源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、JSON数据等。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础]]></title>
    <url>%2F2018%2F12%2F17%2FJavaScript%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaScript语言介绍概念 浏览器脚本语言，书写在script标签中 脚本：一段功能代码块，可以嵌套在其他语言中使用，完成一些额外的功能 可以编写运行在浏览器上的代码程序 属于解释性、弱语言类型编程语言 三个组成部分 ES语法：ECMAScript、主要版本ES5和ES6 DOM：文档对象模型(Document Object Model)，是W3C组织推荐的处理可扩展标志语言的标准编程接口。 BOM：浏览器对象模型(Browser Object Model)，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构；且由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。三种存在位置行间式：存在于行间事件中12345&lt;div onmouseover="this.style.color = 'red'" onmouseleave="this.style.color = 'orange'"&gt;Hello world!&lt;/div&gt;i） 行间式代码块书写在一个个全局时间名属性中ii） 在某一个标签的某一个事件属性值中，出现的this代表该标签iii）该标签对象this可以访问该标签的任意全局属性(style)，然后再间接访问具体需要操作的对象(style.color) 内联式：存在于页面script标签中123456789101112&lt;body&gt; &lt;div id="test"&gt;Hello world!&lt;/div&gt;&lt;/body&gt;&lt;script&gt; test.style.color = "pink";&lt;/script&gt;i）可以通过标签的id(唯一标识)，在js代码块中访问到该标签(js的选择器)ii）js代码块中语法采用的是小驼峰命名法，属性的值都是用字符串形式进行赋值iii）js属于解释性语言，所有加载顺序会影响执行结构 ---------------------------------------------- 解释性语言特性决定JS代码位置 外联式：存在于外部JS文件，通过script标签src属性链接123456789test.js文件test.style.backgroundColor='#0ff'index.html文件&lt;script src="./js/test.js"&gt;&lt;/script&gt;i）通过script标签的src数据链接外部js文件ii）使用外联的script(拥有src属性)标签，会屏蔽掉标签内部的js代码块iii）在js任意地方，均由this对象，this对象不指向任何标签时，指向的是window对象 解释性语言特性决定JS代码位置 出现在head标签底部：依赖型JS库 1234&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt;在这里&lt;/script&gt;&lt;/head&gt; 出现在body标签底部：功能型JS脚本 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; 在这里 &lt;/script&gt;&lt;/html&gt; JS语法规范 注释 1234// 单行注释/* 多行注释*/ 以分号作为语句结尾（允许省略） 变量的定义ES5定义变量12var num = 10; // 无块级作用域变量num = 10; // 全局变量 ES6定义变量12let num = 10; // 局部变量const NUM = 10; // 常量 12// ES5 | ES6// 是ECMAScript两个语法版本, ES6是ES5之后的一个版本, 但是对ES5向下兼容, ES6中支持ES5语法 四种定义变量的方式123456789101112131415161718四种定义变量的方式语法: 关键词 变量名 = 变量值num = 10; // 省略关键词, 定义的为全局变量, 在任何位置定义, 在任何位置都可以访问, 但不建议使用var num = 10; // var关键词, 无块级作用域, 定义在块级作用域中的变量, 外界也可以访问let num = 20; // let关键词, 有块级作用域, 定义在块级作用域中的变量, 外界无法访问const NUM = 30; // const关键词,有块级作用域, 定义在块级作用域中的变量, 外界无法访问, 且变量的值不能再被二次修改, 所以为常量/* 产生块级作用域的方式&#123; 直接书写&#125;if语句可以产生while语句可以产生for语句也可以产生*/// 函数可以产生局部作用域, 除了定义在局部作用域中的全局变量(没有关键字的变量声明), 外界可以访问, 其他定义方式, 外界都不可以访问 变量(标识符)的命名规范 由字母，数字，_，$组成，不能以数字开头（可以包含中文字符） 区分大小写 不能出现关键字及保留字 12345678// 命名规范// 变量命名规范// 可以由哪些组成: 字母, 数字, _, $, 中文(一般不考虑)// 可以以什么开头: 字母, _, $, 中文// 不能出现什么: 关键字, 保留字// 提倡什么书写规范: 小驼峰, 支持_连接语法好的 = "真好";console.log(好的); abstract arguments boolean break byte case catch char class* const continue debugger default delete do double else enum* eval export* extends* false final finally float for function goto if implements import* in instanceof int interface let long native new null package private protected public return short static super* switch synchronized this throw throws transient true try typeof var void volatile while with yield 三种弹出框 alert（）：普通弹出框 1alert("普通弹出框"); confirm（“确认框”）：确认框 12var res = confirm("你是猪吗?");console.log(res);//查看结果 prompt：输入框 1var info = prompt("请输入内容:"); 四种调试方式 alert() console.log() document.write() 和页面中原来的布局在一起出现 浏览器断点调试 数据类型值类型 number：数字类型 123456789var a = 10; //js不区分浮点什么的// 打印a的值和a的类型console.log(a, typeof a); // a 和 字符串的numberconsole.log(typeof a,a); // 是浏览器打印字符串的两种样式// 字符串以黑体，或是""括起来 都是字符串// 判断方式console.log(typeof a == 'number'); string：字符串类型 1234var a = '10'; //单双引号都一样console.log(a, typeof a)// 判断方式console.log(typeof a == 'string') //返回一个布尔值 boolean：布尔类型 1234var a = true;console.log(a, typeof a)// 判断方式console.log(typeof a == 'boolean') undefined：未定义类型 12345var a = undefined;console.log(a, typeof a)// 判断方式console.log(typeof a == 'undefined')console.log(a == undefined) 引用类型 function：函数类型 1234var a = function()&#123;&#125;;console.log(a, typeof a)// 判断方式console.log(typeof a == 'function') object：对象类型 12345var a = &#123;&#125;;console.log(a, typeof a)// 判断方式console.log(typeof a == 'object')console.log(a instanceof Object) 具体的对象类型 null：空对象 12345var a = null;console.log(a, typeof a)// 判断方式console.log(typeof a == 'object')console.log(a == null) Array：数组对象 123456var a = new Array(1, 2, 3, 4, 5);console.log(a, typeof a)// 判断方式console.log(typeof a == 'object')console.log(a instanceof Object)console.log(a instanceof Array) Date：时间对象 123456var a = new Date();console.log(a, typeof a)// 判断方式console.log(typeof a == 'object')console.log(a instanceof Object)console.log(a instanceof Date) RegExp：正则对象 123456var a = new RegExp();console.log(a, typeof a)// 判断方式console.log(typeof a == 'object')console.log(a instanceof Object)console.log(a instanceof RegExp) 4、类型转换 数字|布尔 转换为 字符串 123console.log((true + true) * 10 * false);// boolean类型的true就是数字1, false就是数字0// number 中 0, NaN 可以直接当false来使用, 其他的都可以当true来使用 布尔|字符串 转换为 数字 1234567891011121314151617181920212223var a = '10'; // =&gt; 10 a = '3.14'; // =&gt; 3.14 a = '3.14.15'; // =&gt; NaN var b = true;//字符串可以直接当数字用var n1 = Number(a); console.log(n1);//NaN var n2 = Number(b); console.log(n2);//1a = '3.14.15';console.log(parseFloat(a));//3.14a = '3.94.15'; console.log(parseInt(a));//3// 体现弱语言类型a = '10';var res = +a; // 没有 + 就是 string 10console.log(typeof(res), res); // number 10var res = a - 0 + 1; console.log(typeof(res), res); // number 11 字符串|数字 转换为 布尔 12var a = 10 or '10'Boolean(a)// True 自动转换 12345 + null // 5"5" + null // "5null""5" + 1 // "51""5" - 1 // 4 特殊产物 1234// NaN: 非数字类型// 不与任何数相等，包含自己// NaN与NaN不相等// 利用isNaN()进行判断 运算符算数运算符前提：n = 5 赋值运算符前提：x=5，y=5 运算符 例子 等同于 运算结果 = x=y 5 += x+=y x=x+y 10 -= x-=y x=x-y 0 *= x*=y x=x*y 25 /= x/=y x=x/y 1 %= x%=y x=x%y 0 比较运算符前提：x=5 运算符 描述 比较 结果 == 等于 x==”5” true === 绝对等于 x===”5” false != 不等于 x!=”5” fales !== 不绝对等于 x!==”5” true &gt; 大于 x&gt;5 false &lt; 小于 x&lt;5 false &gt;= 大于等于 x&gt;=5 true &lt;= 小于等于 x&lt;=5 true 逻辑运算符前提：n=5 三目运算符123456// 结果 = 条件表达式 ? 结果1 : 结果2;// eg:var tq = prompt("天气(晴|雨)")var res = tq == '晴' ? "今天天气挺好" : "请假回家收衣服";console.log(res); ES6语法解构赋值 数组的解构赋值 1234let [a, b, c] = [1, 2, 3]// a=1,b=2,c=3let [a, ...b] = [1, 2, 3]// a=1,b=[2,3] 对象的解构赋值 12let &#123;key: a&#125; = &#123;key: 10&#125;// a=10 字符串解构赋值 12let [a,b,c] = 'xyz'// a='x',b='y',c='z']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据表的基本操作]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据表的基本操作创建数据表​ 所谓创建数据表，指的是在已经创建好的数据库中建立新表。创建数据表的过程是规定数据列的属性的过程，同时也是实施数据完整性（包括实体完整性、引用完整性和域完整性等）约束的过程。 创建表的语法形式​ 数据表属于数据库，在创建数据表之前，我们需要指定我们操作哪个库下的哪个表，如果没有选择数据库会抛出‘No database selected’的错误。 ​ 创建数据表的语句为CREATE TABLE &lt;表名&gt;; 1234567CREATE TABLE &lt;表名&gt;(字段名1，数据类型[列级别约束条件][默认值],字段名2，数据类型[列级别约束条件][默认值],……[表级别约束条件]); ​ 使用CREATE TABLE创建表时，需要指定以下信息： 要创建的表的名称，不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等 数据表中每一个列（字段）的名称和数据类型，如果创建多个列，要用逗号隔开。 [e.g.] 首先创建数据库 test_db： CREATE DATABASE test_db; 你想要把表创建在哪个数据库，就选择使用哪个数据库： USE test_db; 创建一个名叫 tb_emp1的表： 1234567CREATE TABLE tb_emp1(id INT(11),name VARCHAR(25),deptid INT(11),salary FLOAT); 查看表是否创建成功： SHOW TABLES; （书P49页，第一句话中的tb_tmp1是错的，应该是tb_emp1） 另外，创建表之后还可以查看表结构 DESC tb_emp1; 使用主键约束​ 主键，又称做主码，是表中一列或多列的组合。主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不能为空。主键的作用有，能够唯一地标识表中的一条记录，可以结合外键来定义不同数据表之间的关系，并且可以加快数据库查询的速度（数据库最为重要的功能是查询！相信我，查询会让你头一个头两个大）。主键和记录之间的关系如同身份证和人之间的关系，它们之间是一一对应的，主键是约束条件，人是一条记录，人的名字、爱好等是属性也就是字段，字段组成了一个完整的人，也就是一条字段。 单字段主键​ 单字段主键由一个字段组成，sql语句格式分为以下两种情况。 在定义列的同时指定主键 12345678910111213141516CREATE TABLE 表名(字段名 数据类型 PRIMARY KEY [默认值], # [] 含义为 可有可无，没有就取默认值 # 包括 数据类型指定的长度也是可有可无，没有就取默认值 ...);# [e.g]CREATE TABLE tb_emp2(id INT(11) PRIMARY KEY,name VARCHAR(25),deptid INT(11),salary FLOAT); 在定义完所有列之后指定主键 12345678CREATE TABLE tb_emp3(id INT(11),name VARCHAR(25),deptid INT(11),salary FLOAT,PRIMARY KEY(id)); 查看结果，执行后发现结果一样，都在id 字段上设置了主键约束。 多字段联合主键主键由多个字段联合组成 PRIMARY KEY [字段1，字段2，... ，字段n] 定义数据表tb_emp4,假设表中没有主键id，为了确定一个员工，可以将name、depid联合起来作为主键。 1234567CREATE TABLE tb_emp4(name VARCHAR(25),deptid INT(11),salary FLOAT,PRIMARY KEY(name,deptid)); ​ 查看结果，可以看到创建了一个名称为tb_emp4的表，name字段和deptid字段组合在一起成为了tb_emp4的多字段联合主键。 使用外键约束​ 外键用来在两个的数据之间建立链接，它可以是一列或者多列，一个表可以有一个或者多个外键。外键对应的事参照完整性，一个表的外键可以为空值，若不为空，则每一个外键值必须等于另一个表中主键的某个值。 ​ 外键：首先它是表中的一个字段，它可以不是本表的主键，但对应另一个表的主键。外键主要作用是保证数据引用的完整性，定义外键后，不允许删除在另一个表中具有关联关系的行（记录）（可以删除没有关联关系的行）。 [e.g.] ​ 部门表tb_dept的主键是id，在员工表tb_emp5中有一个字段deptid与部门表tb_dept中的id关联。 ​ 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的那个表即是主表。 ​ 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的那个表即是从表。 创建外键的sql语法： 1234567CREATE TABLE tb_emp5(字段名 数据类型 约束条件， ...,[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名2[,字段名2,...]REFERENCES &lt;主表名&gt; 主键列1 [,主键列2,...]) ​ “外键名”为定义的外键约束的名称，一个表中不能有相同名称的外键；“字段名”表示子表需要添加外键约束的字段列；“主表名”即被子表外键所以来的表的名称；“主键列”表示主表中定义的主键列，或者列组合。 [e.g.] 创建一个部门表tb_dept1 123456CREATE TABLE tb_dept1(id INT(11) PRIMARY KEY,name VARCHAR(22) NOT NULL,location VARCHAR(50)); 定义数据表tb_emp5,让它的键deptid作为外键关联到tb_dept1的主键id 12345678CREATE TABLE tb_emp5(id INT(11) PRIMARY KEY,name VARCHAR(25),deptid INT(11),salary FLOAT,CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptid) REFERENCES tb_dept1(id)); [小tips] ​ 关联指的是在关系型数据库中，相关表之间的联系。它是通过相容或相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时，就会报错”ERROR 1005 (HY000):Can’t create table ‘database.tablename’(error:150)”。 使用非空约束​ 非空约束（Not Null Constraint）指字段的值不能为空。如果用户在添加数据时，在非空约束字段，没有给指定值，数据库系统就会报错。 1234567CREATE TABLE tb_emp5(字段名 数据类型 NOT NULL， ...)# 虽然说大小写无关，字段名可以写成一行，但是大写和一定格式的书写，# 能让你一目了然，更好的理解。 [e.g.] 定义数据表 tb_emp6，指定员工的名称不能为空 1234567CREATE TABLE tb_emp6(id INT(11) PRIMARY KEY,name VARCHAR(25) NOT NULL,deptid INT(11) ,salary FLOAT); # 注意分号！！！！ 查看结果，发现tp_emp6表中的name字段的 Null 列为NO，意味着，插入之不能为空。 使用唯一性约束​ 唯一性约束（Unique Constraint）要求该列唯一，允许为空，只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 唯一性约束语法：字段名 数据类型 UNIQUE 这里仅仅是写了唯一性约束的语法，没有写在完整的创建表时定义字段的那部分中。 在定义完列之后直接指定唯一约束： 123456CREATE TABLE tb_dept2(id INT(11) PRIMARY KEY,name VARCHAR(22) UNIQUE, location VARCHAR(50)); 在定义完所有列之后指定唯一约束 1234567CREATE TABLE tb_dept3(id INT(11) PRIMARY KEY,name VARCHAR(22) UNIQUE, location VARCHAR(50),CONSTRAINT STH UNIQUE(name)); 以上两种方式都可以用来指定唯一约束。 UNIQUE 和 PRIMARY KEY 是有区别的： 一个表中可以有多个字段声明为UNIQUE，但只能有一个PRIMARY KEY声明 PRIMARY KEY 是唯一且不能有空值，而UNIQUE允许空值的存在 PRIMARY KEY 当表定义主键将自动创建主键索引，而UNIQUE NOT NULL的组合没有索引一说 使用默认约束​ 默认约束（Default Constraint）指定某列的默认值。如男性同学较多，性别就可以默认为‘男’。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为‘男’。 默认约束的语法：字段名 数据类型 DEFAULT 默认值 [e.g.] 1234567CREATE TABLE tb_emp7(id INT(11) PRIMARY KEY,name VARCHAR(25) NOT NULL,deptid INT(11) DEFAULT 1111,salary FLOAT); ​ 可以发现字段deptid行的default列有了默认值为1111，意味着当你在新插入的记录如果没有指定部门编号，则默认值为1111。 [小tips] ​ 当你插入NULL时，默认值会被改变，NULL被当做一个值插入，不会采用默认值。 设置表的属性值自动增加​ 在数据库应用中，经常希望在每次插入新记录的时候，系统自动生成字段的主键值，这时我们就可以通过为表的主键添加 AUTO_INCREMENT 关键字来实现。**默认的，在MySQL 中AUTO_INCREMENT的初始值为1，每新增一条记录，字段值自动+1。一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分。AUTO_INCREMENT约束的字段可以是任何整数类型（TINYINT、SMALLIN、INT、BIGINT等）。 设置表的属性值自动增长的语法： 字段名 数据类型 AUTO_INCREMENT [e.g.] 1234567CREATE TABLE tb_emp8(id INT(11) PRIMARY KEY AUTO_INCREMENT,name VARCHAR(25) NOT NULL,deptid INT(11),salary FLOAT); ​ 可以发现在表tb_emp8中，字段名id行的Extra列多了个auto_increment，当你在插入记录的时候，默认的自增字段ID的值从1开始，每次添加一条新纪录，该值自动加1。 查看数据表结构​ 使用SQL语句创建好数据表之后，可以查看表结构的定义，以确认表的定义是否正确。在MySQL中，查看表结构可以使用DESCRIBE 和SHOW CREATE TABLE语句。 查看表基本结构语句 DESCRIBE​ DESCRIBE/DESC 语句可以查看表的字段信息，其中包括：字段名、字段数据类型、是否为主键、是否有默认值等。其实之前已经用到过很多次了。 语法规则： DESCRIBE 表名; DESC 表名;（简写） 其中，各个字段的含义分别解释： NULL: 表示该列是否可以存储NULL值 KEY:表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。 DEFAULT:表示该列是否有默认值，如果有的话值是多少。 EXTRA:表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。 查看表详细结构语句 SHOW CREATE TABLE​ SHOW CREATE TABLE 语句可以用来显示创建表时的CREATE TABLE语句。 语法格式： SHOW CREATE TABLE 表名; SHOW CREATE TABLE 表名\G 修改数据表​ 修改表指的是修改数据库中已经存在的数据表的结构。MySQL使用ALTER TABLE语句修改表。常用的修改表的操作有：修改表名、修改字段数据类型或字段名、增加和删除字段、修改字段的排列位置、更改表的存储引擎、删除表的外键约束等。 修改表名语法规则 ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;; 其中TO为可选参数，使用与否均不影响结果。 [e.g.] 将数据表tb_dept1改名为tb_deptment1 查看数据库中的所有表 SHOW TABLES; 将数据表tb_dept1改名为tb_deptment1 ALTER TABLE tb_dept1 RENAME tb_deptment1; [小tips] ​ 修改表名称后，可以通过DESC命令来查看修改前后两个表的结构，修改表名并不修改表的结构，因此修改名称后的表和修改名称前的表的结构必然是相同的。 修改字段的数据类型​ 修改字段的数据类型，就是把字段的数据类型转换成另外一种数据类型。 语法规则： ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;; ​ 其中，‘表名’ 指的是你想要修改的数据类型所在的表的名称，‘字段名’指的是需要修改的字段，‘数据类型’指的是修改后的字段的新数据类型。 [e.g.] 将数据表 tb_dept1 中 name 字段的数据类型由 VARCHAR(22) 修改成 VARCHAR(30) 查看表结构 DESC tb_dept1; 修改 ALTER TABLE tb_dept1 MODIFY name VARCHAR(30); 修改字段名语法规则 ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段&gt; &lt;新字段&gt; &lt;新数据类型&gt;; ​ 其中，‘旧字段’指的是修改前的字段名；‘新字段’指的是修改后的字段名；‘新数据类型’指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样即可，但数据类型不能为空。 [e.g.] 将数据表tb_dept1中的location字段名称改为loc，数据类型保持不变 sql 语句 ALTER TABLE tb_dept1 CHANGE location loc VARCHAR(50); 使用DESC查看表tb_dept1 将tb_dept1中loc字段名称再改回location，同时将数据类型变为VARCHAR(60) ALTER TABLE tb_dept1 CHANGE loc location VARCHAR(60); 再次查看tb_dept1 [小tips] ​ CHANGE 和 MODIFY 有区别 MODIFY 单纯用来修改数据类型，而CHANGE 可以修改字段名和数据类型，但是CHANGE也可以实现和MODIFY一样的效果设置一样的新名字就可以，要注意修改数据类型，有可能会影响到数据表中已经有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。 添加字段​ 随着业务需求的变化，可能需要在已经存在的表中添加新的字段。 添加字段的语法规则： ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST | AFTER 已经存在字段]; [小tips] ​ 注意 ：‘FIRST’ 或 ‘AFTER 已经存在字段名’，用于指定新增的字段在表中的位置，如果没有添加参数，则默认将新添加的字段设置为数据表的最后列。 添加无完整性约束条件的字段[e.g.] 在数据表tb_dept1中添加一个没有完整性约束的INT类型的字段 managerid sql语句 ALTER TABLE tb_dept1 ADD managerid INT(10); 查看表tb_dept1 添加有完整性约束条件的字段[e.g.] 在数据表tb_dept1中添加一个不能为空的 VARCHAR(12)类型的字段column1 sql语句 ALTER TABLE tb_dept1 ADD column1 VARCHAR(12) NOT NULL; 查看表tb_dept1 在表的第一列添加一个字段[e.g.] 在数据表tb_dept1 中添加一个INT类型的字段column2 sql语句 ALTER TABLE tb_dept1 ADD column2 INT(11) FIRST; 查看表tb_dept1 在表的指定列之后添加一个字段[e.g.] 在数据表tb_dept1 中 name列后添加一个INT类型的字段column3 sql语句 ALTER TABLE tb_dept1 ADD column3 INT(11) AFTER name; 查看表tb_dept1 删除字段​ 删除字段是将数据表中的某个字段从表中移除 语法规则： ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;; [e.g.] 删除数据表tb_dept1表中的column2字段 查看tb_dept1表结构 DESC tb_dept1; sql语句 ALTER TABLE tb_dept1 DROP column2; 查看tb_dept1表 DESC tb_dept1; 修改字段的排列位置​ 对于一个数据表来说，在创建的时候，字段在表中的顺序已经确定了，但是表的结构并不是完全不可以改变的，可以通过ALTER TABLE来改变表中的字段的相对位置。 语法规则： ALTER TABLE &lt;表名&gt; MODIFY &lt;字段1&gt; &lt;数据类型&gt; FIRST|AFTER &lt;字段2&gt;; ​ ‘字段1’指要修改的字段位置，‘数据类型’指‘字段1’的数据类型，‘FIRST’为可选参数，指将‘字段1’修改为表的第一个子弹，‘AFTER 字段2’指将‘字段1’插入到‘字段2’后面。 修改字段为表的第一个字段修改字段到表的指定列之后更改表的存储引擎删除表的外键约束删除数据表删除没有被关联的表删除被其他表关联的主表综合案例——数据表的基本操作专家解惑 表删除操作需谨慎 每一个表中都要有一个主键么？ 并不是每个表都可以任意选择存储引擎 带AUTO_INCREMENT约束的字段值是从1开始的么？]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的基本操作]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据库的基本操作创建数据库​ MySQL安装好以后，首先需要创建数据库，这是使用MySQL各种功能的前提。安装完成之后，将会在其data目录下自动创建几个必须的数据库，可以使用SHOW DATABASES;语句来查看当前所有存在的数据库。 ​ 可以看到，数据库列表中包含了4个数据库，这四个数据库是必然存在的，一般建议是不需要删除。 ​ 创建数据库是在系统磁盘上划分一块区域用于数据的存储和管理，如果管理员在设置权限的时候为用户创建了数据库，则可以直接使用，否则，需要自己创建数据库。MySQL中创建数据哭的基本SQL语句为CREATE DATABASE database_name; （“database_name” 为要创建的数据库的名称，并且该名称不能与已经存在的数据库重名）。 [e.g.] _创建测试数据库 test_db：_ CREATE DATABASE test_db; ​ 数据库创建好之后，可以使用SHOW CREATE DATABASE声明查看数据库的定义 _查看创建好的数据库 test_db 的定义：_ SHOW CREATE DATABASE test_db; SHOW CREATE DATABASE test_db\G 再次使用 SHOW DATABASES;语句来查看当前所有存在的数据库 ​ 可以看到，数据库列表中包含了刚刚创建的数据库 test_db 和之前存在的四个自带的数据库，一共5个数据库。 删除数据库​ 删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。删除数据库的SQL基本语句为DROP DATABASE database_name;（同理 此处的database_name 为你想要删除的库名），如果你指定的数据库名不存在，则删除会出错。 [e.g] _删除测试数据库 test_db_ DROP DATABASE test_db _再次查看数据库 test_db的定义_ 执行结果给出一条错误信息，即说明数据库 test_db 已不存在，删除成功了。 数据库存储引擎​ 数据库存储引擎是数据库底层软件组件，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。MySQL的核心就是存储引擎。 MySQL 存储引擎简介​ MySQL 提供了多个不同的存储引擎，不需要再整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。MySQL5.7 支持的存储引擎有：InnoDB，MyISAM，Memory，Merge，Archive，Federated，CSV，BLACKHOLE等。可以使用SHOW ENGINES;语句查看系统所支持的引擎类型。 SHOW ENGINES\g 等效于SHOW ENGINES;也就是 ‘ \g ’ 等于 ‘ ; ’ SHOW ENGINES\G 将查询到的横向表格纵向输出，方便阅读。（自己在terminal里试一下吧，太长了！） ​ Support 列的值表示某种引擎是否能使用：YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认存储引擎。 InnoDB 存储引擎​ InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.7中，InnoDB 作为默认存储引擎。InnoDB 主要特性有： InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。 InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。 InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。InnoDB表可以是任何尺寸，即使文件尺寸被限制为2GB的操作系统上。 InnoDB 支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6B的ROWID，并以此作为主键。 InnoDB 被用在众多需要高性能的大型数据库站点上。 InnoDB 不创建目录，使用InnoDB时，MySQL 将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0 和 ib_logfile1 的5MB大小的日志文件。 MyISAM 存储引擎​ MyISAM 基于ISAM的存储引擎，并对其进行扩展。它是在Web、数据存储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。主要特性有： 大文件（63位文件长度）在支持大文件的文件系统和操作系统上被支持。 当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少的碎片。 每个MyISAM 表最大索引数为64，这可以通过重新编译来改变。每个索引最大的列数是16个。 最大的键长度是1000B，这也可以通过编译来改变。对于键长度超过250B的情况，一个超过1024B的键将被用上。 BLOB和TEXT列可以被索引。 NULL值被允许在索引的列中。这个值占每个键的0~1个字节。 所有数字键值以高字节优先被存储以允许一个更高的索引压缩。 每表一个AUTO_INCREMENT列的内部处理。为INSERT和UPADATE操作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。 可以把数据文件和索引文件放在不同的目录。 每个字符列可以有不同的字符集。 有VARCHAR的表可以固定或动态记录长度。 VARCHAR和CHAR列可以多达64KB。 创建数据库时，会产生3个文件，文件的名字以表的名字开始，扩展名指出文件类型：frm文件存储表定义，数据文件的扩展名为.MYD(MYData)，索引文件的扩展名是.MYI(MYIndex)。 MEMORY 存储引擎​ MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。MEMORY主要特性有： MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500B的最大键长度。 MEMORY存储引擎执行HASH和BTREE索引。 可以在一个MEMORY表中有非唯一键。 MEMORY表使用一个固定的记录长度格式。 MEMORY不支持BLOB或TEXT列。 MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引。 MEMORY表在所有客户端之间共享 MEMORY表内容被存在内存中，内存是MEMORY表和服务器在查询处理时的空闲中创建的内部表共享。 当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）。 存储引擎的选择​ 不同的存储引擎都有各自的特点，以适应不同的需求，那么在做选择权，首先需要考虑每一个存储引擎提供了那些不同的功能。 ​ 如果要提供提交、回滚和崩溃恢复能力的事务安全能力，并要求实现并发控制，InnoDB是个很好的选择。如果数据表主要用来插入和查询记录的，则MyISAM引擎能提供较高的处理效率；如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。如果只有INSERT 和SELECT 操作，可以选择Archive引擎，它还支持高并发的插入操作，但是本身并不是事务安全的，非常适合存储归档数据，例如记录日志信息可以使用Archive引擎。 ​ 一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，选择使用合适的存储引擎，将会提高整个数据库的性能。 综合案例——数据库的创建和删除 登录数据库 mysql -uroot -p（本机登录可以不用写 -h localhost） 创建数据库zoo CREATE DATABASE zoo; 创建数据库 zoo SHOW DATABASES; 查看数据库里有哪些数据和，查看数据库zoo是否创建成功。 选择当前数据库为zoo USE zoo; 查看数据库zoo的信息 SHOW CREATE DATABASE zoo; SHOW CREATE DATABASE zoo\G 删除数据库zoo DROP DATABASE zoo; 删除zoo这个数据库 SHOW DATABASES; 查看数据库是否删除 如何查看默认存储引擎 查看系统中所有的存储引擎 SHOW ENGINES; 查看默认存储引擎 SHOW VARIABLES LIKE &#39;storage_engine&#39;; 查看默认存储引擎的SQL语句也同时验证了之前说默认存储引擎为InnoDB。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库基础什么是数据库​ 数据库是由一堆数据构成的有序的集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映了客观事物间的本质联系。数据库系统提供对数据的安全控制和完整性控制。 ​ 数据库的概念诞生于60年前，其诞生和发展给计算机信息管理带来了一场巨大的革命。那么数据库发展至今呢，其种类大概分为三种：层次数据库、网络式数据库 和 关系式数据库，那么我们所学的MySQL就是一个关系型数据库管理系统。 ​ 随着数据库历史的发展，普遍的观点认为，数据库（DataBase,DB）是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。它是一个按数据结构来存储和管理数据的计算机软件系统，即数据库包含两层含义：保管数据的“仓库”，以及数据管理的方法和技术。 ​ 其特点包括：实现数据共享，减少数据冗余；采用特定的数据类型；具有较高的数据独立性；具有统一的数据控制功能。 表​ 在关系数据库中，数据库表示一系列二位数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成，行被称为记录，是组织数据的单位；列被称之为字段，每一个列表示记录的一个属性，都有相应的描述信息，例如数据类型、数据宽度等…… ​ 上图中，这个表中，每个列包含所有作者的某个特定类型的信息，比如每个作者都有编号，名字，性别，专业等，这些属性被称之为字段；每一行，也就是记录，则包含了某个作者所有的特定信息，比如 张三的编号是100，性别为男，专业主修计算机。 数据类型​ 数据类型决定了，数据在计算机中的存储格式，代表不同的信息类别。**常用的数据类型有：整数数据类型、浮点数数据类型、精确小数类型、二进制数据类型、日期/时间数据类型、字符串数据类型。 主键​ 主键（Primary Key）又被称之为主码，用于唯一地表示表中的每一条记录，可以理解为表中的一列或者多列被指定为主键时，主键列上不能有两行相同的值，也不能为空值！一旦出现相同的值，将提示错误，系统不能确定当你需要查询时，你究竟需要的是哪一条记录！生活中其实常常出现这样的情况，比如你的员工ID在同一家公司不可能相同、也不能为空，你的证书编号等等。 数据库技术构成数据库系统​ 数据库系统由硬件部分和软件部分共同构成，硬件主要用于存储数据库中的数据，包括计算机、存储设备等。软件部分则主要包括DBMS、支持DBMS运行的操作系统，以及支持多种语言进行应用开发的访问技术等。 ​ 细分数据库系统有3个主要的组成部分： 数据库：用于存储数据的地方 数据库管理系统：用于管理数据库的软件 数据库应用程序：为了提高数据库系统的处理能力所使用的管理数据库的软件补充 ​ 数据库提供了一个存储空间用以存储各种数据，可以将数据库视为一个存储数据的容器。一个数据库可能包含许多文件，一个数据库系统中通常包含许多数据库。 ​ 数据库管理系统（DataBase Management System, DBMS）是用户创建、管理和维护数据库时所使用的软件，位于用户与操作系统之间，对数据库进行统一管理。DBMS能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性、和可靠性。 ​ 虽然有了DBMS，但是很多情况，DMBS无法满足对数据管理的要求，数据库应用程序（DataBase Application）的使用可以满足对数据管理的更高要求，还可以使数据管理过程更加直观和友好。数据库应用程序负责与DBMS进行通信、访问和管理DBMS中存储的数据，允许用户插入、休该、删除DB中的数据。 SQL语言​ 对数据库进行查询和修改操作的语言叫做SQL。SQL的含义是结构化查询语言（Structured Query Language），SQL有许多不同的类型，有3个主要标准：ANSI（美国国家标准机构） SQL，对ANSI SQL修改后在1992年采纳的标准，称之为SQL-92或SQL2。另外，各大数据库厂商提供不同版本的SQL，这些版本的SQL不但能包括原始的ANSI标准，而且在很大程度上支持SQL-92 标准。 ​ SQL包含以下4个部分： 数据定义语言（DDL）：DROP、CREATE、ALTER等语句。 数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。 数据查询语言（DQL）：SELECT语句。 数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句。 数据库访问接口​ 不同的程序设计语言会有各自不同的数据库访问接口，程序语言通过这些接口，执行SQL语句，进行数据库管理。 ​ Python 标准数据库接口为 Python DB-API ，它为开发人员提供了数据库应用编程接口。那么Python 的数据库接口支持非常多的数据库，例如：GadFly、mSQL、MySQL、Oracle、Sybase、Interbase等 什么是MySQL​ MySQL是一个小型关系数据库系统，与其他的大型数据库管理系统（例如 来自同一个家门的Oracle、DB2、SQL Server等）相比，MySQL规模小、功能有限，但是它体积小、速度快、成本低，且它提供的功能对于较为复杂的应用来说也已经够用，这些特性使得MySQL成为世界上最受欢迎的开放源代码数据库。 客户机-服务器软件​ MySQL其实从本质上是一个主从式架构（Client-server model）或客户端-服务器（Client/Server）结构的一种软件，这是一种网络架构，通常在该网络架构下的软件分为客户端（Client）和服务端（Server）。 ​ 服务器是整个应用系统资源的存储于管理中心，多个客户端则各自处理相应的功能，共同实现完整的应用。在C/S结构中，客户端用户的请求被传送到数据库服务器，数据库服务器进行处理后，将结果返回给用户，从而减少了网络数据传输量。 ​ 用户使用应用程序时，首先启动客户端，通过有关命令告知服务器进行连接以完成各种操作，而服务器则按照此请示提供相应的服务。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。 ​ 这种系统的特点就是，客户端和服务器程序不在同一台计算机上运行，这些客户端和服务器程序通常归属不同的计算机。服务器端一般使用高性能的计算机，并配合使用不同类型的数据库；而客户端需要安装专门的软件，比如专门开发的客户端工具浏览器等。 MySQL版本​ 针对不同用户，MySQL分为两个不同的版本： MySQL Community Server（社区版）：此版本完全免费，但是官方不提供技术支持。 MySQL Enterprise Server （企业版服务器）：它能够以很高性价比为企业提供数据仓库应用，支持ACID事物处理，提供完整的提交、回滚、崩溃恢复和行及锁定功能。但是需要付费使用，官方提供电话支持。 我们用社区版就可以了 MySQL优势​ MySQL 的主要优势如下： 1. 速度：运行速度快 2. 价格：免费 3. 容易使用：复杂程度比较低，易于上手。 4. 可以执行：能够工作在众多不同的系统平台上，例如：Windows、Linux、Mac OS等 5. 丰富的接口：提供了用于C、C++、Java、Python、Ruby等语言的API 6. 支持查询语言：MySQL可以利用标准SQL语法和ODBC（开放式数据库连接）的应用程序 7. 安全性和连接性：十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证了密码安全。并且由于MySQL是网络化，因此可以在因特网上的任何地方访问，提高了数据共享的效率 MySQL 5.7 的新功能​ 和MySQL5.6相比，新功能主要包括以下几个方面： 从MySQL5.7.8版本开始，支持JSON。 性能和可扩展性，改进了InnoDB的可扩展性和临时表的性能，从而实现更快的网络和大数据加载等操作。 改进复制以提高可用性的性能 安全 优化 GIS MySQL 工具​ MySQL数据库管理系统提供了许多命令行工具，这些工具可以用来管理MySQL服务器、对数据库进行访问控制、管理MySQL用户以及数据库备份和恢复工具等。而且MySQL提供了图形化的管理工具，这使得对数据库的操作更加简单。 MySQL命令行实用程序​ MySQL服务器端实用工具程序如下： mysqld：SQL后台程序，即MySQL服务器进程。该程序必须运行之后，客户端才能通过连接服务器来访问数据库。 mysqld_safe：服务器启动脚本。在UNIX 中推荐使用这种方式来启动服务器。它增加了一些安全特性，例如当出现错误时重启服务器并向错误日志文件写入运行时间信息。 mysql.server：服务器启动脚本。用于使用包含为特定级别的、运行启动服务的脚本的、运行目录的系统。（不知道有什么用） mysql_multi：服务器启动脚本，可以启动或停止系统上安装的多个服务器。 myisamchk：用来描述、检查、优化和维护MyISAM表的实用工具。（不知道有什么用） mysqlbug：MySQL缺陷报告脚本。他可以向MySQL邮件系统发送缺陷报告。 mysql_install_db：用默认权限创建MySQL授权表。通常只是在系统上首次安装MySQL时执行一次。 MySQL客户端实用工具程序如下： mysqldump：将MySQL数据库转储到一个文件的客户程序。 mysqlhotcopy：当服务器在运行时，快速备份MyISAM或ISAM表的工具 mysqlshow：显示数据库、表、列以及索引相关信息的客户程序。 perror：显示系统或者MySQL错误代码含义的工具。 MySQL Workbench​ MySQL Workbench 是MySQL的可视化数据库设计软件，它为数据库管理人员和开发人员提供了一整套可视化数据库操作环境，主要功能有： 数据库设计和模型建立 SQL开发 数据库管理]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——MySQL]]></title>
    <url>%2F2018%2F11%2F19%2FPython%E2%80%94%E2%80%94MySQL%2F</url>
    <content type="text"><![CDATA[MySQL初识数据库数据库概述MySQL介绍下载安装MySQL软件基本管理启动查看登录，设置密码忘记密码指定配置文件统一字符编码初识sql语句库相关操作1234567891011# 增加create database #库名称#;# 删除drop database #库名称#;# 修改alter database #库名称# #要改的属性#; # e.g alter database db1 CHARSET utf8; # 在mysql中，‘utf-8’ 不能带 ‘-’# 查询show databases #查看所有数据库;show create database #库名称; 查看建库的语句 123456# 命名规范 1.不能使用纯数字 2.可以是数字 字母 下滑线的组合 3.可以下滑线开头 4.不能是关键字 如create 5.不区分 大小写 表相关操作1234567891011121314151617181920212223# 增加create table 库名称.新表名称(字段名 数据类型[(长度) 约束条件]);# []代表可选的 # e.g create table db1.dog(nikename char(10),gender char(10),age int);# 删除 drop table #表名#; # 修改 # 删除字段名 alter table dog drop age; # 增加字段名 alter table dog add #新字段名 #新类型 # 修改字段名的类型 alter table dog modify #字段名 #新类型 # 把就的字段名改成新的字段名 新的类型 altert table dog change gender sex char(2); # 查询 show tables; # 查看所有表 desc #表名称#; # 查看表结构 show create table #表名#; # 查找建表语句 记录相关操作123456789101112# 增加insert into 表名 values(值1，值2....);# 删除delete from 表名 where 字段名称 = 值;delete from 表名没有条件删除所有# 修改update 表名 set 字段名 = 新的值 where 字段名 = 值;没有条件的话修改全部# 查找select *from 表名; *表示通配符 查看所有字段select 字段名称1，字段名2.. from 表名; 数据类型 12345678910create table 表名(字段名 数据类型[(长度) 约束条件]);# []代表可选# 整数类型 默认有符号 # 设置为无符号 create table t2(字段名 数据类型 unsigned)create table t3(age tinyint unsigned zerofill);# 建表后用alter修改# 对于整数类型而言长度不是数据所占的字节数,是显示数据时的宽度(字符数)# 默认情况下,储存的数值的十进制的位数,小于所设置的显示宽度时,用0来填充# 当数据的十进制位长度 大于显示宽度 可以正常显示 约束]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python——并发编程]]></title>
    <url>%2F2018%2F11%2F18%2FPython%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Alfred——Mac效率工具]]></title>
    <url>%2F2018%2F11%2F16%2FAlfred%E2%80%94%E2%80%94Mac%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[AAAlfred! 看见这个骚气的紫色的帽子没有，这也许是我用mac以来，最想向大家推荐的一款软件——Alfred，它到底有多么好用，几乎就像是帮你封装了你的操作系统！那么今天在这里呢，就给大家介绍一下它的基础用法，真的非常基础，但是已经足够让你摆脱很多烦恼了！ 基础设置篇设置Alfred Hotkey使用Alfred的第一步，当然是配置一个调用它的顺手快捷键，自从有了它之后我舍弃了MacOS自带的Spotlight（聚焦搜索）cmd + space可以在全局调出，并且将这个这个组合快捷键转而用来调用Alfred的小窗口，当然你也能根据你自己的喜好搭配，或者你觉着还有必要留着你的Spotlight，但我相信，看完这篇教程你会毫不犹豫的舍弃。 另外更换为cmd + space的组合快捷键，会有一点小问题，由于是MacOS下自带分配给了Spotlight，所以你第一步需要先去取消Spotlight和cmd + space的绑定关系，再在下图中的Alfred Hotkey中修改为cmd + space 取消Spotlight和cmd + space绑定关系，可以点击参考这里 在 General 选项卡的最下面，你可以设置自己所在的国家或地区，不同的选择会导向特定的域名。例如，在加拿大，Google 搜索的默认域名就会被改为 google.ca。这一选项在大部分情况下都无关紧要，但如果你比较依赖科学上网，我建议将其改为你梯子的物理位置，以减少链接重定向次数，加快访问速度。 快速切换应用当你设置好你的快捷键后，你可以用快捷键呼出你Alfred的命令框，然后输入你想调用的APP名称，既可以快速的开启你的应用，而不用再去dock栏或者launchpad中找你的应用软件啦，它既可以帮你开启应用，也可以帮你做到在应用间快速切换。 快捷网页搜索当你设置好你的快捷键后，你可以用快捷键呼出你Alfred的命令框，然后输入任意你想在google中搜索的内容。Alfred会帮你打开你的默认浏览器并在谷歌中搜索相关信息，帮你省去了打开浏览器点击搜索框等步骤。当然你也可以在Alfred中敲入网址直接启动浏览器访问网页。 接下来，我们回到Alfred的设置中，最上边那一行选择Features，找到Web Search。在这里你可以看到很多Alfred帮你设置好的一些URLS。它的效果就是你可以设置你的Keyword，然后通过Keyword就可以在相应的网站中直接查找，同样不需要打开浏览器，即可完成。这里我设置的百度的关键字为bd，谷歌的关键字为google，当然你要是嫌麻烦，你可以自定义你的关键字。 那么如何添加你想查找的网站的URL呢？ 首先点击，Web Search 右下角的 Add Custom Search，会弹出一个小窗口。 这里我列出一些常用网站的URL，方便你们添加： 百度： https://www.baidu.com/s?wd={query} 知乎：https://www.zhihu.com/search?q={query} 微博：https://s.weibo.com/weibo/{query} Bilibili：https://search.bilibili.com/all?keyword={query} 淘宝：https://s.taobao.com/search?q={query} 京东：https://search.jd.com/Search?keyword={query} Github：https://github.com/search?q={query} e.g.百度 快捷网页书签访问点击进入Web Bookmarks，导入你浏览器的书签，在Alfred的命令窗口中就能时间快速访问。 文件搜索操作Alfred 另外内置很多命令操作，例如：open是打开文件，in是查找文件是否包含你所要查找的内容，find是查找文件位置等，当然同样支持自定义快捷键。 系统操作Alfred还支持系统操作，可以根据自定义命令关键字呼出，如果担心误触，只需要取消勾选命令钱的方框或再次确认就可以了。 计算器Alfred的计算器支持完善的函数语法，只要在开头加上‘=’号，你就能使用包括三角、对数、指数、开方等在内的高级运算符，同时支持圆周率等数学常数，瞬间从小学进化到高中知识范围。更详细的语法介绍，你可以参考 Calculator 选项卡中的说明。 词典词典其实我并没有使用它自带的词典功能，而是使用了Alfred的workflows下的有道，在这里先简单介绍一下，我的室友会写关于如何使用Alfred的workflows，之后我会贴上他的blog地址，大家可以链接过去看看。这里先给大家看一下简单的操作，我设置为double click cmd为我的快捷键，然后每次就可以非常方便的查询单词，支持发音，翻译句子，支持选中查询等，真的超级方便。 以上呢，就是Alfred一些基本的我也比较常用的功能，另外其实最主要的一个功能就是词典那里的查词，运用到的workflow，这个功能相关的内容，我的室友会在最近几天更新，之后我会更新我的blog，贴上他的地址，另外使用某些功能的话，需要你们购买powerpack，其实组个团一起买，也没多少钱啦，关键真的非常好用这个软件。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——封装]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装什么是封装？封指的是隐藏的意思，但是这种隐藏对外不对内 装指的是把属性装进一个容器 如何封装只需要在想要封装的数据前加上__开头 （两个下划线），该属性就会被隐藏起来，该隐藏具备的特点： 只是一种语法意义上的变形，开头的属性会在检测语法时发生变形 _类名_\属性名 这种隐藏式对外不对内，因为在类内部检测语法时所有的代码统一都发生的变形 这种变形只在检测语法时发生一次，在类定义之后新增的__开头的属性并不会发生变形 如果父类不想让子类覆盖自己的属性，可以在属性前加__开头 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 这种隐藏式对外不对内，因为在类内部检测语法时所有的代码统一都发生的变形 # class Foo: # __x = 1111 # _Foo__x =1111 # def __init__(self,y): # self.__y = y # # def __f1(self): # print('Foo.f1') # # def get_y(self): # print(self.__y) # _类名__属性名 # obj = Foo(2222) # # print(obj.x) # 找不到属性 # # print(obj.__x) # # print(obj.y) # # print(obj.__y) # # print(obj._Foo__x) # 1111 # print(obj._Foo__y) # obj.get_y()# 这种变形只在检测语法时发生一次，在类定义之后新增的__开头的属性并不会发生变形 # Foo.__aaaaaaaaaaaaaaaaaaaaaa = 1 # print(Foo.__dict__) # '__aaaaaaaaaaaaaaaaaaaaaa': 1# 如果父类不想让子类覆盖自己的方法，可以在方法名前加__开头 # class Foo: # def __f1(self): # print('Foo.f1') # # def f2(self): # print('Foo.f2') # self.__f1() # obj._Foo__f1() # # class Bar(Foo): # def __f1(self): # print('Bar.f1') # # obj = Bar() # obj.f2()# 为何要封装？封装数据属性的目的：将数据属性封装起来，类外部的使用就无法直接操作该数据属性，需要类内部开一个接口给使用者，类的设计者可以在接口智商附加任意逻辑，从而严格控制使用者对属性的操作 封装函数属性的目的：隔离复杂度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 封装不是单纯意义上的隐藏# 封装数据属性的目的：把数据属性封装起来，然后需要开辟接口给类外部的使用者使用# 这样我们可以在接口之上添加控制逻辑，从而严格空间访问者对属性的操作class People: def __init__(self,name,age): self.__name = name self.__age = age def tell_info(self): u = input('user&gt;&gt;&gt; ').strip() p = input('pwd&gt;&gt;&gt; ').strip() if u == 'ooc' and p =='111': print(self.__name,self.__age) def modfiy_info(self,name,age): if type(name) is not str: raise TypeError('必须为str类型') if type(age) is not int: raise TypeError('必须为int类型') self.__name = name self.__age = agep = People('david',18)p.tell_info()p.modfiy_info('Jack',20)p.modfiy_info('Jack','20') # 报错p.modfiy_info(aaaa,20) # 报错# 封装函数属性的目的：为了隔离复杂度class ATM: def __card(self): print('插卡') def __auth(self): print('用户认证') def __input(self): print('输入取款金额') def __print_bill(self): print('打印账单') def __take_money(self): print('取款') def withdraw(self): self.__card() self.__auth() self.__input() self.__print_bill() self.__take_money()obj=ATM()obj.withdraw()# 封装其实最主要的功能就是明确地区分内外，对外是隐藏的，对内是开放的]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——组合与继承]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是组合解决类与类之间代码冗余的问题有两种解决方案： 继承 ：描述的是类与类之间的关系 组合：描述的是一个类产生的对象，该对象拥有一个属性，这个属性的值是来自于另一个类的对象 12345678910111213141516171819202122232425262728293031323334353637383940class Date: def __init__(self,year,mon,day): self.year = year self.mon = mon self.day = day def tell_brith(self): print('出生日期&lt;%s-%s-%s&gt;' %(self.year,self.mon,self.day))class People: school = 'Lixin' def __init__(self,name,age,gender): self.name = name self.age = age self.gender = genderclass Teacher(People): def __init__(self,name,age,gender,level,salary): super().__init__(name,age,gender) self.level = level self.salary = salary def change_score(self): print('%s teacher is changing score.' %self.name)class Student(People): def __init__(self,name,age,gender,course): super().__init__(name,age,gender) self.course = course def choose(self): print('%s student is choosing courses.' %self.name)teacher_1 = Teacher('Lu',30,'male',10,10000)date_obj = Date(1988,1,1)date_obj.tell_brith()teacher_1.birth = date_obj # 为teacher_1 增加birth属性 值等于date_objteacher_1.birth.tell_brith() # teacher_1的名称空间等价于date_obj]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——绑定与非绑定方法]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[绑定方法与非绑定方法绑定方法 特殊之处：绑定给谁就应该由谁来调用，谁来调用就会将谁当做第一个参数自动传入 绑定给对象的方法：在类中定义函数没有被任何装饰器修饰的情况下，默认就是绑定对象的 绑定给类的方法：为类中定义函数添加一个装饰器classmethod，就是绑定类的 非绑定方法 特殊之处：非绑定方法就是一个普通函数，即不与类绑定又不与对象绑定，意味着类与对象都可以调用，但是无论谁来调用都是一个普通函数，没有自动传值效果。 非绑定方法：为类中定义函数添加一个装饰器staticmethod，就是非绑定方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Foo: def func1(self): print('func',self) # 绑定给类方法 @classmethod def func2(cls): print('func2',cls) # 非绑定方法，既不与类绑定又不与对象绑定 @staticmethod def func3(x,y): print('func3',x,y)obj = Foo()# 一、绑定给对象obj.func1()print(obj)# &lt;__main__.Foo object at 0x107f7ee48&gt;# 绑定给对象的方法，类也可以调用，但是类调用就是一个普通函数，# 没有自动传值的效果# Foo.func1() # 需要传值Foo.func1(obj)# 二、绑定给类的方法# 绑定给类的，应该由类来调用print(Foo.func2)print(obj.func2)Foo.func2()obj.func2()# 三、非绑定方法print(obj.func3)print(Foo.func3)obj.func3(1,2)Foo.func3(1,3)# caseimport settingsclass MySQL: def __init__(self,ip,port): self.id=self.create_id() self.ip=ip self.port=port def tell_info(self): print('&lt;%s:%s:%s&gt;' % (self.id,self.ip, self.port)) @classmethod def from_conf(cls): return cls(settings.IP, settings.PORT) @staticmethod def create_id(): import uuid return uuid.uuid4()# obj=MySQL('1.1.1.1.1',3406)# obj1=MySQL('1.1.1.2',3406)# obj.tell_info()print(MySQL.from_conf)a = MySQL.from_conf() # 要有变量接受返回值# 用a调用传入返回值a.tell_info()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——多态]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态什么是多态？多态指的是同一种事物多种形态 为何要用多态？用基类创建一套规则，强制子类去遵循，这样便可以再不用考虑对象具体类型的前提下而直接使用对象下的方法 如何用多态？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Animal: def eat(self): pass def drink(self): pass def bark(self): passclass Cat(Animal): def bark(self): print('喵喵喵')class Dog(Animal): def bark(self): print('汪汪汪')c = Cat()d = Dog()# 可以在不考虑对象具体类型的前提下而直接使用对象下的方法# 规则强制import abc #abstract classclass Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def eat(self): pass @abc.abstractmethod def drink(self): pass @abc.abstractmethod def bark(self): pass# obj=Animal() # 抽象基类本身不能被实例化class Cat(Animal): def eat(self): print('cat eat') def drink(self): print('cat drink') def bark(self): print('喵喵喵')class Dog(Animal): def eat(self): print('dog eat') def drink(self): print('dog drink') def bark(self): print('汪汪汪')def BARK(animal): animal.bark()c = Cat()c.bark()BARK(c) 鸭子类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Foo: def f1(self): print('from foo.f1') def f2(self): print('from foo.f2')class Bar: def f1(self): print('from bar.f1') def f2(self): print('from bar.f2')obj1=Foo()obj2=Bar()obj1.f1()obj1.f2()obj2.f1()obj2.f2()class Disk: def read(self): print('disk read') def write(self): print('disk write')class Txt: def read(self): print('txt read') def write(self): print('txt write')class Process: def read(self): print('process read') def write(self): print('process write')obj1=Disk()obj2=Txt()obj3=Process()obj1.read()obj2.read()obj3.read()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——网络编程]]></title>
    <url>%2F2018%2F11%2F02%2FPython%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python基础之socket编程客户端、服务器架构C/S：C = Client，S = Server。C/S 架构即“客户端-服务器”架构。 B/S：B = Browser，S =Server。B/S架构其实是C/S架构一种特殊的实现形式 OSI七层协议 &amp; TCP/IP 五层模型 TCP/IP 五层模型讲解物理层 功能：以二进制数据形式在物理媒体上传输数据。 数据链路层以太网协议（ethernet）： 一组电信号构成一个数据包，叫做 ‘以太帧’ 以太帧（IEEE802.3结构）的组成： Preamble: 前导码，7个字节，用于数据传输过程中的双方发送、接收的速率的同步 SFD: 帧开始符，1个字节，表明下一个字节开始是真实数据 dst MAC: 目标MAC地址，6个字节，指明这个以太帧的接受者 src MAC: 源MAC地址，6个字节，指明这个以太帧的发送者 Length: 长度，2个字节，指明这个以太帧数据字段的长度， Type: 类型，2个字节，指明这个以太帧中数据的协议类型，比如 0x0800 表明该以太帧用的是IPv4的ip协议 Data and Pad: 数据与填充，46~1500个字节，包含了上层协议传递下来的数据，如果加入数据字段后，这个以太帧长度不够64个字节，会在数据字段加入‘填充’使它达到64字节 FCS: 帧校验序列，4个字节，对接收网卡，主要是检测Date and Pad字段，提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧。目前最为流行的用于FCS的算法是循环冗余校验（cyclic redundancy check - CRC） MAC地址（Media Access Control Address）: 每块网卡出厂时，由网卡生产厂家少如网卡的EPROM，它储存的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址，形象的解释，MAC地址就如同身份证上的身份证号码，具有全球唯一性。 广播：有了MAC地址，局域网内的两台主机就可以通信，一台主机通过ARP协议获取另外一台主机的MAC地址。在同一局域网内的主机都会收到一个包，其他主机会收到这个包，并进行拆解，发现目标MAC地址不是自己，就丢弃，如果是自己就响应。 网络层试想，我们现在有了ethernet、MAC地址、广播的发送方式，世界上的计算机都采用以太网的广播方式，的确彼此之间就可以通信le ，但是会出现一个问题，一台主机发送的包就会被全世界收到，这就会造成很多问题，比如效率低下。 那么实际上世界的网络是由一个个小的彼此隔离的局域网组成的，以太网的广播包只能在一个局域网内发送，一个局域网就是一个广播域，以太网的广播包只能在一个广播域内发送，跨广播域通信只能通过路由转发，那么网络层的功能就是找一种办法来区分不同的广播域/子网，这种办法叫做IP协议。 IP协议 规定网络地址的协议叫做IP协议，它定义的地址称之为IP地址，广泛采用的版本为IPv4，它规定网络地址由32位2进制表示。 范围0.0.0.0 - 255.255.255.255 一个IP地址通常携程四段十进制数，例如：127.10.12.1 IP地址分为两部分 网络部分：标识子网 主机部分：标识主机 单纯的IP地址，只是标识了IP地址的种类，从网络部分或主机部分都无法辨识一个IP所处的子网，即：192.168.10.1与192.168.10.2 不能确定二者处于同一个子网内。 子网掩码：就是标识子网特征的一个参数，我们知道了‘子网掩码’后，我们就能判断，任意两个IP地址是否处在同一个子网络内，方法就是将两个IP地址与子网掩码进行AND运算（两个对应数位为1，运算结果就为1，否则为0），然后比较结果是否相同，如果是的话，就表明这两个IP地址，在同一个子网络中，否则就不是。 IP协议，最主要的功能由两个：一个是为每一台计算及分配IP地址，另一个是确定哪些地址在同一个子网络。 IP数据报 ARP协议 传输层以我们的电脑为例，你会在电脑上运行QQ，微信，浏览器等应用软件，网络层的IP+子网掩码帮我们区分了子网，以太网的MAC地址帮我们找到了局域网内的主机，那么如何该分辨你的这个数据是发送给你主机上的哪个应用程序的呢？答案是端口port（端口范围0-65535，0-1023为系统占用端口尽量别用） tcp协议暂时看一下这个超链接大佬写的吧，好像举例更生动点。 应用层应用层是系统的最高层，是直接为应用进程提供服务的，直接和应用程序接口并提供常见的网络应用服务。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 socketSocket我们通常称之为套接字，是在应用层和TCP/IP协议族通信的一个抽象层。它把运输层和网络层复杂的复杂的操作抽象为几个简单的接口提供给应用层调用，以此来实现网络中的通信。 套接字发展史及分类 基于文件类型的套接字家族：AF_UNIX（UNIX中一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信） 基于网络类型的套接字家族：AF_INET（python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET） 套接字工作流程 TCP1234567891011121314151617181920# TCP服务器.pyimport socketserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)server.bind(('127.0.0.1',8080))# 1024-65535server.listen(5)while True: conn,client_addr = server.accept() print(conn) while True: try: data = conn.recv(1024) # 接受数据的最大限制 if not data:break # 针对linux系统。 conn.send(data.upper()) # 注意收发都是以bytes为单位 except ConnectionResetError: break conn.close()server.close() 123456789101112# TCP客户端.pyimport socketclient = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect(('127.0.0.1',8080))while True: msg = input('&gt;&gt;&gt;: ').strip() client.send(msg.encode('utf-8')) data = client.recv(1024) print(data.decode('utf-8'))client.close() UDP12345678910# UDP服务器.pyimport socketserver = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)server.bind(('127.0.0.1',8080))while True: client_data,client_addr = server.recvfrom(1024) msg = input('回复%s:%s&gt;&gt;&gt;: '%(client_addr[0],client_addr[1])) server.sendto(msg.decode('utf-8'),client_addr) 12345678910# UDP客户端.pyimport socketclient = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: msg = input('&gt;&gt;&gt;: ').strip() client.sendto(msg.encode('utf-8'),('127.0.0.1',8080)) res,server_addr = client.recvfrom(1024) print(res.decode('utf-8')) TCP粘包问题很通俗的理解一下TCP粘包问题，第一种情况就是发送的内容过少，TCP协议为了提高传输效率，通常会收集短时间内的少量数据作为一个包发送出去；第二种情况就是发送的内容过多，导致接收端不能完整的接受，残留数据在管道内，再次接收时，会先接受残留数据然后再接受新的数据。所以我们也可以看出，TCP协议不会丢失数据，数据没收完会接着上次继续收，但是也就造成了粘包问题，而UDP根本不会粘包，但是当发送的数据超过512个字节时，极其容易丢失数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# _*_ coding: utf-8 _*_# Time : 2018/11/18 2:27 PM# Author : oOC# Email : david.yfwei@gmail.com# File : cmd解决粘包服务器.pyimport socket,subprocess,struct,jsonserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)server.bind(('127.0.0.1',8080))server.listen(5)while True: print('正在等待连接'.center(30,'=')) # 同意连接请求 client,client_addr = server.accept() # 重复收发数据 while True: try: # 接收命令,返回值一定是个bytes类型 cmd = client.recv(1024).decode('utf-8') # 在linux中,客户端异常关闭,服务器会收空 if not cmd:continue info = subprocess.Popen(cmd,shell = True,stdout = subprocess.PIPE,stderr = subprocess.PIPE) res = info.stdout.read()+info.stderr.read() print('字节数:%s',len(res)) # 1.组装一个报头 head_dic = &#123; 'name':'CMD套接字通信', 'total_size':len(res), &#125; # 2.报头转JSON格式 head_str = json.dumps(head_dic) # 3.JSON转字节 head_bytes = head_str.encode('utf-8') # 4.发送报头长度 bytes_len = struct.pack('i',len(head_bytes)) client.send(bytes_len) # 5.发送报头 client.send(head_bytes) # 6.发送真实数据 client.send(res) except ConnectionResetError: print('客户端异常关闭!') client.close() breakclient.close() 123456789101112131415161718192021222324252627282930313233343536# _*_ coding: utf-8 _*_# Time : 2018/11/18 2:27 PM# Author : oOC# Email : david.yfwei@gmail.com# File : cmd解决粘包客户端.pyimport socket,struct,jsonclient = socket.socket()while True: # 发送数据 msg = input('&gt;&gt;&gt;: ') if not msg:continue client.send(msg.encode('utf-8')) # 1.获取报头长度 bytes_len = client.recv(4) # 服务器格式为i,固定4个字节 # 2.转回整型 head_len = struct.unpack('i',bytes_len) # 3.接收报头数据 head_bytes = client.recv(head_len) # 4.转为JSON字符串 head_dic = json.loads(head_bytes.decode('utf-8')) recv_len = 0 finally_data = b'' while recv_len &lt; head_dic['total_size']: data = client.recv(1024) recv_len += len(data) finally_data += data print(finally_data.decode('utf-8'))client.close()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——异常处理]]></title>
    <url>%2F2018%2F11%2F01%2FPython%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理 什么是异常？异常就是程序运行时发送错误的信号（在程序出现错误时，则会产生一个异常，若程序没有处理它，则会抛出该异常，程序的运行也随之终止） 异常的分类： 语法错误（最低级异常，避免犯错） 语法错误在python解释器的语法检测时，就会报错，必须在程序执行前就改正 逻辑错误 这种异常只有在代码被执行时才能发现，我们要处理的重点就是运行时产生的异常 特点：在没有运行代码前，往往无法很直观的能发现。如果运行时产生异常，并且我们没有正的处理异常时，他就会抛出错误信息，并且终止程序的运行，此时我们可以通过捕捉异常，使我们的程序更加稳定不容易崩溃，但也不意味着能滥用异常处理。 异常的组成 异常的追踪信息（具体发生异常的位置 以及函数的调用顺序） 异常类（错误的类型） 异常值（详细的错误信息） Case：123456789101112131415161718def func(): namefunc()# Traceback (most recent call last): (异常的追踪信息)# File "/Users/ooc/Desktop/异常处理/test.py", line 33, in &lt;module&gt;# func()# File "/Users/ooc/Desktop/异常处理/test.py", line 31, in func# name# （错误的类型）NameError: name 'name' is not defined (详细的错误信息)# 异常处理try: func()except Exception as e: print(e)# name 'name' is not defined 常见异常123456789101112AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的 全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的 异常处理为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，我们需要对异常进行处理。 如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防 如果错误发生的条件是不可预知的，贼需要用到try…except: 在错误发生之后进行处理 123456789101112131415161718192021222324252627282930313233343536# 基本语法try: # 被检测的代码块except 异常类型： # try 中一旦检测到异常，就会执行这个位置的逻辑 # 多种异常类型处理print("staring.....")try: name # 一旦检测到异常，就会执行except的逻辑 [][-1] passexcept NameError: print("名字找不到!")except IndexError: print("索引超出范围")print("end.......")# staring.....# 名字找不到!# end.......# 处理多种异常类型 Exception和BaseExceptionprint("staring.....")try: &#123;&#125;["aaa"] name [][-1] 1/0except Exception: print("可能名字找不到! 可能所以超出范围 可能除数为0")print("end.......")# staring.....# 可能名字找不到! 可能所以超出范围 可能除数为0# end....... 主动抛出异常123456789101112# 当程序中有一些用户没有遵守规则，我们可以主动抛出异常'''语法： raise 异常类型(异常的详细信息) 异常类型必须是BaseException的子类'''# e.gage = input("请输入整型的年龄:")if not age.isdigit(): raise TypeError("你输入的不是整型!")age = int(age)print("十年后你%s岁" % (age + 10)) 异常处理的使用通常只有在错误发生的条件无法预知的情况下，才应该加上try…except 异常不太常用语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 不太常用的 # 语法1 try: except: else: # try中没有发生异常时执行 # 语法2 try : except : finally : # 无论是否发生异常 都会执行finally 可以用来回收系统资源!# casetry: f = open("test.txt","rt",encoding="utf-8") f.read() f.write("123")except Exception: print("发生异常了")finally: print("关闭文件!") f.close() # 断言 assert# Assert statements are a convenient way to insert debugging# assertions into a program # 语法: assert 结果为Bool的表达式 # 如果值为True 则继续往下执行 # 如果值为False 抛出一个 AssertionError 表示断言失败name_list = ['jack','james']if len(name_list) &gt; 2: raise ValuError('列表中只有两个元素')# assert 相当于 ifassert len(name_list) &gt; 2 # 要使用列表中的数据来完成任务，就可以用assert代替if 做判断# 自定义异常类型# 当系统提供的这些异常类型 和你要描述的错误不匹配时 就需要自定义异常类型 # 写法: # class 自定义异常类型名称(BaseException): # 总结一下:之所以自定义异常类型 是为了更具体描述你的错误 让使用者一眼就看出了 # 关键点:1.如何自定义异常类型 # 2.在except中 使用as 来获取异常对象 class UnlikeError(BaseException): def __init(self,msg): self.msg = msg def hello(): msg = input('输入一段话： ') if msg == '你好': print('你好') else: raise UnlikeError('你不好')try: hello()except UnlikeError as e: print(e.msg) # 输入一段话：sagas# 你不好# 输入一段话：你好# 你好]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——内置方法]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E2%80%94%E2%80%94%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内置方法判断对象的类型isintance(对象,类型) 判断是否是子类issubclass(子类,父类) __str__方法会在对象被打印时自动触发,然后将返回值返回给print功能进行打印 1234567891011class People: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return '&lt;%s:%s&gt;' %(self.name,self.age)peo=People('ooc',18)print(peo) #print(peo.__str__())# &lt;ooc:18&gt; __del__方法会在对象被删除时自动触发执行,用来在对象被删除前回收系统资源 1234567891011class Bar: def __init__(self,x,y,filepath): self.x=x self.y=y self.f=open(filepath,'r',encoding='utf-8') def __del__(self): # 写回收系统资源相关的代码 self.f.close()obj=Bar(10,20)del obj]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——反射]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射反射指的是通过字符串来操作属性 123456789101112131415161718192021222324252627# e.g.class Foo: def __init__(self,name,age): self.name = name self.age = age def tell_info(self): print('%s:%s' %(self.name,self.age)) obj = Foo('ooc',18)# hasattrprint(hasattr(obj,'name')) # True# getattrprint(getattr(obj,'name')) # ooc# setattrsetattr(obj,'gender','male') # 增加属性print(obj.__dict__) # &#123;'name': 'ooc', 'age': 18, 'sex': 'male'&#125;stattr(obj,'name','david') # 已存在属性就修改属性print(obj.__dict__) # &#123;'name': 'david', 'age': 18, 'sex': 'male'&#125;# delattrdelattr(obj,'name')print(obj.__dict__) # &#123;'age': 18, 'sex': 'male'&#125;]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的命名空间]]></title>
    <url>%2F2018%2F10%2F23%2FPython%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Python 的命名空间原文链接：https://segmentfault.com/a/1190000004519811]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——面向对象编程]]></title>
    <url>%2F2018%2F10%2F22%2FPython%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程面向过程编程思想 与 面向对象的编程思想面向过程编程思想 核心 ‘过程’ 两字，过程指的是解决问题的步骤 即：先干什么——&gt;再干什么——&gt;后干什么 优点：一个复杂功能简单化、流程化 缺点：可扩展性差，一动全动 面向对象的编程思想 核心‘对象’两字，对象是特征（变量）与技能（函数）的结合体 堪比创造世界，一切皆对象 类对象是特征（变量）与技能（函数）的结合体，而类则是一系列对象相同的特征（变量）与技能（函数）的结合体。 对象是具体存在的事物，而类则是一个抽象的概念 站在不同的角度总结出的类与对象是不同的 现实世界：先有一个个具体存在的对象，然后随着发展才会有类的概念 程序中：先定义类，后调用了类来产生对象 类的用途： 类本质就是一个名称空间，可以对该名称空间进行增删改查 调用类来产生对象 类体包含 相同的特征（变量）和相同的技能（函数） 类体中可以包含任意python代码 类体代码会在类定义阶段立即执行，产生一个名称空间，用来将类体代码执行执行过程中产生的名字都丢进去 e.g. Case 123456789101112131415161718192021222324252627282930313233343536立信选课系统对象1： 特征 学校 = ‘Lixin’ 职业 = ‘student’ 姓名 = ‘ooc’ 年龄 = 22 性别 = ‘male’ 技能 选课对象2： 特征 学校 = ‘Lixin’ 职业 = ‘student’ 姓名 = ‘rachel’ 年龄 = 18 性别 = ‘female’ 技能 选课对象3： 特征 学校 = ‘Lixin’ 职业 = ‘teacher’ 姓名 = ‘gu’ 年龄 = 50 性别 = ‘male’ 等级 = 10 技能 打分 学生类： 相似特征 学校 = ‘Lixin’ 职业 = ‘学生’ 相似技能 选课 1234567891011121314151617181920212223242526272829303132class LiXinStudent: # 相似的特征 school = 'Lixin' job = 'student' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender # 相似的技能 def choose_course(self): print('%s choose course' %self.name)# 类对名称空间进行增删改查# 查看当前名称空间print(LiXinStudent.__dict__)print(LiXinStudent.__dict__['school'])# LiXinStudent.school # LiXinStudent.__dict['school']LiXinStudent.add_element = 11111print(LiXinStudent.__dict__) # 名称空间增加 add_element = 11111# 调用类产生对象stu1 = LiXinStudent('ooc', 22, 'male')print(stu1)# &lt;__main__.LiXinStudent object at 0x10b774e48&gt;print(stu1.__dict__)# &#123;'name': 'ooc', 'age': 22, 'gender': 'male'&#125;# __init__的功能：就是在实例化时就为对象初始自己独有的特征# 注意：不能有返回值 属性查找顺序 先从对象自己的名称空间找，没有则去所属的类找，不回去全局找，所属类里找不到就报错。 类中定义的变量是所有对象共享的，对象可以来用，类也可以来使用，类一旦改变自己的数据属性的值，所有的对象都能感知到。 绑定方法类中定义的函数是类的函数属性，类可以用，类来调用就是一个普通的函数，但其实类中的定义的函数是给对象用的，而且是绑定给对象用的。 类的函数：该传几个参数就传几个参数 特殊之处是绑定给谁就应该由谁来调用，谁来调用就会将谁当做第一个参数自动传入 123456stu1 = LiXinStudent('ooc', 22, 'male')print(stu1.__dict__)# &#123;'name': 'ooc', 'age': 22, 'sex': 'male'&#125;stu1 = choose_course()# ooc choose course# 绑定给谁就应该由谁来调用 继承什么是继承？在程序中继承是一种新建子类的方式，新创建的类称之为子类、派生类，被继承的类称之为父类、基类、超类。继承描述的是一种遗传关系，子类可以重用父类的属性。 为何用继承？减少类与类之间的代码冗余的问题 如何继承先抽象再继承 e.g. Case1 12345678910111213141516171819202122232425# 单继承&amp;多继承class Parent1(object): passclass Parent2: passclass Sub1(Parent1): passclass Sub2(Parent1,Parent2): passprint(Sub1.__bases__)# (&lt;class '__main__.Parent1'&gt;,)print(Sub2.__bases__)# (&lt;class '__main__.Parent1'&gt;, &lt;class '__main__.Parent2'&gt;)print(Parent1.__bases__)# (&lt;class 'object'&gt;,)print(Parent2.__bases__)# (&lt;class 'object'&gt;,) 在python3中你不在()中写object，也默认给你加了# python2与python3在继承上的区别# 新式类:但凡继承object类的子类,以及该子类的子子类,...都称之为新式类# 经典类:没有继承object类的子类,以及该子类的子子类,...都称之为经典类# 只有在python2中才区分新式类与经典类 e.g. Case2 123456789101112131415161718192021222324252627282930313233343536373839# 在子类派生出的新功能中如何重用父类的功能：# 方式一：指名道姓地访问某一个类中的函数，与继承无关class LixinPeople: school = 'Lixin' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = genderclass LixinStudent(LixinPeople): def choose_course(self): print('%s is choosing course' %self.name)class LixinTeacher(LixinPeople): def __init__(self,name,age,gender,level,salary): LixinPeople.__init__(self,name,age,gender) self.level = level self.salary = salary def score(self,stu,num): stu.num=num # 同时把分数存到该学生的内存空间当中 print('老师%s给学生%s打分%s' %(self.name,stu.name,num))tea = LixinTeacher('gu',50,'male',10,3000)print(tea.__dict__)stu1 = LixinStudent('ooc',22,'male')print(stu1.__dict__)stu1.choose_course()tea.score(stu1,100)print(stu1.__dict__)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——re正则表达式]]></title>
    <url>%2F2018%2F10%2F19%2FPython%E2%80%94%E2%80%94re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[re - 正则表达式的操作Regular Expression简称re，表示正则表达式. 什么是正则表达式这个模块提供了一系列功能强大的正则表达式 (regular expression) 工具, 它们允许你快速检查给定字符串是否与给定的模式匹配 (使用 match 函数), 或者包含这个模式 (使用 search 函数). 正则表达式是以紧凑(也很神秘)的语法写出的字符串模式.表达式指的是某些带有特殊含义的符号或者符号组成的式子，这些式子是对字符进行处理的逻辑公式，是用特殊字符或者一些特殊组成一个规则字符串，这个规则字符串用来表达对字符的过滤逻辑。 re.match函数re.match 尝试从字符串的起始位置匹配一个模式， 支持的字符及其表达的含义The special characters are: ​ ‘.’ 匹配换行符之外的任何字符 ​ ‘^’ 匹配字符串的开头 ​ ‘$’ 匹配到字符串末尾或字符串末尾的换行符之前 ​ ‘‘ 匹配前面表达式的0次或更多重复。ab 将匹配’a’,’ab’或’a’,后跟任意数量的’b’(贪婪) ​ ‘+’ 匹配结果表达式匹配前一表达式的1次或多次重复 ​ ab+将匹配’a’，后跟任何非零数字’b’，它将不匹配只是’a’（贪婪） ​ ‘?’ 导致结果表达式匹配前面表达式的0或1个重复。ab? 将匹配’a’或’ab’（贪婪） *?,+?,?? 前三个表达式的非（贪婪）版本 ​ {m,n} 匹配前一个表达式的m到n次重复 ​ {m,n}? 前一个表达式的非（贪婪）版本 ​ ‘\\‘ 要么转义特殊字符，要么发出特殊序列信号 ​ [] 表示一组字符 ​ ‘|’ A|B, creates an RE that will match either A or B. ​ (…) Matches the RE inside the parentheses. ​]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——hashlib模块]]></title>
    <url>%2F2018%2F10%2F18%2FPython%E2%80%94%E2%80%94hashlib%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hashlib 模块hash是一个种算法，是将一个任意长的数据，根据计算得到一个固定长度的特征码 特征 不同输入 可能会有相同的结果 几率特别小 相同的输入 肯定得到一个相同的结果 散列值的性质，从原理上来说是不可能反解的 网上有反解的一些小工具，但是使用的方式是撞库，就是他们讲一些经常出现的数据存放起来，然后进行一一比对 使用场景 密码验证 验证数据是否被篡改，例如游戏安装包 Case12345678910111213141516171819202122232425262728import hashlibm = hashlib.md5('aaa123'.encode('utf-8'))print(m.hexdigest())print(len(m.hexdigest()))# d9f6e636e369552839e7bb8057aeb8da# 32h1 = hashlib.sha512('123'.encode('uft-8')) # hashlib.有很多不同的算法print(len(h1.hexdigest()))print(h1.hexdigest())# 128# 3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2# 加盐m = hashlib.md5('321'.encode('utf-8'))print(m.hexdigest())# caf1a3dfb505ffed0d024130f58c5cfam.update('qweqr'.encode('utf-8'))print(m.hexdigest())# 60025d5161811b25a25c0c333df98634# 先加盐import hmach = hmac.new('qweqr'.encode('utf-8'))h.update('321'.encode('utf-8'))print(h.hexdigest())# 393faee81f2f2db9bd3efa6d5302792e]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——logging模块]]></title>
    <url>%2F2018%2F10%2F18%2FPython%E2%80%94%E2%80%94logging%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[logging 模块日志级别12345logging.debug() # 10 # 默认级别为warninglogging.info() # 20 # 默认输出位置为控制台logging.warning() # 30 # 默认编码根据系统确定logging.error() # 40logging.critical() # 50 自定义配置12import logginglogging.basicConfig() # 函数中通过具体参数来更改logging模块默认行为 可用参数 123456filename: 用指定的文件名创建FiledHandler，这样日志会被储存在指定的文件filemode: 文件打开方式，在指定了filename时使用这个参数，默认值为&apos;a&apos;还可以指定&apos;w&apos;format: 指定handler使用的日志显示格式datefmt: 指定日期时间格式level: 设置rootlogger的日志级别stream: 用指定的stream创建StreamHandler,可以指定输出到sys.stderr, sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 可用格式 1234567891011121314%(name)s: Logger的名字，并非用户名，详细查看%(levelno)s: 数字形式的日志级别%(levelname)s: 文本形式的日志级别%(pathname)s: 调用日志输出函数的模块的文件名%(module)s: 调用日志输出函数的模块名%(funcName)s: 调用日志输出函数的函数名%(lineno)d: 调用日志输出函数的语句所在的代码行%(created)f: 当前时间，用UNIX标准的表示时间的浮点数表示%(relativeCreated)d: 输出日志信息时自Logger创建以来的毫秒数%(asctime)s: 字符串形式的当前时间。默认格式为&apos;2018-10-15 17:30:00,123&apos;在逗号后边是毫秒%(thread)d: 线程ID%(threadName)s: 线程名%(process)d: 进程ID%(message)s: 用户输出的消息 Case1234567891011import logginglogging.basicConfig( filename="a.log", filemode="at", level=10, format="%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(message)s", datefmt="%Y-%m-%d %X %p")logging.debug("这是调试信息") # 由于我们设置了最低级别从10开始所以debug信息也会显示# 2018-10-18 18:19:21 PM DEBUG &lt;module&gt; 21 这又是调试信息 logging中的四个核心角色 logger 生成日志 handler 处理日志 filter 过滤日志 formatter 格式化 一条日志完整的生命周期 由logger产生日志 # 会先检查日志级别，低于设置的级别则不执行 交给过滤器判断是否被过滤 将日志消息分发给绑定的所有处理器 处理器按照绑定的格式化对对象输出日志 # 如果不指定格式则按照默认格式 通过字典配置日志模块配置日志模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647standard_format = "%(name)s %(asctime)s %(levelname)s %(module)s %(funcName)s %(lineno)s %(message)s"simple_format = "%(name)s %(asctime)s %(module)s %(message)s"complete_format = "%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(thread)s %(process)s %(message)s"logfile_path = r"/Users/ooc/Desktop/代码/test/log0.log"LOGGING_DIC = &#123; 'version':1, 'formatters':&#123; 'standard': &#123; 'format' : standard_format &#125;, 'simple':&#123; 'format' : simple_format &#125;, 'complete':&#123; 'format' : complete_format &#125; &#125;, 'fileters':&#123;&#125;, 'handlers' :&#123; 'console' :&#123; 'level' : 'DEBUG', 'class' : 'logging.StreamHandler', 'formatter' : 'simple' &#125;, 'default':&#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125;, &#125;, 'logger' :&#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125;, &#125;,&#125;]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——configparser模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94configparser%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[configparser 模块configparser 用于解析配置文件的模块，我们会在配置文件中，放入一些配置程序的信息，通常而言，这些配置信息是我们不需要经常去改动的信息，例如数据文件的路径 DB_PATH 在配置文件中，只有两种内容： section分区 option 选项 通常我们用get功能，从配置文件中获取一个配置选项。 Case12345678910# file: test.cfg# 路径相关的配置[path]db_path = /a/b/c/test.txt# 用户相关的配置[user]name = oOC# 服务相关的配置[server]url = 192.168.0.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# file: configparser模块.pyimport configparserconfig = configparser.ConfigParser()config.read('test.cfg',encoding='utf-8') # 读取一个配置文件# 获取需要的信息# 获取所有的分区print(config.sections())# ['path', 'user', 'server']# 获取所有选项print(config.options('user'))# ['name']# 获取路径print(config.get('path','db_path'))# /a/b/c/test.txt# 获取用户名print(config.get('user','name'))# oOC# get返回的都是字符串类型 如果需要转换类型 # 直接使用get+对应的类型(bool int float)getfloat()getint()getbool()# 是否由某个选项config.has_option()# 是否由某个分区config.has_section()# 返回布尔值# 添加config.add_section("server")config.set("server","url","192.168.1.2")# 删除config.remove_sectionconfig.remove_option("user")# 修改config.set("server","url","192.168.1.2")# 写回文件中with open("test.cfg", "wt", encoding="utf-8") as f: config.write(f)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——XML模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94XML%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[XML 模块参考文档链接： 什么是XML 模块？ XML 指可扩展标记语言（EXtensible Markup Language） XML 的设计宗旨是传输数据，而不是显示数据 XML 标签没有被预定义，我们需要自行定义标签 XML 的语法格式12345678910&lt;?xml version="1.0" encoding = "UTF-8"?&gt;&lt;!-- XML 声明文件的可选部分，如果存在需要放在文档的第一行 --&gt;&lt;root&gt; &lt;!-- 根元素 --&gt; &lt;child name = 'ooc'&gt; &lt;!-- 元素 应该还包含 有属性 'category' --&gt; &lt;!--XML 属性值必须加引号 --&gt;&lt;!--在 XML 中，应该尽量避免使用属性。如果信息感觉起来很像数据才使用元素吧--&gt; &lt;subchild&gt;......&lt;/subchild&gt; &lt;!-- 同时，层级必须明确，不可以混乱--&gt; &lt;subchild1&gt;.....&lt;/subchild1&gt; &lt;!-- 同级 --&gt; &lt;/child&gt;&lt;/root&gt; &lt;!--与第三行&lt;root&gt;对应&lt;/root&gt;是关闭标签，必须有这样的一对 --&gt; Case11234567891011121314&lt;bookstore&gt; &lt;book category="CHILDREN"&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category="WEB"&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XML 命名规则XML 元素必须遵循以下命名规则： 名称可以包含字母、数字以及其他字符 不能以数字或者标点符号开始 不能以字母xml、XML、Xml等开始 名称不能包含空格 Case212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# file: c.xml&lt;studentinfo&gt; &lt;stu1&gt; &lt;name1&gt; 张三 &lt;/name1&gt; &lt;age1&gt; 20 &lt;/age1&gt; &lt;girlfriend11&gt; &lt;name11&gt; 张三的女朋友 &lt;/name11&gt; &lt;age11&gt; 19 &lt;/age11&gt; &lt;/girlfriend11&gt; &lt;/stu1&gt; &lt;stu2&gt; &lt;name2&gt; 李四 &lt;/name2&gt; &lt;age2&gt; 23 &lt;/age2&gt; &lt;girlfriend22&gt; &lt;name22&gt; 李四的女朋友 &lt;/name22&gt; &lt;age22&gt; 18 &lt;/age22&gt; &lt;/girlfriend22&gt; &lt;/stu2&gt;&lt;/studentinfo&gt;# file:xml模块.pyimport xml.etree.ElementTree as ElementTree# 解析c.xmltree = ElementTree.parse('c.xml')print(tree)# 获取根标签rootTree = tree.getroot()print(rootTree)# iter是用于在全文范围获取标签for item in rootTree.iter('age22'): print(item.text) print(item.text.strip())# 输出 &lt;xml.etree.ElementTree.ElementTree object at 0x10462a7f0&gt;&lt;Element 'studentinfo' at 0x1045cbe08&gt; 1818]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——JSON模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94JSON%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[JSON 模块 什么是JSON模块？如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。JSON表示的对象就是标准的JavaScript语言的对象。 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象 JSON 名称、值对1"name" : "菜鸟教程" JSON 值Json值可以是： 数字（整数或浮点数） e.g. {“age”:30} 字符串（双引号中） 逻辑值（bool） 数组（中括号中） 对象（在大括号中） e.g. {“name”:”ooc”,”url”:”makeupstories.github.io”} null JSON格式的语法规范JSON模块提供了四个方法：dumps, dump, loads, load (不带s 封装write 和 read) ase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import json# file: a.json&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;# 反序列化 # file: json模块.pywith open('a.json','rt',encoding = 'utf-8') as f: res = json.loads(f.read()) print(type(res))# &lt;class 'dict'&gt;with open('a.json',encoding='utf-8') as f: print(json,load(f)) # 不带s 封装 write 和 read功能 # &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;json_info = '''&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;'''res = json.loads(json_info)print(res)# &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;with open('b.json','wt',encoding='utf-8') as f: f.wrtie(json.dumps(json_info)) with open('b.json','wt',encoding='utf-8') as f: json.dump(json_info,f) # 不带s 封装 write 和 read功能]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shelve模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shelve%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shelve 模块shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型。 case12345678910import shelveuser = &#123;'name':'ooc'&#125;f = shelve.open(r'user_info.shv',writeback = True)f['user'] = userf.close() # 关闭时，把添加的内容写回到原文件中f = shelve.open(r'user_info.shv')print(f['user'])f.close()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——pickle模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[pickle 模块序列化的模块 单机程序 序列化是什么？序列化就是将内存中的数据结构转化成为一种中间格式，并储存到硬盘上。我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。 为什么要序列化？就是为了将数据持久储存，还为了实现跨平台数据交互。 反序列化是什么？把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 case123456789101112131415161718import pickledic = &#123;'name':'ooc','age':23,'gender':'male'&#125;print(type(dic)) # &lt;class 'dict'&gt;a = pickle.dumps(dic) # dumps 直接序列化到文件print(type(a)) # &lt;class 'bytes'&gt;f = open('user_info.pkl','wb') # 因为a是'bytes' ，wb是写入bytesf.write(a) # f.write(pickle.dumps(dic))序列化f.close()f = open('user_info.pkl','rb')info = pickle.loads(f.read()) # 从文件中反序列化print(info['age'])# 23]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shutil模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shutil%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shutil 模块shutil 模块提供了一个易于使用的高级接口，用于处理文件、文件夹、压缩包、处理模块等 1234567891011121314151617181920212223242526272829303132333435363738# 将文件内容拷贝到另一个文件中# shutil.copyfileobj(fsrc,fdst[,length])&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.copyfileobj(open('old.txt','r'),open('new.txt','w'))# 拷贝文件 和 shutil.copyfileobj(fsrc,fdst[,length]) 差不多# shutil.copyfile(src,dst)&gt;&gt;&gt; shutil.copyfile('old.txt','new.txt') # 目标无需存在# 仅拷贝权限，内容、组、用户均不变# shutil.copymode(src,dst)&gt;&gt;&gt; shutil.copymode('old.txt','new.txt') # 目标文件必须存在# 拷贝文件和权限# shutil.copy(src,dst)&gt;&gt;&gt; shutil.copy('old.txt','new.txt')# 拷贝文件和状态信息# shutil.copy2(src,dst)&gt;&gt;&gt; shutil.copy2('old.txt','new.txt')# 压缩文件# 创建压缩包并返回文件路径# shutil.make_archive(base_name, format,...)# base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，# 如：data_bak =&gt;保存至当前路径# 如：/tmp/data_bak =&gt;保存至/tmp/# format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”# root_dir： 要压缩的文件夹路径（默认当前目录）# owner： 用户，默认当前用户# group： 组，默认当前组# logger： 用于记录日志，通常是logging.Logger对象&gt;&gt;&gt; shutil.make_archive('compression','zip',r'\a\b\c')&gt;&gt;&gt; shutil.make_archive('compression1','rar',r'\a\b\c')# shutil直接解压&gt;&gt;&gt; shutil.unpack_archive('\a\b\c\compression.zip')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os.path模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94os.path%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os.path 模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; import os# 返回path规范化的绝对路径&gt;&gt;&gt; os.path.abspath('a.txt') '/Users/ooc/makeupstories.github.io/a.txt'# 将path分割成目录和文件名二元组返回&gt;&gt;&gt; os.path.split('/Users/ooc/makeupstories.github.io/a.txt')('/Users/ooc/makeupstories.github.io', 'a.txt')# 返回path的目录。其实就是os.path.split(path)的第一个元素 [0]&gt;&gt;&gt; os.path.dirname('/Users/ooc/makeupstories.github.io/a.txt')'/Users/ooc/makeupstories.github.io'# 返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。# 即os.path.split(path)的第二个元素&gt;&gt;&gt; os.path.basename('/Users/ooc/makeupstories.github.io/a.txt') 'a.txt'# 如果path存在，返回True；如果path不存在，返回False&gt;&gt;&gt; os.path.exists('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 如果path是绝对路径，返回True&gt;&gt;&gt; os.path.isabs('/Users/ooc/makeupstories.github.io/no_exist.txt')True# 如果path是一个存在的文件，返回True。否则返回False&gt;&gt;&gt; os.path.isfile('/Users/ooc/makeupstories.github.io/no_exist.txt')False# 如果path是一个存在的目录，则返回True。否则返回False&gt;&gt;&gt; os.path.isdir('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 将多个名称拼接为路径 &gt;&gt;&gt; os.path.join('a/','b/','c') 'a/b/c'# 返回path所指向的文件或者目录的最后存取时间&gt;&gt;&gt; os.path.getatime('/Users/ooc/makeupstories.github.io')1539767358.083225# 返回path所指向的文件或者目录的最后修改时间&gt;&gt;&gt; os.path.getmtime('/Users/ooc/makeupstories.github.io') 1539500860.4628224# 返回path的大小&gt;&gt;&gt; os.path.getsize('/Users/ooc/makeupstories.github.io') 448]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块这个模块提供了一种方便的使用操作系统函数的方法。 获取当前的工作目录123&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc' 切换当前工作目录123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc'&gt;&gt;&gt; os.chdir('/Users/ooc/Desktop/')&gt;&gt;&gt; os.getcwd()'/Users/ooc/Desktop' 当前目录 &amp; 上一级目录12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.curdir # 当前目录 '.''.'&gt;&gt;&gt; os.pardir # 上一级目录 '..''..' 系统环境变量12&gt;&gt;&gt; os.environ # 与sys.path不同的是 sys.path加载的是包的环境变量 # os.environ加载的是系统的环境变量 执行系统命令12&gt;&gt;&gt; os.system('cd') # 会执行括号中的命令，如果命令成功执行，返回0，否则返回10 创建目录123&gt;&gt;&gt; os.mkdir('d') # mkdir 一级一级的创建目录&gt;&gt;&gt; os.mkdir('j/a') # 上一级目录必须存在，否则报错&gt;&gt;&gt; os.makedirs('a/b/c') # 创建目录，可以连同子目录一同创建 删除目录12&gt;&gt;&gt; os.removedirs('a/b/c') # 递归删除，如果文件夹内没有文件就删掉，有文件就保留&gt;&gt;&gt; os.rmdir('d') 删除文件1&gt;&gt;&gt; os.remove(r'/Users/ooc/Desktop/a/b/c.txt') # 仅仅删除文件 列出所有文件和文件夹名称1&gt;&gt;&gt; os.listdir(r'/Users/ooc/Desktop/a/b') # 列出所有文件和文件夹名称 获取当前平台的路径分隔符12&gt;&gt;&gt; os.sep # 不同系统会有所差异/ 获取当前平台换行符12&gt;&gt;&gt; os.linesep'\n']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——random模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94random%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[random 模块Random variable generators. 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; random.random() # 0-1 不包括1 输出一个随机浮点数0.026446419370216523&gt;&gt;&gt; random.random()0.5107952377575242&gt;&gt;&gt; random.random()0.8535785412460167&gt;&gt;&gt; random.randint(1,10) # 取1-10 中的随机一个整数2&gt;&gt;&gt; random.randint(1,10) # 取得到10 因为 return self.randrange(a, b+1)3&gt;&gt;&gt; random.randrange(1,10)# 取1-10 中的随机一个整数6 # 但是取不到10# 原文档# This fixes the problem with randint() which includes the endpoint; in Python this is usually not what you want.&gt;&gt;&gt; random.sample(['1','2','3','4'],2)['3', '4'] #sample(指定一个范围，随机个数)&gt;&gt;&gt; l = ['1','2','3','4'] # 打乱原列表的顺序&gt;&gt;&gt; random.shuffle(l)&gt;&gt;&gt; l['4', '2', '1', '3']&gt;&gt;&gt; random.choice([1,2,3]) # 随机选一个1&gt;&gt;&gt; random.choices([1,2,3,4,5,6,7],k = 2) # 随机选择两个[5, 7] 随机验证码长度自定义 包括0-9 a-z A-Z 123456789101112def get_auth_code(length): res = "" for i in range(length): a = random.randint(0,9) b = chr(random.randint(65,90)) c = chr(random.randint(97,122)) s = random.choice([a,b,c]) res += str(s) return resprint(get_auth_code(4))# 5V3l 输出]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——sys模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94sys%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[sys 模块This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter. 环境变量12345&gt;&gt;&gt; import sys # 记住要调用模块 此文章后边不再写&gt;&gt;&gt; sys.path['', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python37.zip', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload', '/usr/local/lib/python3.7/site-packages']# 环境变量# 可以通过 sys.path.append() 来添加 查看已经加载的模块12&gt;&gt;&gt; sys.modules# 你就可以看到你已经加载的模块，由于我这边加载的模块巨多，不写了 获取终端调用时的参数1234567891011121314151617&gt;&gt;&gt; sys.argv[''] # 这里我在terminal中测试的代码# 在pycharm, file:sys_argv.pyprint(sys.argv) 这里我们可以看到 sys.argv 是一个列表# ['/Users/ooc/Desktop/Python/sys模块.py']print(sys.argv[0])# /Users/ooc/Desktop/Python/sys模块.py# file:sys_argv.py# import sysprint(sys.argv[2])# file: sys_argv.py# file_path: /Users/ooc/Desktop/Python/sys_argv.py# terminaloOCs-MBP:~ ooc$ python3 /Users/ooc/Desktop/Python/sys_argv.py 1 4 9 104 # 获取终端调用时的参数 第一个元素是程序本身路径 获取解释器的版本信息1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.version'3.7.0 (default, Aug 22 2018, 15:22:33) \n[Clang 9.1.0 (clang-902.0.39.2)]'# 当前解释器使用的信息 获取当前平台名称12&gt;&gt;&gt; sys.platformdarwin # MacOS int类型支持的最大值12&gt;&gt;&gt; sys.maxsize # 貌似python2中好像是，sys.maxint9223372036854775807 最大的Unicode值12&gt;&gt;&gt; sys.maxunicode1114111 中间结束程序12345&gt;&gt;&gt; sys.exit() # 默认为0# 执行到这行代码时就退出程序If the status is omitted or None, it defaults to zero (i.e., success).If the status is an integer, it will be used as the system exit status.If it is another kind of object, it will be printed and the system 终端复制文件工具123456789# 原文件路径source = sys.argv[1]# 目标文件路径dispath = sys.argv[2]with open(source,'rb') as f: data = f.read() with open(dispatch,'wb') as f2: f2.write(data)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——datetime模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94datetime%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[datetimedatetime 主要对时间和日期的处理 获取当前详细时间12345678910111213141516171819202122232425262728&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2018, 10, 15, 19, 45, 9, 841259)&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; print(a)2018-10-15 19:45:24.502984 # 获取时间的某一部分&gt;&gt;&gt; print(a.hour)19&gt;&gt;&gt; print(a.year)2018# 替换时间的某一部分&gt;&gt;&gt; a = a.replace(year=2019)&gt;&gt;&gt; print(a)2019-10-15 19:45:24.502984&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; b = datetime.datetime.now()&gt;&gt;&gt; print(a + b) # 不支持的操作类型 + 个人猜测是因为最大只能计算到2038年Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'datetime.datetime' and 'datetime.datetime'&gt;&gt;&gt; print(a - b)-1 day, 23:59:52.248296&gt;&gt;&gt; print(b - a)0:00:07.751704]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——time模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94time%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[time与时间相关的一个模块 更多了解：http://www.runoob.com/python3/python3-date-time.html 时间的三类时间戳时间戳是指从 1970年1月1日 0:0:0 开始到现在的秒数，但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。（不知道有没有更新过） 12345678&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1539595862.1039639&gt;&gt;&gt; time1 = time.time()&gt;&gt;&gt; time.sleep(10)&gt;&gt;&gt; time2 = time.time()&gt;&gt;&gt; time2 - time110.00250792503357 结构化时间123456789101112131415161718192021&gt;&gt;&gt; time.localtime()# 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组。time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=18, tm_min=43, tm_sec=5, tm_wday=0, tm_yday=288, tm_isdst=0)# tm_year 年# tm_mon 月# tm_mday 日# tm_hour 小时# tm_min 分钟# tm_sec 0 到 61 (60或61 是闰秒)# tm_wday 0到6 (0是周一) # tm_yday 一年中的第几天# tm_isdst 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的时候， tm_isdst为0；不了解情况时，tm_isdst()为负。# 单独取值&gt;&gt;&gt; time.localtime().tm_year2018&gt;&gt;&gt; time.localtime().tm_mon10&gt;&gt;&gt; time.gmtime() time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=10, tm_min=58, tm_sec=45, tm_wday=0, tm_yday=288, tm_isdst=0)# gmtime() 函数将一个时间戳转换为UTC时区（0时区）的struct_time，可选的参数sec表示从1970年1月1日以来的秒数。其默认值为time.time()，函数返回time.struct_time类型的对象。 格式化字符串时间12345&gt;&gt;&gt; time.strftime('%Y-%m-%d %H:%M:%S %p') # 注意大小写不然会报语法错误'2018-10-15 19:01:40 PM'&gt;&gt;&gt;time.strftime('%Y-%m-%d %X %p')'2018-10-15 19:02:11 PM' 三种格式之间的相互转换123456789101112131415# 时间戳转为结构化&gt;&gt;&gt; time.localtime(time.time())time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=19, tm_min=4, tm_sec=25, tm_wday=0, tm_yday=288, tm_isdst=0)# 结构化转字符串&gt;&gt;&gt; time.strftime('%Y-%m-%d',time.localtime(time.time()))'2018-10-15'# 字符串转为结构化&gt;&gt;&gt; time.strptime('2018-10-15','%Y-%m-%d')time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1)# 结构化转时间戳&gt;&gt;&gt; time.mktime(time.strptime('2018-10-15','%Y-%m-%d'))1539532800.0 格林威治时间123&gt;&gt;&gt; time.altzone # 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。-28800 # 暂时我也不知道有啥用 time.ctime([secs])12&gt;&gt;&gt; time.ctime() # 偏外国友人使用的时间格式'Mon Oct 15 19:12:30 2018']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——目录规范]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[标准目录规范在学习模块和包之前，就已经写过了ATM和购物车的项目，但是当时我们没有学习模块和包，所以当时是所有的函数功能都写在一个.py文件当中，虽然实现了功能，但是当时就发现，在实际写代码时，过程非常的复杂，看起来比较乱，所以在学习模块和包以后呢，我们应该根据项目，应该分什么文件，分什么样的文件夹，那么在初期呢，我们有一个固定的文件结构，就是今天的要说的开发的标准目录规范。 配置文件e.g. case : ATM 123456789101112131415161718# 此代码块用于表示我的目录# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范标准目录规范 ———————— | # 文件和模块 bin-------------- start.py | config----------- settings.py | core------------- ATM.py | db--------------- db.txt | lib-------------- common.py | log-------------- log.txt | readme.txt（说明文档） 1234567891011121314151617181920212223242526272829303132# file: 'start.py' # 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') start() 在case中，可以发现我们使用到了文件的路径，在之后的功能中，日志文件，或者数据文件等，我们会不止一次的使用到文件路径，那么我们每一次直接将路径写在代码中，效率是非常低的，不可取，因为这只是在我们自己的电脑上用时，路径是这样的，但是当移植到别人的电脑上时，路径就会发生改变，所以我们不可避免的会需要修改这些路径。 所以不要直接写在代码中，我们可以通过定义一个变量，然后在修改的时候只需要修改一次，其次，也简化了书写。 12345678# file: 'start.py'# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt'# 在python中的常量，通常通过全部大写的变量名来定义，但是其本质和一个普通变量没有区别，但是大家统一用全部大写来定义一个常量 ​ 通常这类用于配置程序的变量，我们应该将它们都统一的放到单独的配置文件当中，不应该与我们的函数功能存放在一起。所以更好的做法是新建一个文件，将配置文件放进去。 12345678# 所以我们有了config这个文件夹，并在里边创建一个settings.py文件# file:'settings.py'# 将配置信息写入settings.py# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt' 公共模块通常我们还会在很多时候，在进行关键操作之前需要进行验证，也就是说例如在atm功能中，在转账、提现、存款时，无论想要操作哪一步都需要先进行登陆验证，那么这时候这个验证功能的函数，就属于公共模块。 1234# file: 'common.py'# 登陆验证装饰器def login_auth(): pass 日志文件 log.txt 和 数据文件 db.txt区分业务逻辑和启动代码另外我们可以将程序的业务逻辑和启动代码，进行分离，创建一个start.py 和 将业务逻辑模块放入core文件夹中（e.g. ATM.py） 1234567891011121314151617181920212223242526272829303132# file: 'ATM.py'# 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') # file: 'start.py'start() 执行文件最后start.py就是一个执行文件通常我们放在bin文件夹中，即使有多个执行文件，我们也可以将其统一到bin文件夹中。 定制程序的入口为了给用户提供便利，我们程序的入口应该从core业务逻辑中转移到start.py文件中，所以我们需要将start.py中导入core下的ATM并执行start。 123456789# file:'start.py'import core.ATMcore.ATM.start()# 运行结果Traceback (most recent call last): File "/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.py", line 16, in &lt;module&gt; import core.ATMModuleNotFoundError: No module named 'core' 很显然这样配置之后，我们以为导入了 ‘core’ 模块，但是运行结果很明确的告诉我们没有找到名字叫 ‘core’ 的模块，所以我们需要导入模块。 1234567891011121314151617# file: 'start.py'import sys,osprint(__file__)# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.pyprint(os.path.dirname(__file__))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/binprint(os.path.dirname(os.path.dirname(__file__)))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范 # 为了能够找到所有模块，把‘标准目录规范’下的下的所有文件夹导入到环境变量中BASE_DIC = os.path.dirname(os.path.dirname(__file__))sys.path.append(BASE_DIC)import core.ATMcore.ATM.start()# 定制程序的入口就结束啦 使用标准目录后引用配置文件在上述的case中，我们把文件的路径等配置文件，放在了 settings.py 文件中，那么我们在ATM中要使用这些配置文件，就需要导入config下的settings.py 12345678910# file: 'ATM.py'# 导入配置文件 settings.pyfrom config import settingsdef login(): with open(settings.DB_PATH,'rt',encoding='utf-8') as read_f: # 这里用settings.DB_PATH来调用读取文件路径 print(read_f.read()) ... 引用自定义模块为之前的功能添加日志功能 12345678910111213141516# file: 'common.py'# 导入配置文件 config 下的 settings 模块from config import settings# 新增一个日志功能def logger(msg): with open(settings.LOG_PATH,'at',encoding='utf-8') as write_f: write_f.write(msg) # file: 'ATM.py'from lib import commondef login(): with open(DB_PATH,'rt',encoding='utf-8') as read_f: print(read_f.read()) print('Login') common.logger('XXX登陆系统\n')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——字典dict]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8dict%2F</url>
    <content type="text"><![CDATA[什么是字典字典是一种可变容器模型，且可以储存任意类型对象。为什么称之为字典，是因为，在使用过程中就像查字典，你要查 ‘apple’ 这个单词，你通过首字母，会先查找 ‘a’ ——&gt; ‘p’——&gt;’p’ 然后你就找到了 ‘apple’ ,而不需要像列表一样从第一个元素开始找到最后一个元素，所以某种程度上来说，字典要比列表快的多，而 list 越大，查找就越慢。 定义：在{}内用 ‘,’ 分隔开多个 key:value ，通常 key 必须是一个不可变的类型，而通常呢我们使用字符串来表达key，用来描述 value 的特征， 而value可以是任意数据类型。 12345678# e.g.info=&#123; 'name':'David', 'age':18, 'gender':'male', 'height':180, 'hobbies':['programming','read','fitness']&#125; 字典的特性 字典value可以是任何的python对象，但key不行。 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个值会被记住 key必须不可变， 所以可以用数字，字符串或元组充当，而用列表就不行 能存多个值 无序 可变（值可以变，id不变） 不可hash 字典的使用####访问字典里的值 123456789101112131415&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['name'] # 按key取值'David'&gt;&gt;&gt; info['age']18&gt;&gt;&gt; info['hobbies']['programming', 'read', 'fitness']&gt;&gt;&gt; info['hobbies'][2] # 先按key取值，再按列表取值'fitness' 计算字典元素个数，即计算key的总数123456789&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; len(info)5 按key存取值：可存可取123456789101112131415161718&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['weight']=130 # 往字典里添加元素&gt;&gt;&gt; info&#123;'name': 'David', 'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness'], 'weight': 130&#125;# get&gt;&gt;&gt; a = info.get('name')&gt;&gt;&gt; a'David'&gt;&gt;&gt; a = info.get('nameXXX') # 取不到值 不会报错 会返回一个None&gt;&gt;&gt; print(a)None 删除元素12345678910111213141516&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; del info['name'] # 直接修改原值&gt;&gt;&gt; info&#123;'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness']&#125;&gt;&gt;&gt; info.clear() # 清空字典&#123;&#125;&gt;&gt;&gt; del info # 删除字典Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'info' is not defined 成员运算 in 和 not in1234567891011&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; 18 in info # 查看的是key是否在字典中False&gt;&gt;&gt; 'age' in infoTrue 循环12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; for k in info.keys() # 取key... print(k)...nameagegenderheighthobbies&gt;&gt;&gt; for k in info: # 默认输出key... print(k)... nameagegenderheighthobbies# 取value&gt;&gt;&gt; for v in info.values():... print(v)... David18male180['programming', 'read', 'fitness']&gt;&gt;&gt; for k,v in info.items(): # 同时取出key 和 value... print(k,v)...name Davidage 18gender maleheight 180hobbies ['programming', 'read', 'fitness'] 快速创造一个字典123456789# fromkeys:需求是快速新造出一个字典，value的初始值全部都为None# key来自一个列表&gt;&gt;&gt; keys = ['name','age','gender']&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; for k in keys:... d[k] = None&gt;&gt;&gt; d=&#123;&#125;.fromkeys(keys,None)&gt;&gt;&gt; print(d)&#123;'name': None, 'age': None, 'gender': None&#125; setdefault12345678910&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; res = info.setdefault('age', 123456) # 在key存在的情况下不修改值,会返回原值&gt;&gt;&gt; res 18]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——列表list]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8list%2F</url>
    <content type="text"><![CDATA[1. 什么是列表 list列表 list 是 Python 内置的一种数据类型。在[]用逗号分隔开多个任意类型的值，通常用来描述同一种类型的值，放入列表。 list 的特点： 有序 存多个值 可以按索引村取值 可以随时添加和删除其中的元素 可变类型（可变：值可变，id不变） 不可hash 2. 如何使用列表 list 获取列表 list中元素的个数 12345&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# len() 是 Python 的内置函数之一,主要功能是返回对象的长度或者项目个数# 对象可以是（字符串、列表、元祖、集合、字典）&gt;&gt;&gt; len(name) 4 取列表中重复的元素 123&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose','Nick']&gt;&gt;&gt; name.count('Nick')2 按索引取值 12345678910111213141516&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0] # 按索引来访问list中每一个位置的元素，位置从0开始计算'David'&gt;&gt;&gt; name[1]'Nick'&gt;&gt;&gt; name[-1] # 索引 -1 代表直接取到列表的最后一个值 也就是倒数第一个值'Rose'&gt;&gt;&gt; name[-2] # 依次类推 可以取倒数第二个值'Rachel'&gt;&gt;&gt; name[4] # 当索引取4时，列表索引超过了范围，就会提示你列表索引超过了范围Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range# 最后一个元素的索引可以 可以用 元素个数减1 也可以表示为 len(name)-1 按值找索引 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.index('Rachel')2&gt;&gt;&gt; name.index('Lily')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'Lily' is not in list 添加元素 123456789101112131415161718192021222324252627&gt;&gt;&gt; name = [] # 声明一个空列表# append&gt;&gt;&gt; name.append('David')&gt;&gt;&gt; name # 打印列表['David'] &gt;&gt;&gt; name.append('Nick')&gt;&gt;&gt; name['David', 'Nick'] # .append()追加 在列表最后一个元素后边追加元素&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.append(new_name)['David', 'Nick', ['Jack', 'Lily']]# 我们看到结果是append 将一整个new_name作为一个整体传入name中作为一个元素# extend# 那其实我们还有另外一种添加的方法 .extend()# .extend()可以把new_name中的元素一个一个加入到name中&gt;&gt;&gt; name = ['David','Nick']&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.extend(new_name)['David', 'Nick', 'Jack', 'Lily']# 那么如果想要在指定位置追加元素呢&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name.insert(1,'Jim') # insert(你想插入的位置，插入的内容)&gt;&gt;&gt; name['David', 'Jim', 'Nick', 'Rachel'] 删除元素 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# pop&gt;&gt;&gt; name.pop() # 默认删除列表最后一个元素 并且有返回值 ‘Rose’ 改变原列表'Rose'&gt;&gt;&gt; name['David', 'Nick', 'Rachel']&gt;&gt;&gt; name.pop(1) # pop写入索引 按索引删除指定位置的元素'Nick'&gt;&gt;&gt; name&gt;&gt;&gt; ['David', 'Rachel']# del&gt;&gt;&gt; del name[0] # 按索引删除 name列表中的元素&gt;&gt;&gt; name['Rachel']# remove&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.remove(0) # 尝试用索引Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# 报错 参数x 不在list中&gt;&gt;&gt; name.remove('Rachel')&gt;&gt;&gt; name # 可以看出remove的参数 传入的必须是是list中的元素内容['David', 'Nick', 'Rose']# clear&gt;&gt;&gt; name.clear() # 不会返回一个列表，而是返回给你一个内存地址 &lt;built-in method clear of list object at 0x1048b0148&gt;&gt;&gt;&gt; name.clear()&gt;&gt;&gt; name[] # 清空列表 替换元素 123456&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[1] = 'Mary' # 将索引[1]位置的元素替换成 'Mary'&gt;&gt;&gt; name['David', 'Mary', 'Rachel', 'Rose']&gt;&gt;&gt; name[-1] = 'Jack' # 同理正反取索引 都以用来替换元素['David', 'Mary', 'Rachel', 'Jack'] 列表的嵌套 1234567891011&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name_2 = ['Rose', name]&gt;&gt;&gt; name_2['Rose', ['David', 'Nick', 'Rachel']]# 如何取值 取到'Nick'# name_2 = ['Rose', name] 其实就是在name_2的列表中套了一个name# 在这里可以把name看作是name_2中的元素# 我们要取到name中的'Nick' 就需要先取值 取到name_2中的 name元素# 然后再取 name 中的'Nick'元素 所以我们就可以怎么干&gt;&gt;&gt; name_2[1][1]'Nick' 切片（有头，无尾，步长默认为1） 12345678910111213141516171819202122&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[0:3] # 返回值可以通过声明一个变量去接收['David', 'Nick', 'Rachel']# 有头指的是从索引[0]开始，无尾是取不到索引[3]= 'Rose'位置的值&gt;&gt;&gt; name # 不会改变原列表 ['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0:4:2] # 这里没有报超出索引范围的错误，可以看出只取到了[3]# 默认步长为1，这里改为2，意思就是为 一个 隔 一个 取值['David', 'Rachel']&gt;&gt;&gt; name[0:] # 意思为 从列表的头，取到列表的尾巴，就是取到元素最后一个值['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[1:]['Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[-2:] # 从倒数第二个值开始取，取到列表的尾巴['Rachel', 'Rose']&gt;&gt;&gt; name[:-1] # 从最开头，取到倒数第一个值，有头无尾，所以不会取最后一个值['David', 'Nick', 'Rachel']&gt;&gt;&gt; name[:-2]['David', 'Nick']&gt;&gt;&gt; name[:] # 不传入任何参数，就是从头取到尾['David', 'Nick', 'Rachel', 'Rose'] 成员运算 in和not in 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; 'David' in name # 判断name这个列表中是否有'David',然后返回一个布尔值True&gt;&gt;&gt; 'Lily' in nameFalse&gt;&gt;&gt; 'Lily' not in name # 判断name这个列表中 没有'Lily',然后返回一个布尔值True 循环 12345678&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; for item in name: ... # for 循环通常用来取值 这里将name列表中的元素一个一个取出来... print(item)DavidNickRachelRose 排序 1234567891011121314151617181920&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# reverse 反转列表&gt;&gt;&gt; name.reverse() # 直接改变原列表，反转&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[::-1] # 通过切片的方式反转列表['Rose', 'Rachel', 'Nick', 'David']# sort 对原列表排序&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.sort(reverse = True) # 直接改变原列表，反转，无返回值&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']# 默认参数 sort(cmp = None,key = None,reverse = False)# cmp: 按照传入参数的方法进行排序，还没学到# key：主要用来进行排序，只有一个参数，具体的函数参数取自可迭代对象中，指定可迭# 代对象中的一个元素来进行排序（先不管，还没法理解）# reverse = False(默认序列) reverse = True (反转序列)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LoveMyCountry]]></title>
    <url>%2F2018%2F10%2F11%2FLoveMyCountry%2F</url>
    <content type="text"><![CDATA[I Love My Country前言​ 今天讲的这个话题其实可以说比较敏感的，得益于github pages拒绝百度爬虫，让我在这里敢写下这篇blog——关于‘爱国上网’。写这篇帖子的初衷非常简单，希望大家能多用于学习和开拓眼界。 申明须知严格禁止任何人使用海外、国内VPS主机、服务器用于违规、违法用途。严禁个人售卖行为！严禁个人售卖行为！严禁个人售卖行为！重要的事说三遍！正文由于我个人正在使用的服务器是来自Bwh,个人建议是优先选择CN2机房方案，因为联通和电信都是直连，白天和晚上的速度都比较稳定，虽然偶尔也会抽风但是相比普通线路机房会好很多。但是如果我们不追求速度要求的话，普通KVM和OVZ方案也是可以选择的。那么在这篇文章里呢我推荐大家购买kvm，由于前几年都是使用kvm方案，网速并没有什么大碍且在Bwh中性价比极高。其实服务器有很多，但是bwh对于新手和不想深入了解只想自己使用的人而言，无疑非常容易上手，因为它服务器有一键式的ss安装。其实曾今在国内我购买过阿里云的香港服务器，很不幸没活过2个月。 一、新注册搬瓦工账户入口 点击此处进入注册网址 我们可以看到下图所示，看到当前所有的搬瓦工VPS可购买的配置型号。我们直接创建账户是不行的，我们需要先找一个可以购买的机器，Order Now购买，在这里我们选择购买，但是我们最后不付款，只进行注册！不付款！只进行注册！ 下一步 点击Add to Cart 接着点击 Check out 这里不会支付，放心点吧！只是为了假装支付进入他的注册页面，因为正常的注册界面有验证码，无法验收所以必须要曲线救国。 这里就比较关键，我们需要输入新注册账户的个人信息。全部用拼音填写，尽量真实一点，尤其是国家和地区部分需要真实。你乱写容易出现欺诈订单和不通过。其次，也可以看到付款方式有paypal和alipay，相比较而言国内小伙伴应该alipay用的比较多。 在这里我们可以选择好alipay，然后下方的 terms of service打勾，点击complete order，这里回跳转到支付页面只要退出，回到主页就可以通过登陆，登陆新账号啦。 二、选择服务器这里的话，我只推荐Basic VPS - Self-managed - SPECIAL 10G KVM PROMO V3 - LOS ANGELES - CN2大家可以直接点击这个网址进入网址挑选购买，每个月500g的流量，机房是losangeles-cn2，年费为29.99美金/年，对于我上社交软件，查资料，甚至看视频，几乎没有障碍，十分稳定，流量也足够我挥霍。 这里点几Order Now进入购买页面 ————&gt; 下一页面点击Add to Cart 然后进入购物车页面，点击Checkout，记得要登陆后购买！支持支付宝alipay付款 三、配置服务器付款成功后，进入主页，在主页点击client area 点击你的服务器services中 选择 my services 然后你会看见你刚刚购买的服务器，点击KiwiVM Control Panel进入控制台 如果你发现你的operating system和我不一样 不是Centos 6 x86_64 bbr,请点击这个页面中的stop停止你的服务器，然后进入左边Install new OS，找到相印的版本安装。 安装完成后点击 四 配置上网Win10/macos用户看这里： 你获取了你的加密、端口和密钥后，只要进行最后一步配置就可以啦。我们需要下载shadowsocks,那么根据不同用户呢有不同的下载地址，点击下方地址就可以啦。 win10: https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E macos： https://github.com/shadowsocks/ShadowsocksX-NG 至于 安卓和ios下的安装和使用，你可以直接联系我啊！实在是太复杂了，就不一一赘述啦。 看不懂请谷歌百度 下载完成后我们要进行配置啦 大同小异，这里我统一用mac版来做范例了 打开那个纸飞机，它会出现在你的菜单栏上 找到servers——&gt;进入 server preferences 其中ip地址在你的刚刚服务器的控制台的main controls中找的到，ip地址后的端口和其余的都在shadowsocks server中能找到。 当你把所有的东西都弄好后，你就可以享受全世界啦！ Hello world! 然后稍微介绍一下这个小飞机的用途： 它分 PAC模式 和 Global 模式，意思也很简单，pac模式下，国内能打开的网址走国内，打不开的网址走服务器，global模式下所有网址一律走服务器。建议使用pac，有特殊情况使用global，开了global也别忘了关。 有任何问题联系我哦 完结]]></content>
      <categories>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages & Hexo 搭建个人blog]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BAblog%E2%80%94%E2%80%94Github%20Pages%26Hexo%2F</url>
    <content type="text"><![CDATA[前言趁着今天自习的机会，本着想花费一上午的时间来解决github pages&amp;hexo搭建个人blog，结果啊整整花了一天，头一低一抬，8点又8点了。之所以有这个欲望是因为，之前都是用博客园写blog，第一天被学长瞅见，学长：low 逼！我也觉得low，苦在真的没空抽身搭建这个github pages，今天总算是忙里偷闲。 这个真的超级酷！！！！ 其实搭建差不多花了俩三个小时吧，踩了不少坑。不过最让人兴奋的就是搭建好的时候，开始慢慢美化自己的blog的过程，真是美妙啊。那么这次和我一起研究搭建个人blog的呢，还有我的室友Musibii。那么当然不出意外的，我们也是借鉴了许许多多过去的经验贴啊，没想到还是踩了一个又一个的坑啊。好了，废话不多说，那么开始我们的表演吧。 Github注册那么既然我们要使用github pages，肯定就需要一个github的账号。点击 Github 这个进入主页，然后点击右上角 sign up 一通操作后……恭喜你，成为了全球最大的同性交友网站的一员。（建议注册时用户名最好不要有大写字母！） 注册后，你就需要搭建一个库，点击左下方new repository，开始建库。 点击下边的create repository就注册成功啦。 这时候点击右上角的头像，选择your repositories，就可以看见你的库里有一个项目啦。 Hexo这里我和Musibii在Hexo和Jekyll两个最流行的blog框架中，选择了Hexo(js速度比较快吧，其次据说学习成本低，没感觉低) Hexo 基于Nodejs，如果你不是很熟悉这些不知道什么玩意的东西的话呢，暂时也不用深究，接下来的每一步都要小心小心仔细仔细，就ok啦。 安装git $ brew install git // 安装Git brew 是 homebrew 的功能之一，所以你需要install homebrew，这些安装都在你的终端/terminal当中完成，具体的安装homebrew命令官方网站中有。 安装nodejs 安装nodejs呢，需要先安装nvm，nvm是nodejs的版本管理器，用来切换nodejs的版本，这里建议用curl方式安装，homebrew安装的方式会少文件夹，导致后边无法正常安装。 $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装完成后重启你的terimal，再安装nodejs。 $ nvm install 8 需要注意的是后边的8是nodejs的版本号，如果你隔了很久搜到了这篇帖子，请去查寻最新的nodejs的版本，否则会导致你的版本过低而在安装过程中出现warning，最后导致error。 安装hexo 完成以上安装再安装hexo $ sudo npm install hexo-cli -g 到这里呢所有的工具都已经安装好了 编写发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(你的用户名.github.io) 创建博客 下边出现的所有username都需替换成你自己的username $ hexo init username.github.io 成功后会创建出一个名为 username.github.io的文件夹 更改配置 主题安装 我们为了使博客好看点，这里我们需要安装一个主题，在terminal中，进入刚刚生成username.github.io的文件夹目录，安装主题。 $ cd username.github.io $ git clone https://github.com/iissnan/hexo-theme-next themes/next 这是我现在用的主题。 基础配置：我们可以在 文件夹中 打开username.github.io的文件夹 如果你不会vim之类的话，macos就是通过finder，找到username.github.io的文件夹下的_config.yml修改几个基础配置，注意配置的：后必须要有空格 title: MakeUpStories //你博客的名字 author: oOC //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改。 可以先去hexo next官网中，查看官方文档，把基础的看完，你就可以去简书啊之类的查看更加进阶的设置，目前我的设置页十分的基础。 写文章 写文章的话我这里直接用的内置username.github.io/source/_posts下的helloworld.md文件进行测试。 测试 $ hexo s 进行服务器测试，在终端中你会收到返回信息，在https://localhost:4000中你可以查看当前的blog是什么样子的。 安装hero-deployer-git工具 如果之前一切都顺利的话，在这里就可以设置自动部署发布工具啦 $ npm install hexo-deployer-git --save 发布 最后的最后，如果你的测试一切都ok，没有问题的话，我们就生成一个静态网页文件发布至我们的github pages当中啦。 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在输入命令之后，会让你输入github的邮箱！！一定是邮箱和密码，别以为用户名能登陆就用用户名，一定要用邮箱啊！然后你的blog就被上传至github了，以后写完blog，都要执行一下这个命令上传blog。 最后：我的bloghttps://makeupstories.github.io/ 这是我的第一篇blog，之后有空的话，我还会更新如何搭建科学上网，以及在mac系统上比较好用的app和小插件，另外还有我的python学习之路。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
