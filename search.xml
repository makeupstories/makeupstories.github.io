<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python——目录规范]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[标准目录规范在学习模块和包之前，就已经写过了ATM和购物车的项目，但是当时我们没有学习模块和包，所以当时是所有的函数功能都写在一个.py文件当中，虽然实现了功能，但是当时就发现，在实际写代码时，过程非常的复杂，看起来比较乱，所以在学习模块和包以后呢，我们应该根据项目，应该分什么文件，分什么样的文件夹，那么在初期呢，我们有一个固定的文件结构，就是今天的要说的开发的标准目录规范。 配置文件e.g. case : ATM 123456789101112131415161718# 此代码块用于表示我的目录# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范标准目录规范 ———————— | # 文件和模块 # 目录 bin-------------- start.py | config----------- settings.py | core------------- ATM.py | db--------------- db.txt | lib-------------- common.py | log-------------- log.txt | readme.txt（说明文档） 1234567891011121314151617181920212223242526272829303132# file: 'start.py' # 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') start() 在case中，可以发现我们使用到了文件的路径，在之后的功能中，日志文件，或者数据文件等，我们会不止一次的使用到文件路径，那么我们每一次直接将路径写在代码中，效率是非常低的，不可取，因为这只是在我们自己的电脑上用时，路径是这样的，但是当移植到别人的电脑上时，路径就会发生改变，所以我们不可避免的会需要修改这些路径。 所以不要直接写在代码中，我们可以通过定义一个变量，然后在修改的时候只需要修改一次，其次，也简化了书写。 12345678# file: 'start.py'# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt'# 在python中的常量，通常通过全部大写的变量名来定义，但是其本质和一个普通变量没有区别，但是大家统一用全部大写来定义一个常量 ​ 通常这类用于配置程序的变量，我们应该将它们都统一的放到单独的配置文件当中，不应该与我们的函数功能存放在一起。所以更好的做法是新建一个文件，将配置文件放进去。 12345678# 所以我们有了config这个文件夹，并在里边创建一个settings.py文件# file:'settings.py'# 将配置信息写入settings.py# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt' 公共模块通常我们还会在很多时候，在进行关键操作之前需要进行验证，也就是说例如在atm功能中，在转账、提现、存款时，无论想要操作哪一步都需要先进行登陆验证，那么这时候这个验证功能的函数，就属于公共模块。 1234# file: 'common.py'# 登陆验证装饰器def login_auth(): pass 日志文件 log.txt 和 数据文件 db.txt区分业务逻辑和启动代码另外我们可以将程序的业务逻辑和启动代码，进行分离，创建一个start.py 和 将业务逻辑模块放入core文件夹中（e.g. ATM.py） 1234567891011121314151617181920212223242526272829303132# file: 'ATM.py'# 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') # file: 'start.py'start() 执行文件最后start.py就是一个执行文件通常我们放在bin文件夹中，即使有多个执行文件，我们也可以将其统一到bin文件夹中。 定制程序的入口为了给用户提供便利，我们程序的入口应该从core业务逻辑中转移到start.py文件中，所以我们需要将start.py中导入core下的ATM并执行start。 123456789# file:'start.py'import core.ATMcore.ATM.start()# 运行结果Traceback (most recent call last): File "/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.py", line 16, in &lt;module&gt; import core.ATMModuleNotFoundError: No module named 'core' 很显然这样配置之后，我们以为导入了 ‘core’ 模块，但是运行结果很明确的告诉我们没有找到名字叫 ‘core’ 的模块，所以我们需要导入模块。 1234567891011121314151617# file: 'start.py'import sys,osprint(__file__)# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.pyprint(os.path.dirname(__file__))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/binprint(os.path.dirname(os.path.dirname(__file__)))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范 # 为了能够找到所有模块，把‘标准目录规范’下的下的所有文件夹导入到环境变量中BASE_DIC = os.path.dirname(os.path.dirname(__file__))sys.path.append(BASE_DIC)import core.ATMcore.ATM.start()# 定制程序的入口就结束啦 使用标准目录后引用配置文件在上述的case中，我们把文件的路径等配置文件，放在了 settings.py 文件中，那么我们在ATM中要使用这些配置文件，就需要导入config下的settings.py 12345678910# file: 'ATM.py'# 导入配置文件 settings.pyfrom config import settingsdef login(): with open(settings.DB_PATH,'rt',encoding='utf-8') as read_f: # 这里用settings.DB_PATH来调用读取文件路径 print(read_f.read()) ... 引用自定义模块为之前的功能添加日志功能 12345678910111213141516# file: 'common.py'# 导入配置文件 config 下的 settings 模块from config import settings# 新增一个日志功能def logger(msg): with open(settings.LOG_PATH,'at',encoding='utf-8') as write_f: write_f.write(msg) # file: 'ATM.py'from lib import commondef login(): with open(DB_PATH,'rt',encoding='utf-8') as read_f: print(read_f.read()) print('Login') common.logger('XXX登陆系统\n')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——字典dict]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8dict%2F</url>
    <content type="text"><![CDATA[一、什么是字典字典是一种可变容器模型，且可以储存任意类型对象。为什么称之为字典，是因为，在使用过程中就像查字典，你要查 ‘apple’ 这个单词，你通过首字母，会先查找 ‘a’ ——&gt; ‘p’——&gt;’p’ 然后你就找到了 ‘apple’ ,而不需要像列表一样从第一个元素开始找到最后一个元素，所以某种程度上来说，字典要比列表快的多，而 list 越大，查找就越慢。 定义：在{}内用 ‘,’ 分隔开多个 key:value ，通常 key 必须是一个不可变的类型，而通常呢我们使用字符串来表达key，用来描述 value 的特征， 而value可以是任意数据类型。 12345678# e.g.info=&#123; 'name':'David', 'age':18, 'gender':'male', 'height':180, 'hobbies':['programming','read','fitness']&#125; 二、字典的使用 访问字典里的值 计算字典元素个数，即计算key的总数 按key存取值：可存可取 删除元素 成员运算 in 和 not in 循环 快速创造一个字典]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——列表list]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8list%2F</url>
    <content type="text"><![CDATA[1. 什么是列表 list列表 list 是 Python 内置的一种数据类型。在[]用逗号分隔开多个任意类型的值，通常用来描述同一种类型的值，放入列表。 list 的特点： 有序 存多个值 可以按索引村取值 可以随时添加和删除其中的元素 可变类型（可变：值可变，id不变） 不可hash 2. 如何使用列表 list 获取列表 list中元素的个数 12345&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# len() 是 Python 的内置函数之一,主要功能是返回对象的长度或者项目个数# 对象可以是（字符串、列表、元祖、集合、字典）&gt;&gt;&gt; len(name) 4 取列表中重复的元素 123&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose','Nick']&gt;&gt;&gt; name.count('Nick')2 按索引取值 12345678910111213141516&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0] # 按索引来访问list中每一个位置的元素，位置从0开始计算'David'&gt;&gt;&gt; name[1]'Nick'&gt;&gt;&gt; name[-1] # 索引 -1 代表直接取到列表的最后一个值 也就是倒数第一个值'Rose'&gt;&gt;&gt; name[-2] # 依次类推 可以取倒数第二个值'Rachel'&gt;&gt;&gt; name[4] # 当索引取4时，列表索引超过了范围，就会提示你列表索引超过了范围Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range# 最后一个元素的索引可以 可以用 元素个数减1 也可以表示为 len(name)-1 按值找索引 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.index('Rachel')2&gt;&gt;&gt; name.index('Lily')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'Lily' is not in list 添加元素 123456789101112131415161718192021222324252627&gt;&gt;&gt; name = [] # 声明一个空列表# append&gt;&gt;&gt; name.append('David')&gt;&gt;&gt; name # 打印列表['David'] &gt;&gt;&gt; name.append('Nick')&gt;&gt;&gt; name['David', 'Nick'] # .append()追加 在列表最后一个元素后边追加元素&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.append(new_name)['David', 'Nick', ['Jack', 'Lily']]# 我们看到结果是append 将一整个new_name作为一个整体传入name中作为一个元素# extend# 那其实我们还有另外一种添加的方法 .extend()# .extend()可以把new_name中的元素一个一个加入到name中&gt;&gt;&gt; name = ['David','Nick']&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.extend(new_name)['David', 'Nick', 'Jack', 'Lily']# 那么如果想要在指定位置追加元素呢&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name.insert(1,'Jim') # insert(你想插入的位置，插入的内容)&gt;&gt;&gt; name['David', 'Jim', 'Nick', 'Rachel'] 删除元素 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# pop&gt;&gt;&gt; name.pop() # 默认删除列表最后一个元素 并且有返回值 ‘Rose’ 改变原列表'Rose'&gt;&gt;&gt; name['David', 'Nick', 'Rachel']&gt;&gt;&gt; name.pop(1) # pop写入索引 按索引删除指定位置的元素'Nick'&gt;&gt;&gt; name&gt;&gt;&gt; ['David', 'Rachel']# del&gt;&gt;&gt; del name[0] # 按索引删除 name列表中的元素&gt;&gt;&gt; name['Rachel']# remove&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.remove(0) # 尝试用索引Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# 报错 参数x 不在list中&gt;&gt;&gt; name.remove('Rachel')&gt;&gt;&gt; name # 可以看出remove的参数 传入的必须是是list中的元素内容['David', 'Nick', 'Rose']# clear&gt;&gt;&gt; name.clear() # 不会返回一个列表，而是返回给你一个内存地址 &lt;built-in method clear of list object at 0x1048b0148&gt;&gt;&gt;&gt; name.clear()&gt;&gt;&gt; name[] # 清空列表 替换元素 123456&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[1] = 'Mary' # 将索引[1]位置的元素替换成 'Mary'&gt;&gt;&gt; name['David', 'Mary', 'Rachel', 'Rose']&gt;&gt;&gt; name[-1] = 'Jack' # 同理正反取索引 都以用来替换元素['David', 'Mary', 'Rachel', 'Jack'] 列表的嵌套 1234567891011&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name_2 = ['Rose', name]&gt;&gt;&gt; name_2['Rose', ['David', 'Nick', 'Rachel']]# 如何取值 取到'Nick'# name_2 = ['Rose', name] 其实就是在name_2的列表中套了一个name# 在这里可以把name看作是name_2中的元素# 我们要取到name中的'Nick' 就需要先取值 取到name_2中的 name元素# 然后再取 name 中的'Nick'元素 所以我们就可以怎么干&gt;&gt;&gt; name_2[1][1]'Nick' 切片（有头，无尾，步长默认为1） 12345678910111213141516171819202122&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[0:3] # 返回值可以通过声明一个变量去接收['David', 'Nick', 'Rachel']# 有头指的是从索引[0]开始，无尾是取不到索引[3]= 'Rose'位置的值&gt;&gt;&gt; name # 不会改变原列表 ['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0:4:2] # 这里没有报超出索引范围的错误，可以看出只取到了[3]# 默认步长为1，这里改为2，意思就是为 一个 隔 一个 取值['David', 'Rachel']&gt;&gt;&gt; name[0:] # 意思为 从列表的头，取到列表的尾巴，就是取到元素最后一个值['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[1:]['Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[-2:] # 从倒数第二个值开始取，取到列表的尾巴['Rachel', 'Rose']&gt;&gt;&gt; name[:-1] # 从最开头，取到倒数第一个值，有头无尾，所以不会取最后一个值['David', 'Nick', 'Rachel']&gt;&gt;&gt; name[:-2]['David', 'Nick']&gt;&gt;&gt; name[:] # 不传入任何参数，就是从头取到尾['David', 'Nick', 'Rachel', 'Rose'] 成员运算 in和not in 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; 'David' in name # 判断name这个列表中是否有'David',然后返回一个布尔值True&gt;&gt;&gt; 'Lily' in nameFalse&gt;&gt;&gt; 'Lily' not in name # 判断name这个列表中 没有'Lily',然后返回一个布尔值True 循环 12345678&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; for item in name: ... # for 循环通常用来取值 这里将name列表中的元素一个一个取出来... print(item)DavidNickRachelRose 排序 1234567891011121314151617181920&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# reverse 反转列表&gt;&gt;&gt; name.reverse() # 直接改变原列表，反转&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[::-1] # 通过切片的方式反转列表['Rose', 'Rachel', 'Nick', 'David']# sort 对原列表排序&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.sort(reverse = True) # 直接改变原列表，反转，无返回值&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']# 默认参数 sort(cmp = None,key = None,reverse = False)# cmp: 按照传入参数的方法进行排序，还没学到# key：主要用来进行排序，只有一个参数，具体的函数参数取自可迭代对象中，指定可迭# 代对象中的一个元素来进行排序（先不管，还没法理解）# reverse = False(默认序列) reverse = True (反转序列)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LoveMyCountry]]></title>
    <url>%2F2018%2F10%2F11%2FLoveMyCountry%2F</url>
    <content type="text"><![CDATA[I Love My Country前言​ 今天讲的这个话题其实可以说比较敏感的，得益于github pages拒绝百度爬虫，让我在这里敢写下这篇blog——关于‘爱国上网’。写这篇帖子的初衷非常简单，希望大家能多用于学习和开拓眼界。 申明须知严格禁止任何人使用海外、国内VPS主机、服务器用于违规、违法用途。严禁个人售卖行为！严禁个人售卖行为！严禁个人售卖行为！重要的事说三遍！正文由于我个人正在使用的服务器是来自Bwh,个人建议是优先选择CN2机房方案，因为联通和电信都是直连，白天和晚上的速度都比较稳定，虽然偶尔也会抽风但是相比普通线路机房会好很多。但是如果我们不追求速度要求的话，普通KVM和OVZ方案也是可以选择的。那么在这篇文章里呢我推荐大家购买kvm，由于前几年都是使用kvm方案，网速并没有什么大碍且在Bwh中性价比极高。其实服务器有很多，但是bwh对于新手和不想深入了解只想自己使用的人而言，无疑非常容易上手，因为它服务器有一键式的ss安装。其实曾今在国内我购买过阿里云的香港服务器，很不幸没活过2个月。 一、新注册搬瓦工账户入口 点击此处进入注册网址 我们可以看到下图所示，看到当前所有的搬瓦工VPS可购买的配置型号。我们直接创建账户是不行的，我们需要先找一个可以购买的机器，Order Now购买，在这里我们选择购买，但是我们最后不付款，只进行注册！不付款！只进行注册！ 下一步 点击Add to Cart 接着点击 Check out 这里不会支付，放心点吧！只是为了假装支付进入他的注册页面，因为正常的注册界面有验证码，无法验收所以必须要曲线救国。 这里就比较关键，我们需要输入新注册账户的个人信息。全部用拼音填写，尽量真实一点，尤其是国家和地区部分需要真实。你乱写容易出现欺诈订单和不通过。其次，也可以看到付款方式有paypal和alipay，相比较而言国内小伙伴应该alipay用的比较多。 在这里我们可以选择好alipay，然后下方的 terms of service打勾，点击complete order，这里回跳转到支付页面只要退出，回到主页就可以通过登陆，登陆新账号啦。 二、选择服务器这里的话，我只推荐Basic VPS - Self-managed - SPECIAL 10G KVM PROMO V3 - LOS ANGELES - CN2大家可以直接点击这个网址进入网址挑选购买，每个月500g的流量，机房是losangeles-cn2，年费为29.99美金/年，对于我上社交软件，查资料，甚至看视频，几乎没有障碍，十分稳定，流量也足够我挥霍。 这里点几Order Now进入购买页面 ————&gt; 下一页面点击Add to Cart 然后进入购物车页面，点击Checkout，记得要登陆后购买！支持支付宝alipay付款 三、配置服务器付款成功后，进入主页，在主页点击client area 点击你的服务器services中 选择 my services 然后你会看见你刚刚购买的服务器，点击KiwiVM Control Panel进入控制台 如果你发现你的operating system和我不一样 不是Centos 6 x86_64 bbr,请点击这个页面中的stop停止你的服务器，然后进入左边Install new OS，找到相印的版本安装。 安装完成后点击 四 配置上网Win10/macos用户看这里： 你获取了你的加密、端口和密钥后，只要进行最后一步配置就可以啦。我们需要下载shadowsocks,那么根据不同用户呢有不同的下载地址，点击下方地址就可以啦。 win10: https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E macos： https://github.com/shadowsocks/ShadowsocksX-NG 至于 安卓和ios下的安装和使用，你可以直接联系我啊！实在是太复杂了，就不一一赘述啦。 看不懂请谷歌百度 下载完成后我们要进行配置啦 大同小异，这里我统一用mac版来做范例了 打开那个纸飞机，它会出现在你的菜单栏上 找到servers——&gt;进入 server preferences 其中ip地址在你的刚刚服务器的控制台的main controls中找的到，ip地址后的端口和其余的都在shadowsocks server中能找到。 当你把所有的东西都弄好后，你就可以享受全世界啦！ Hello world! 然后稍微介绍一下这个小飞机的用途： 它分 PAC模式 和 Global 模式，意思也很简单，pac模式下，国内能打开的网址走国内，打不开的网址走服务器，global模式下所有网址一律走服务器。建议使用pac，有特殊情况使用global，开了global也别忘了关。 有任何问题联系我哦 完结]]></content>
      <categories>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages & Hexo 搭建个人blog]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BAblog%E2%80%94%E2%80%94Github%20Pages%26Hexo%2F</url>
    <content type="text"><![CDATA[前言趁着今天自习的机会，本着想花费一上午的时间来解决github pages&amp;hexo搭建个人blog，结果啊整整花了一天，头一低一抬，8点又8点了。之所以有这个欲望是因为，之前都是用博客园写blog，第一天被学长瞅见，学长：low 逼！我也觉得low，苦在真的没空抽身搭建这个github pages，今天总算是忙里偷闲。 这个真的超级酷！！！！ 其实搭建差不多花了俩三个小时吧，踩了不少坑。不过最让人兴奋的就是搭建好的时候，开始慢慢美化自己的blog的过程，真是美妙啊。那么这次和我一起研究搭建个人blog的呢，还有我的室友Musibii。那么当然不出意外的，我们也是借鉴了许许多多过去的经验贴啊，没想到还是踩了一个又一个的坑啊。好了，废话不多说，那么开始我们的表演吧。 Github注册那么既然我们要使用github pages，肯定就需要一个github的账号。点击 Github 这个进入主页，然后点击右上角 sign up 一通操作后……恭喜你，成为了全球最大的同性交友网站的一员。（建议注册时用户名最好不要有大写字母！） 注册后，你就需要搭建一个库，点击左下方new repository，开始建库。 点击下边的create repository就注册成功啦。 这时候点击右上角的头像，选择your repositories，就可以看见你的库里有一个项目啦。 Hexo这里我和Musibii在Hexo和Jekyll两个最流行的blog框架中，选择了Hexo(js速度比较快吧，其次据说学习成本低，没感觉低) Hexo 基于Nodejs，如果你不是很熟悉这些不知道什么玩意的东西的话呢，暂时也不用深究，接下来的每一步都要小心小心仔细仔细，就ok啦。 安装git $ brew install git // 安装Git brew 是 homebrew 的功能之一，所以你需要install homebrew，这些安装都在你的终端/terminal当中完成，具体的安装homebrew命令官方网站中有。 安装nodejs 安装nodejs呢，需要先安装nvm，nvm是nodejs的版本管理器，用来切换nodejs的版本，这里建议用curl方式安装，homebrew安装的方式会少文件夹，导致后边无法正常安装。 $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装完成后重启你的terimal，再安装nodejs。 $ nvm install 8 需要注意的是后边的8是nodejs的版本号，如果你隔了很久搜到了这篇帖子，请去查寻最新的nodejs的版本，否则会导致你的版本过低而在安装过程中出现warning，最后导致error。 安装hexo 完成以上安装再安装hexo $ sudo npm install hexo-cli -g 到这里呢所有的工具都已经安装好了 编写发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(你的用户名.github.io) 创建博客 下边出现的所有username都需替换成你自己的username $ hexo init username.github.io 成功后会创建出一个名为 username.github.io的文件夹 更改配置 主题安装 我们为了使博客好看点，这里我们需要安装一个主题，在terminal中，进入刚刚生成username.github.io的文件夹目录，安装主题。 $ cd username.github.io $ git clone https://github.com/iissnan/hexo-theme-next themes/next 这是我现在用的主题。 基础配置：我们可以在 文件夹中 打开username.github.io的文件夹 如果你不会vim之类的话，macos就是通过finder，找到username.github.io的文件夹下的_config.yml修改几个基础配置，注意配置的：后必须要有空格 title: MakeUpStories //你博客的名字 author: oOC //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改。 可以先去hexo next官网中，查看官方文档，把基础的看完，你就可以去简书啊之类的查看更加进阶的设置，目前我的设置页十分的基础。 写文章 写文章的话我这里直接用的内置username.github.io/source/_posts下的helloworld.md文件进行测试。 测试 $ hexo s 进行服务器测试，在终端中你会收到返回信息，在https://localhost:4000中你可以查看当前的blog是什么样子的。 安装hero-deployer-git工具 如果之前一切都顺利的话，在这里就可以设置自动部署发布工具啦 $ npm install hexo-deployer-git --save 发布 最后的最后，如果你的测试一切都ok，没有问题的话，我们就生成一个静态网页文件发布至我们的github pages当中啦。 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在输入命令之后，会让你输入github的邮箱！！一定是邮箱和密码，别以为用户名能登陆就用用户名，一定要用邮箱啊！然后你的blog就被上传至github了，以后写完blog，都要执行一下这个命令上传blog。 最后：我的bloghttps://makeupstories.github.io/ 这是我的第一篇blog，之后有空的话，我还会更新如何搭建科学上网，以及在mac系统上比较好用的app和小插件，另外还有我的python学习之路。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
