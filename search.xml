<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Alfred——Mac效率工具]]></title>
    <url>%2F2018%2F11%2F16%2FAlfred%E2%80%94%E2%80%94Mac%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[AAAlfred! 看见这个骚气的紫色的帽子没有，这也许是我用mac以来，最想向大家推荐的一款软件——Alfred，它到底有多么好用，几乎就像是帮你封装了你的操作系统！那么今天在这里呢，就给大家介绍一下它的基础用法，真的非常基础，但是已经足够让你摆脱很多烦恼了！ 基础设置篇设置Alfred Hotkey使用Alfred的第一步，当然是配置一个调用它的顺手快捷键，自从有了它之后我舍弃了MacOS自带的Spotlight（聚焦搜索）cmd + space可以在全局调出，并且将这个这个组合快捷键转而用来调用Alfred的小窗口，当然你也能根据你自己的喜好搭配，或者你觉着还有必要留着你的Spotlight，但我相信，看完这篇教程你会毫不犹豫的舍弃。 另外更换为cmd + space的组合快捷键，会有一点小问题，由于是MacOS下自带分配给了Spotlight，所以你第一步需要先去取消Spotlight和cmd + space的绑定关系，再在下图中的Alfred Hotkey中修改为cmd + space 取消Spotlight和cmd + space绑定关系，可以点击参考这里 在 General 选项卡的最下面，你可以设置自己所在的国家或地区，不同的选择会导向特定的域名。例如，在加拿大，Google 搜索的默认域名就会被改为 google.ca。这一选项在大部分情况下都无关紧要，但如果你比较依赖科学上网，我建议将其改为你梯子的物理位置，以减少链接重定向次数，加快访问速度。 快速切换应用当你设置好你的快捷键后，你可以用快捷键呼出你Alfred的命令框，然后输入你想调用的APP名称，既可以快速的开启你的应用，而不用再去dock栏或者launchpad中找你的应用软件啦，它既可以帮你开启应用，也可以帮你做到在应用间快速切换。 快捷网页搜索当你设置好你的快捷键后，你可以用快捷键呼出你Alfred的命令框，然后输入任意你想在google中搜索的内容。Alfred会帮你打开你的默认浏览器并在谷歌中搜索相关信息，帮你省去了打开浏览器点击搜索框等步骤。当然你也可以在Alfred中敲入网址直接启动浏览器访问网页。 接下来，我们回到Alfred的设置中，最上边那一行选择Features，找到Web Search。在这里你可以看到很多Alfred帮你设置好的一些URLS。它的效果就是你可以设置你的Keyword，然后通过Keyword就可以在相应的网站中直接查找，同样不需要打开浏览器，即可完成。这里我设置的百度的关键字为bd，谷歌的关键字为google，当然你要是嫌麻烦，你可以自定义你的关键字。 那么如何添加你想查找的网站的URL呢？ 首先点击，Web Search 右下角的 Add Custom Search，会弹出一个小窗口。 这里我列出一些常用网站的URL，方便你们添加： 百度： https://www.baidu.com/s?wd={query} 知乎：https://www.zhihu.com/search?q={query} 微博：https://s.weibo.com/weibo/{query} Bilibili：https://search.bilibili.com/all?keyword={query} 淘宝：https://s.taobao.com/search?q={query} 京东：https://search.jd.com/Search?keyword={query} Github：https://github.com/search?q={query} e.g.百度 快捷网页书签访问点击进入Web Bookmarks，导入你浏览器的书签，在Alfred的命令窗口中就能时间快速访问。 文件搜索操作Alfred 另外内置很多命令操作，例如：open是打开文件，in是查找文件是否包含你所要查找的内容，find是查找文件位置等，当然同样支持自定义快捷键。 系统操作Alfred还支持系统操作，可以根据自定义命令关键字呼出，如果担心误触，只需要取消勾选命令钱的方框或再次确认就可以了。 计算器Alfred的计算器支持完善的函数语法，只要在开头加上‘=’号，你就能使用包括三角、对数、指数、开方等在内的高级运算符，同时支持圆周率等数学常数，瞬间从小学进化到高中知识范围。更详细的语法介绍，你可以参考 Calculator 选项卡中的说明。 词典词典其实我并没有使用它自带的词典功能，而是使用了Alfred的workflows下的有道，在这里先简单介绍一下，我的室友会写关于如何使用Alfred的workflows，之后我会贴上他的blog地址，大家可以链接过去看看。这里先给大家看一下简单的操作，我设置为double click cmd为我的快捷键，然后每次就可以非常方便的查询单词，支持发音，翻译句子，支持选中查询等，真的超级方便。 以上呢，就是Alfred一些基本的我也比较常用的功能，另外其实最主要的一个功能就是词典那里的查词，运用到的workflow，这个功能相关的内容，我的室友会在最近几天更新，之后我会更新我的blog，贴上他的地址，另外使用某些功能的话，需要你们购买powerpack，其实组个团一起买，也没多少钱啦，关键真的非常好用这个软件。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——封装]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装什么是封装？封指的是隐藏的意思，但是这种隐藏对外不对内 装指的是把属性装进一个容器 如何封装只需要在想要封装的数据前加上__开头 （两个下划线），该属性就会被隐藏起来，该隐藏具备的特点： 只是一种语法意义上的变形，开头的属性会在检测语法时发生变形 _类名_\属性名 这种隐藏式对外不对内，因为在类内部检测语法时所有的代码统一都发生的变形 这种变形只在检测语法时发生一次，在类定义之后新增的__开头的属性并不会发生变形 如果父类不想让子类覆盖自己的属性，可以在属性前加__开头 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 这种隐藏式对外不对内，因为在类内部检测语法时所有的代码统一都发生的变形 # class Foo: # __x = 1111 # _Foo__x =1111 # def __init__(self,y): # self.__y = y # # def __f1(self): # print('Foo.f1') # # def get_y(self): # print(self.__y) # _类名__属性名 # obj = Foo(2222) # # print(obj.x) # 找不到属性 # # print(obj.__x) # # print(obj.y) # # print(obj.__y) # # print(obj._Foo__x) # 1111 # print(obj._Foo__y) # obj.get_y()# 这种变形只在检测语法时发生一次，在类定义之后新增的__开头的属性并不会发生变形 # Foo.__aaaaaaaaaaaaaaaaaaaaaa = 1 # print(Foo.__dict__) # '__aaaaaaaaaaaaaaaaaaaaaa': 1# 如果父类不想让子类覆盖自己的方法，可以在方法名前加__开头 # class Foo: # def __f1(self): # print('Foo.f1') # # def f2(self): # print('Foo.f2') # self.__f1() # obj._Foo__f1() # # class Bar(Foo): # def __f1(self): # print('Bar.f1') # # obj = Bar() # obj.f2()# 为何要封装？封装数据属性的目的：将数据属性封装起来，类外部的使用就无法直接操作该数据属性，需要类内部开一个接口给使用者，类的设计者可以在接口智商附加任意逻辑，从而严格控制使用者对属性的操作 封装函数属性的目的：隔离复杂度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 封装不是单纯意义上的隐藏# 封装数据属性的目的：把数据属性封装起来，然后需要开辟接口给类外部的使用者使用# 这样我们可以在接口之上添加控制逻辑，从而严格空间访问者对属性的操作class People: def __init__(self,name,age): self.__name = name self.__age = age def tell_info(self): u = input('user&gt;&gt;&gt; ').strip() p = input('pwd&gt;&gt;&gt; ').strip() if u == 'ooc' and p =='111': print(self.__name,self.__age) def modfiy_info(self,name,age): if type(name) is not str: raise TypeError('必须为str类型') if type(age) is not int: raise TypeError('必须为int类型') self.__name = name self.__age = agep = People('david',18)p.tell_info()p.modfiy_info('Jack',20)p.modfiy_info('Jack','20') # 报错p.modfiy_info(aaaa,20) # 报错# 封装函数属性的目的：为了隔离复杂度class ATM: def __card(self): print('插卡') def __auth(self): print('用户认证') def __input(self): print('输入取款金额') def __print_bill(self): print('打印账单') def __take_money(self): print('取款') def withdraw(self): self.__card() self.__auth() self.__input() self.__print_bill() self.__take_money()obj=ATM()obj.withdraw()# 封装其实最主要的功能就是明确地区分内外，对外是隐藏的，对内是开放的]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——组合与继承]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是组合解决类与类之间代码冗余的问题有两种解决方案： 继承 ：描述的是类与类之间的关系 组合：描述的是一个类产生的对象，该对象拥有一个属性，这个属性的值是来自于另一个类的对象 12345678910111213141516171819202122232425262728293031323334353637383940class Date: def __init__(self,year,mon,day): self.year = year self.mon = mon self.day = day def tell_brith(self): print('出生日期&lt;%s-%s-%s&gt;' %(self.year,self.mon,self.day))class People: school = 'Lixin' def __init__(self,name,age,gender): self.name = name self.age = age self.gender = genderclass Teacher(People): def __init__(self,name,age,gender,level,salary): super().__init__(name,age,gender) self.level = level self.salary = salary def change_score(self): print('%s teacher is changing score.' %self.name)class Student(People): def __init__(self,name,age,gender,course): super().__init__(name,age,gender) self.course = course def choose(self): print('%s student is choosing courses.' %self.name)teacher_1 = Teacher('Lu',30,'male',10,10000)date_obj = Date(1988,1,1)date_obj.tell_brith()teacher_1.birth = date_obj # 为teacher_1 增加birth属性 值等于date_objteacher_1.birth.tell_brith() # teacher_1的名称空间等价于date_obj]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——绑定与非绑定方法]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[绑定方法与非绑定方法绑定方法 特殊之处：绑定给谁就应该由谁来调用，谁来调用就会将谁当做第一个参数自动传入 绑定给对象的方法：在类中定义函数没有被任何装饰器修饰的情况下，默认就是绑定对象的 绑定给类的方法：为类中定义函数添加一个装饰器classmethod，就是绑定类的 非绑定方法 特殊之处：非绑定方法就是一个普通函数，即不与类绑定又不与对象绑定，意味着类与对象都可以调用，但是无论谁来调用都是一个普通函数，没有自动传值效果。 非绑定方法：为类中定义函数添加一个装饰器staticmethod，就是非绑定方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Foo: def func1(self): print('func',self) # 绑定给类方法 @classmethod def func2(cls): print('func2',cls) # 非绑定方法，既不与类绑定又不与对象绑定 @staticmethod def func3(x,y): print('func3',x,y)obj = Foo()# 一、绑定给对象obj.func1()print(obj)# &lt;__main__.Foo object at 0x107f7ee48&gt;# 绑定给对象的方法，类也可以调用，但是类调用就是一个普通函数，# 没有自动传值的效果# Foo.func1() # 需要传值Foo.func1(obj)# 二、绑定给类的方法# 绑定给类的，应该由类来调用print(Foo.func2)print(obj.func2)Foo.func2()obj.func2()# 三、非绑定方法print(obj.func3)print(Foo.func3)obj.func3(1,2)Foo.func3(1,3)# caseimport settingsclass MySQL: def __init__(self,ip,port): self.id=self.create_id() self.ip=ip self.port=port def tell_info(self): print('&lt;%s:%s:%s&gt;' % (self.id,self.ip, self.port)) @classmethod def from_conf(cls): return cls(settings.IP, settings.PORT) @staticmethod def create_id(): import uuid return uuid.uuid4()# obj=MySQL('1.1.1.1.1',3406)# obj1=MySQL('1.1.1.2',3406)# obj.tell_info()print(MySQL.from_conf)a = MySQL.from_conf() # 要有变量接受返回值# 用a调用传入返回值a.tell_info()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——多态]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态什么是多态？多态指的是同一种事物多种形态 为何要用多态？用基类创建一套规则，强制子类去遵循，这样便可以再不用考虑对象具体类型的前提下而直接使用对象下的方法 如何用多态？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Animal: def eat(self): pass def drink(self): pass def bark(self): passclass Cat(Animal): def bark(self): print('喵喵喵')class Dog(Animal): def bark(self): print('汪汪汪')c = Cat()d = Dog()# 可以在不考虑对象具体类型的前提下而直接使用对象下的方法# 规则强制import abc #abstract classclass Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def eat(self): pass @abc.abstractmethod def drink(self): pass @abc.abstractmethod def bark(self): pass# obj=Animal() # 抽象基类本身不能被实例化class Cat(Animal): def eat(self): print('cat eat') def drink(self): print('cat drink') def bark(self): print('喵喵喵')class Dog(Animal): def eat(self): print('dog eat') def drink(self): print('dog drink') def bark(self): print('汪汪汪')def BARK(animal): animal.bark()c = Cat()c.bark()BARK(c) 鸭子类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Foo: def f1(self): print('from foo.f1') def f2(self): print('from foo.f2')class Bar: def f1(self): print('from bar.f1') def f2(self): print('from bar.f2')obj1=Foo()obj2=Bar()obj1.f1()obj1.f2()obj2.f1()obj2.f2()class Disk: def read(self): print('disk read') def write(self): print('disk write')class Txt: def read(self): print('txt read') def write(self): print('txt write')class Process: def read(self): print('process read') def write(self): print('process write')obj1=Disk()obj2=Txt()obj3=Process()obj1.read()obj2.read()obj3.read()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——网络编程]]></title>
    <url>%2F2018%2F11%2F02%2FPython%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python基础之socket编程客户端、服务器架构C/S：C = Client，S = Server。C/S 架构即“客户端-服务器”架构。 B/S：B = Browser，S =Server。B/S架构其实是C/S架构一种特殊的实现形式 OSI七层协议 &amp; TCP/IP 五层模型 TCP/IP 五层模型讲解物理层 功能：以二进制数据形式在物理媒体上传输数据。 数据链路层以太网协议（ethernet）： 一组电信号构成一个数据包，叫做 ‘以太帧’ 以太帧（IEEE802.3结构）的组成： Preamble: 前导码，7个字节，用于数据传输过程中的双方发送、接收的速率的同步 SFD: 帧开始符，1个字节，表明下一个字节开始是真实数据 dst MAC: 目标MAC地址，6个字节，指明这个以太帧的接受者 src MAC: 源MAC地址，6个字节，指明这个以太帧的发送者 Length: 长度，2个字节，指明这个以太帧数据字段的长度， Type: 类型，2个字节，指明这个以太帧中数据的协议类型，比如 0x0800 表明该以太帧用的是IPv4的ip协议 Data and Pad: 数据与填充，46~1500个字节，包含了上层协议传递下来的数据，如果加入数据字段后，这个以太帧长度不够64个字节，会在数据字段加入‘填充’使它达到64字节 FCS: 帧校验序列，4个字节，对接收网卡，主要是检测Date and Pad字段，提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧。目前最为流行的用于FCS的算法是循环冗余校验（cyclic redundancy check - CRC） MAC地址（Media Access Control Address）: 每块网卡出厂时，由网卡生产厂家少如网卡的EPROM，它储存的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址，形象的解释，MAC地址就如同身份证上的身份证号码，具有全球唯一性。 广播：有了MAC地址，局域网内的两台主机就可以通信，一台主机通过ARP协议获取另外一台主机的MAC地址。在同一局域网内的主机都会收到一个包，其他主机会收到这个包，并进行拆解，发现目标MAC地址不是自己，就丢弃，如果是自己就响应。 网络层试想，我们现在有了ethernet、MAC地址、广播的发送方式，世界上的计算机都采用以太网的广播方式，的确彼此之间就可以通信le ，但是会出现一个问题，一台主机发送的包就会被全世界收到，这就会造成很多问题，比如效率低下。 那么实际上世界的网络是由一个个小的彼此隔离的局域网组成的，以太网的广播包只能在一个局域网内发送，一个局域网就是一个广播域，以太网的广播包只能在一个广播域内发送，跨广播域通信只能通过路由转发，那么网络层的功能就是找一种办法来区分不同的广播域/子网，这种办法叫做IP协议。 IP协议 规定网络地址的协议叫做IP协议，它定义的地址称之为IP地址，广泛采用的版本为IPv4，它规定网络地址由32位2进制表示。 范围0.0.0.0 - 255.255.255.255 一个IP地址通常携程四段十进制数，例如：127.10.12.1 IP地址分为两部分 网络部分：标识子网 主机部分：标识主机 单纯的IP地址，只是标识了IP地址的种类，从网络部分或主机部分都无法辨识一个IP所处的子网，即：192.168.10.1与192.168.10.2 不能确定二者处于同一个子网内。 子网掩码：就是标识子网特征的一个参数，我们知道了‘子网掩码’后，我们就能判断，任意两个IP地址是否处在同一个子网络内，方法就是将两个IP地址与子网掩码进行AND运算（两个对应数位为1，运算结果就为1，否则为0），然后比较结果是否相同，如果是的话，就表明这两个IP地址，在同一个子网络中，否则就不是。 IP协议，最主要的功能由两个：一个是为每一台计算及分配IP地址，另一个是确定哪些地址在同一个子网络。 IP数据报 ARP协议 传输层以我们的电脑为例，你会在电脑上运行QQ，微信，浏览器等应用软件，网络层的IP+子网掩码帮我们区分了子网，以太网的MAC地址帮我们找到了局域网内的主机，那么如何该分辨你的这个数据是发送给你主机上的哪个应用程序的呢？答案是端口port（端口范围0-65535，0-1023为系统占用端口尽量别用） tcp协议暂时看一下这个超链接大佬写的吧，好像举例更生动点。 应用层应用层是系统的最高层，是直接为应用进程提供服务的，直接和应用程序接口并提供常见的网络应用服务。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 socketSocket我们通常称之为套接字，是在应用层和TCP/IP协议族通信的一个抽象层。它把运输层和网络层复杂的复杂的操作抽象为几个简单的接口提供给应用层调用，以此来实现网络中的通信。 套接字发展史及分类 基于文件类型的套接字家族：AF_UNIX（UNIX中一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信） 基于网络类型的套接字家族：AF_INET（python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET） 套接字工作流程]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——异常处理]]></title>
    <url>%2F2018%2F11%2F01%2FPython%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理 什么是异常？异常就是程序运行时发送错误的信号（在程序出现错误时，则会产生一个异常，若程序没有处理它，则会抛出该异常，程序的运行也随之终止） 异常的分类： 语法错误（最低级异常，避免犯错） 语法错误在python解释器的语法检测时，就会报错，必须在程序执行前就改正 逻辑错误 这种异常只有在代码被执行时才能发现，我们要处理的重点就是运行时产生的异常 特点：在没有运行代码前，往往无法很直观的能发现。如果运行时产生异常，并且我们没有正的处理异常时，他就会抛出错误信息，并且终止程序的运行，此时我们可以通过捕捉异常，使我们的程序更加稳定不容易崩溃，但也不意味着能滥用异常处理。 异常的组成 异常的追踪信息（具体发生异常的位置 以及函数的调用顺序） 异常类（错误的类型） 异常值（详细的错误信息） Case：123456789101112131415161718def func(): namefunc()# Traceback (most recent call last): (异常的追踪信息)# File "/Users/ooc/Desktop/异常处理/test.py", line 33, in &lt;module&gt;# func()# File "/Users/ooc/Desktop/异常处理/test.py", line 31, in func# name# （错误的类型）NameError: name 'name' is not defined (详细的错误信息)# 异常处理try: func()except Exception as e: print(e)# name 'name' is not defined 常见异常123456789101112AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的 全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的 异常处理为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，我们需要对异常进行处理。 如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防 如果错误发生的条件是不可预知的，贼需要用到try…except: 在错误发生之后进行处理 123456789101112131415161718192021222324252627282930313233343536# 基本语法try: # 被检测的代码块except 异常类型： # try 中一旦检测到异常，就会执行这个位置的逻辑 # 多种异常类型处理print("staring.....")try: name # 一旦检测到异常，就会执行except的逻辑 [][-1] passexcept NameError: print("名字找不到!")except IndexError: print("索引超出范围")print("end.......")# staring.....# 名字找不到!# end.......# 处理多种异常类型 Exception和BaseExceptionprint("staring.....")try: &#123;&#125;["aaa"] name [][-1] 1/0except Exception: print("可能名字找不到! 可能所以超出范围 可能除数为0")print("end.......")# staring.....# 可能名字找不到! 可能所以超出范围 可能除数为0# end....... 主动抛出异常123456789101112# 当程序中有一些用户没有遵守规则，我们可以主动抛出异常'''语法： raise 异常类型(异常的详细信息) 异常类型必须是BaseException的子类'''# e.gage = input("请输入整型的年龄:")if not age.isdigit(): raise TypeError("你输入的不是整型!")age = int(age)print("十年后你%s岁" % (age + 10)) 异常处理的使用通常只有在错误发生的条件无法预知的情况下，才应该加上try…except 异常不太常用语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 不太常用的 # 语法1 try: except: else: # try中没有发生异常时执行 # 语法2 try : except : finally : # 无论是否发生异常 都会执行finally 可以用来回收系统资源!# casetry: f = open("test.txt","rt",encoding="utf-8") f.read() f.write("123")except Exception: print("发生异常了")finally: print("关闭文件!") f.close() # 断言 assert# Assert statements are a convenient way to insert debugging# assertions into a program # 语法: assert 结果为Bool的表达式 # 如果值为True 则继续往下执行 # 如果值为False 抛出一个 AssertionError 表示断言失败name_list = ['jack','james']if len(name_list) &gt; 2: raise ValuError('列表中只有两个元素')# assert 相当于 ifassert len(name_list) &gt; 2 # 要使用列表中的数据来完成任务，就可以用assert代替if 做判断# 自定义异常类型# 当系统提供的这些异常类型 和你要描述的错误不匹配时 就需要自定义异常类型 # 写法: # class 自定义异常类型名称(BaseException): # 总结一下:之所以自定义异常类型 是为了更具体描述你的错误 让使用者一眼就看出了 # 关键点:1.如何自定义异常类型 # 2.在except中 使用as 来获取异常对象 class UnlikeError(BaseException): def __init(self,msg): self.msg = msg def hello(): msg = input('输入一段话： ') if msg == '你好': print('你好') else: raise UnlikeError('你不好')try: hello()except UnlikeError as e: print(e.msg) # 输入一段话：sagas# 你不好# 输入一段话：你好# 你好]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——内置方法]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E2%80%94%E2%80%94%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内置方法判断对象的类型isintance(对象,类型) 判断是否是子类issubclass(子类,父类) __str__方法会在对象被打印时自动触发,然后将返回值返回给print功能进行打印 1234567891011class People: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return '&lt;%s:%s&gt;' %(self.name,self.age)peo=People('ooc',18)print(peo) #print(peo.__str__())# &lt;ooc:18&gt; __del__方法会在对象被删除时自动触发执行,用来在对象被删除前回收系统资源 1234567891011class Bar: def __init__(self,x,y,filepath): self.x=x self.y=y self.f=open(filepath,'r',encoding='utf-8') def __del__(self): # 写回收系统资源相关的代码 self.f.close()obj=Bar(10,20)del obj]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——反射]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射反射指的是通过字符串来操作属性 123456789101112131415161718192021222324252627# e.g.class Foo: def __init__(self,name,age): self.name = name self.age = age def tell_info(self): print('%s:%s' %(self.name,self.age)) obj = Foo('ooc',18)# hasattrprint(hasattr(obj,'name')) # True# getattrprint(getattr(obj,'name')) # ooc# setattrsetattr(obj,'gender','male') # 增加属性print(obj.__dict__) # &#123;'name': 'ooc', 'age': 18, 'sex': 'male'&#125;stattr(obj,'name','david') # 已存在属性就修改属性print(obj.__dict__) # &#123;'name': 'david', 'age': 18, 'sex': 'male'&#125;# delattrdelattr(obj,'name')print(obj.__dict__) # &#123;'age': 18, 'sex': 'male'&#125;]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的命名空间]]></title>
    <url>%2F2018%2F10%2F23%2FPython%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Python 的命名空间原文链接：https://segmentfault.com/a/1190000004519811]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——面向对象编程]]></title>
    <url>%2F2018%2F10%2F22%2FPython%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程面向过程编程思想 与 面向对象的编程思想面向过程编程思想 核心 ‘过程’ 两字，过程指的是解决问题的步骤 即：先干什么——&gt;再干什么——&gt;后干什么 优点：一个复杂功能简单化、流程化 缺点：可扩展性差，一动全动 面向对象的编程思想 核心‘对象’两字，对象是特征（变量）与技能（函数）的结合体 堪比创造世界，一切皆对象 类对象是特征（变量）与技能（函数）的结合体，而类则是一系列对象相同的特征（变量）与技能（函数）的结合体。 对象是具体存在的事物，而类则是一个抽象的概念 站在不同的角度总结出的类与对象是不同的 现实世界：先有一个个具体存在的对象，然后随着发展才会有类的概念 程序中：先定义类，后调用了类来产生对象 类的用途： 类本质就是一个名称空间，可以对该名称空间进行增删改查 调用类来产生对象 类体包含 相同的特征（变量）和相同的技能（函数） 类体中可以包含任意python代码 类体代码会在类定义阶段立即执行，产生一个名称空间，用来将类体代码执行执行过程中产生的名字都丢进去 e.g. Case 123456789101112131415161718192021222324252627282930313233343536立信选课系统对象1： 特征 学校 = ‘Lixin’ 职业 = ‘student’ 姓名 = ‘ooc’ 年龄 = 22 性别 = ‘male’ 技能 选课对象2： 特征 学校 = ‘Lixin’ 职业 = ‘student’ 姓名 = ‘rachel’ 年龄 = 18 性别 = ‘female’ 技能 选课对象3： 特征 学校 = ‘Lixin’ 职业 = ‘teacher’ 姓名 = ‘gu’ 年龄 = 50 性别 = ‘male’ 等级 = 10 技能 打分 学生类： 相似特征 学校 = ‘Lixin’ 职业 = ‘学生’ 相似技能 选课 1234567891011121314151617181920212223242526272829303132class LiXinStudent: # 相似的特征 school = 'Lixin' job = 'student' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender # 相似的技能 def choose_course(self): print('%s choose course' %self.name)# 类对名称空间进行增删改查# 查看当前名称空间print(LiXinStudent.__dict__)print(LiXinStudent.__dict__['school'])# LiXinStudent.school # LiXinStudent.__dict['school']LiXinStudent.add_element = 11111print(LiXinStudent.__dict__) # 名称空间增加 add_element = 11111# 调用类产生对象stu1 = LiXinStudent('ooc', 22, 'male')print(stu1)# &lt;__main__.LiXinStudent object at 0x10b774e48&gt;print(stu1.__dict__)# &#123;'name': 'ooc', 'age': 22, 'gender': 'male'&#125;# __init__的功能：就是在实例化时就为对象初始自己独有的特征# 注意：不能有返回值 属性查找顺序 先从对象自己的名称空间找，没有则去所属的类找，不回去全局找，所属类里找不到就报错。 类中定义的变量是所有对象共享的，对象可以来用，类也可以来使用，类一旦改变自己的数据属性的值，所有的对象都能感知到。 绑定方法类中定义的函数是类的函数属性，类可以用，类来调用就是一个普通的函数，但其实类中的定义的函数是给对象用的，而且是绑定给对象用的。 类的函数：该传几个参数就传几个参数 特殊之处是绑定给谁就应该由谁来调用，谁来调用就会将谁当做第一个参数自动传入 123456stu1 = LiXinStudent('ooc', 22, 'male')print(stu1.__dict__)# &#123;'name': 'ooc', 'age': 22, 'sex': 'male'&#125;stu1 = choose_course()# ooc choose course# 绑定给谁就应该由谁来调用 继承什么是继承？在程序中继承是一种新建子类的方式，新创建的类称之为子类、派生类，被继承的类称之为父类、基类、超类。继承描述的是一种遗传关系，子类可以重用父类的属性。 为何用继承？减少类与类之间的代码冗余的问题 如何继承先抽象再继承 e.g. Case1 12345678910111213141516171819202122232425# 单继承&amp;多继承class Parent1(object): passclass Parent2: passclass Sub1(Parent1): passclass Sub2(Parent1,Parent2): passprint(Sub1.__bases__)# (&lt;class '__main__.Parent1'&gt;,)print(Sub2.__bases__)# (&lt;class '__main__.Parent1'&gt;, &lt;class '__main__.Parent2'&gt;)print(Parent1.__bases__)# (&lt;class 'object'&gt;,)print(Parent2.__bases__)# (&lt;class 'object'&gt;,) 在python3中你不在()中写object，也默认给你加了# python2与python3在继承上的区别# 新式类:但凡继承object类的子类,以及该子类的子子类,...都称之为新式类# 经典类:没有继承object类的子类,以及该子类的子子类,...都称之为经典类# 只有在python2中才区分新式类与经典类 e.g. Case2 123456789101112131415161718192021222324252627282930313233343536373839# 在子类派生出的新功能中如何重用父类的功能：# 方式一：指名道姓地访问某一个类中的函数，与继承无关class LixinPeople: school = 'Lixin' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = genderclass LixinStudent(LixinPeople): def choose_course(self): print('%s is choosing course' %self.name)class LixinTeacher(LixinPeople): def __init__(self,name,age,gender,level,salary): LixinPeople.__init__(self,name,age,gender) self.level = level self.salary = salary def score(self,stu,num): stu.num=num # 同时把分数存到该学生的内存空间当中 print('老师%s给学生%s打分%s' %(self.name,stu.name,num))tea = LixinTeacher('gu',50,'male',10,3000)print(tea.__dict__)stu1 = LixinStudent('ooc',22,'male')print(stu1.__dict__)stu1.choose_course()tea.score(stu1,100)print(stu1.__dict__)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——re正则表达式]]></title>
    <url>%2F2018%2F10%2F19%2FPython%E2%80%94%E2%80%94re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[re - 正则表达式的操作Regular Expression简称re，表示正则表达式. 什么是正则表达式这个模块提供了一系列功能强大的正则表达式 (regular expression) 工具, 它们允许你快速检查给定字符串是否与给定的模式匹配 (使用 match 函数), 或者包含这个模式 (使用 search 函数). 正则表达式是以紧凑(也很神秘)的语法写出的字符串模式.表达式指的是某些带有特殊含义的符号或者符号组成的式子，这些式子是对字符进行处理的逻辑公式，是用特殊字符或者一些特殊组成一个规则字符串，这个规则字符串用来表达对字符的过滤逻辑。 re.match函数re.match 尝试从字符串的起始位置匹配一个模式， 支持的字符及其表达的含义The special characters are: ​ ‘.’ 匹配换行符之外的任何字符 ​ ‘^’ 匹配字符串的开头 ​ ‘$’ 匹配到字符串末尾或字符串末尾的换行符之前 ​ ‘‘ 匹配前面表达式的0次或更多重复。ab 将匹配’a’,’ab’或’a’,后跟任意数量的’b’(贪婪) ​ ‘+’ 匹配结果表达式匹配前一表达式的1次或多次重复 ​ ab+将匹配’a’，后跟任何非零数字’b’，它将不匹配只是’a’（贪婪） ​ ‘?’ 导致结果表达式匹配前面表达式的0或1个重复。ab? 将匹配’a’或’ab’（贪婪） *?,+?,?? 前三个表达式的非（贪婪）版本 ​ {m,n} 匹配前一个表达式的m到n次重复 ​ {m,n}? 前一个表达式的非（贪婪）版本 ​ ‘\\‘ 要么转义特殊字符，要么发出特殊序列信号 ​ [] 表示一组字符 ​ ‘|’ A|B, creates an RE that will match either A or B. ​ (…) Matches the RE inside the parentheses. ​]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——hashlib模块]]></title>
    <url>%2F2018%2F10%2F18%2FPython%E2%80%94%E2%80%94hashlib%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hashlib 模块hash是一个种算法，是将一个任意长的数据，根据计算得到一个固定长度的特征码 特征 不同输入 可能会有相同的结果 几率特别小 相同的输入 肯定得到一个相同的结果 散列值的性质，从原理上来说是不可能反解的 网上有反解的一些小工具，但是使用的方式是撞库，就是他们讲一些经常出现的数据存放起来，然后进行一一比对 使用场景 密码验证 验证数据是否被篡改，例如游戏安装包 Case12345678910111213141516171819202122232425262728import hashlibm = hashlib.md5('aaa123'.encode('utf-8'))print(m.hexdigest())print(len(m.hexdigest()))# d9f6e636e369552839e7bb8057aeb8da# 32h1 = hashlib.sha512('123'.encode('uft-8')) # hashlib.有很多不同的算法print(len(h1.hexdigest()))print(h1.hexdigest())# 128# 3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2# 加盐m = hashlib.md5('321'.encode('utf-8'))print(m.hexdigest())# caf1a3dfb505ffed0d024130f58c5cfam.update('qweqr'.encode('utf-8'))print(m.hexdigest())# 60025d5161811b25a25c0c333df98634# 先加盐import hmach = hmac.new('qweqr'.encode('utf-8'))h.update('321'.encode('utf-8'))print(h.hexdigest())# 393faee81f2f2db9bd3efa6d5302792e]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——logging模块]]></title>
    <url>%2F2018%2F10%2F18%2FPython%E2%80%94%E2%80%94logging%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[logging 模块日志级别12345logging.debug() # 10 # 默认级别为warninglogging.info() # 20 # 默认输出位置为控制台logging.warning() # 30 # 默认编码根据系统确定logging.error() # 40logging.critical() # 50 自定义配置12import logginglogging.basicConfig() # 函数中通过具体参数来更改logging模块默认行为 可用参数 123456filename: 用指定的文件名创建FiledHandler，这样日志会被储存在指定的文件filemode: 文件打开方式，在指定了filename时使用这个参数，默认值为&apos;a&apos;还可以指定&apos;w&apos;format: 指定handler使用的日志显示格式datefmt: 指定日期时间格式level: 设置rootlogger的日志级别stream: 用指定的stream创建StreamHandler,可以指定输出到sys.stderr, sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 可用格式 1234567891011121314%(name)s: Logger的名字，并非用户名，详细查看%(levelno)s: 数字形式的日志级别%(levelname)s: 文本形式的日志级别%(pathname)s: 调用日志输出函数的模块的文件名%(module)s: 调用日志输出函数的模块名%(funcName)s: 调用日志输出函数的函数名%(lineno)d: 调用日志输出函数的语句所在的代码行%(created)f: 当前时间，用UNIX标准的表示时间的浮点数表示%(relativeCreated)d: 输出日志信息时自Logger创建以来的毫秒数%(asctime)s: 字符串形式的当前时间。默认格式为&apos;2018-10-15 17:30:00,123&apos;在逗号后边是毫秒%(thread)d: 线程ID%(threadName)s: 线程名%(process)d: 进程ID%(message)s: 用户输出的消息 Case1234567891011import logginglogging.basicConfig( filename="a.log", filemode="at", level=10, format="%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(message)s", datefmt="%Y-%m-%d %X %p")logging.debug("这是调试信息") # 由于我们设置了最低级别从10开始所以debug信息也会显示# 2018-10-18 18:19:21 PM DEBUG &lt;module&gt; 21 这又是调试信息 logging中的四个核心角色 logger 生成日志 handler 处理日志 filter 过滤日志 formatter 格式化 一条日志完整的生命周期 由logger产生日志 # 会先检查日志级别，低于设置的级别则不执行 交给过滤器判断是否被过滤 将日志消息分发给绑定的所有处理器 处理器按照绑定的格式化对对象输出日志 # 如果不指定格式则按照默认格式 通过字典配置日志模块配置日志模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647standard_format = "%(name)s %(asctime)s %(levelname)s %(module)s %(funcName)s %(lineno)s %(message)s"simple_format = "%(name)s %(asctime)s %(module)s %(message)s"complete_format = "%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(thread)s %(process)s %(message)s"logfile_path = r"/Users/ooc/Desktop/代码/test/log0.log"LOGGING_DIC = &#123; 'version':1, 'formatters':&#123; 'standard': &#123; 'format' : standard_format &#125;, 'simple':&#123; 'format' : simple_format &#125;, 'complete':&#123; 'format' : complete_format &#125; &#125;, 'fileters':&#123;&#125;, 'handlers' :&#123; 'console' :&#123; 'level' : 'DEBUG', 'class' : 'logging.StreamHandler', 'formatter' : 'simple' &#125;, 'default':&#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125;, &#125;, 'logger' :&#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125;, &#125;,&#125;]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——configparser模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94configparser%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[configparser 模块configparser 用于解析配置文件的模块，我们会在配置文件中，放入一些配置程序的信息，通常而言，这些配置信息是我们不需要经常去改动的信息，例如数据文件的路径 DB_PATH 在配置文件中，只有两种内容： section分区 option 选项 通常我们用get功能，从配置文件中获取一个配置选项。 Case12345678910# file: test.cfg# 路径相关的配置[path]db_path = /a/b/c/test.txt# 用户相关的配置[user]name = oOC# 服务相关的配置[server]url = 192.168.0.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# file: configparser模块.pyimport configparserconfig = configparser.ConfigParser()config.read('test.cfg',encoding='utf-8') # 读取一个配置文件# 获取需要的信息# 获取所有的分区print(config.sections())# ['path', 'user', 'server']# 获取所有选项print(config.options('user'))# ['name']# 获取路径print(config.get('path','db_path'))# /a/b/c/test.txt# 获取用户名print(config.get('user','name'))# oOC# get返回的都是字符串类型 如果需要转换类型 # 直接使用get+对应的类型(bool int float)getfloat()getint()getbool()# 是否由某个选项config.has_option()# 是否由某个分区config.has_section()# 返回布尔值# 添加config.add_section("server")config.set("server","url","192.168.1.2")# 删除config.remove_sectionconfig.remove_option("user")# 修改config.set("server","url","192.168.1.2")# 写回文件中with open("test.cfg", "wt", encoding="utf-8") as f: config.write(f)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——XML模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94XML%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[XML 模块参考文档链接： 什么是XML 模块？ XML 指可扩展标记语言（EXtensible Markup Language） XML 的设计宗旨是传输数据，而不是显示数据 XML 标签没有被预定义，我们需要自行定义标签 XML 的语法格式12345678910&lt;?xml version="1.0" encoding = "UTF-8"?&gt;&lt;!-- XML 声明文件的可选部分，如果存在需要放在文档的第一行 --&gt;&lt;root&gt; &lt;!-- 根元素 --&gt; &lt;child name = 'ooc'&gt; &lt;!-- 元素 应该还包含 有属性 'category' --&gt; &lt;!--XML 属性值必须加引号 --&gt;&lt;!--在 XML 中，应该尽量避免使用属性。如果信息感觉起来很像数据才使用元素吧--&gt; &lt;subchild&gt;......&lt;/subchild&gt; &lt;!-- 同时，层级必须明确，不可以混乱--&gt; &lt;subchild1&gt;.....&lt;/subchild1&gt; &lt;!-- 同级 --&gt; &lt;/child&gt;&lt;/root&gt; &lt;!--与第三行&lt;root&gt;对应&lt;/root&gt;是关闭标签，必须有这样的一对 --&gt; Case11234567891011121314&lt;bookstore&gt; &lt;book category="CHILDREN"&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category="WEB"&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XML 命名规则XML 元素必须遵循以下命名规则： 名称可以包含字母、数字以及其他字符 不能以数字或者标点符号开始 不能以字母xml、XML、Xml等开始 名称不能包含空格 Case212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# file: c.xml&lt;studentinfo&gt; &lt;stu1&gt; &lt;name1&gt; 张三 &lt;/name1&gt; &lt;age1&gt; 20 &lt;/age1&gt; &lt;girlfriend11&gt; &lt;name11&gt; 张三的女朋友 &lt;/name11&gt; &lt;age11&gt; 19 &lt;/age11&gt; &lt;/girlfriend11&gt; &lt;/stu1&gt; &lt;stu2&gt; &lt;name2&gt; 李四 &lt;/name2&gt; &lt;age2&gt; 23 &lt;/age2&gt; &lt;girlfriend22&gt; &lt;name22&gt; 李四的女朋友 &lt;/name22&gt; &lt;age22&gt; 18 &lt;/age22&gt; &lt;/girlfriend22&gt; &lt;/stu2&gt;&lt;/studentinfo&gt;# file:xml模块.pyimport xml.etree.ElementTree as ElementTree# 解析c.xmltree = ElementTree.parse('c.xml')print(tree)# 获取根标签rootTree = tree.getroot()print(rootTree)# iter是用于在全文范围获取标签for item in rootTree.iter('age22'): print(item.text) print(item.text.strip())# 输出 &lt;xml.etree.ElementTree.ElementTree object at 0x10462a7f0&gt;&lt;Element 'studentinfo' at 0x1045cbe08&gt; 1818]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——JSON模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94JSON%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[JSON 模块 什么是JSON模块？如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。JSON表示的对象就是标准的JavaScript语言的对象。 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象 JSON 名称、值对1"name" : "菜鸟教程" JSON 值Json值可以是： 数字（整数或浮点数） e.g. {“age”:30} 字符串（双引号中） 逻辑值（bool） 数组（中括号中） 对象（在大括号中） e.g. {“name”:”ooc”,”url”:”makeupstories.github.io”} null JSON格式的语法规范JSON模块提供了四个方法：dumps, dump, loads, load (不带s 封装write 和 read) ase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import json# file: a.json&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;# 反序列化 # file: json模块.pywith open('a.json','rt',encoding = 'utf-8') as f: res = json.loads(f.read()) print(type(res))# &lt;class 'dict'&gt;with open('a.json',encoding='utf-8') as f: print(json,load(f)) # 不带s 封装 write 和 read功能 # &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;json_info = '''&#123; "users": [&#123; "name": "ooc", "age": 23 &#125;, &#123; "name": "james", "age": 27 &#125; ]&#125;'''res = json.loads(json_info)print(res)# &#123;'users': [&#123;'name': 'ooc', 'age': 23&#125;, &#123;'name': 'james', 'age': 27&#125;]&#125;with open('b.json','wt',encoding='utf-8') as f: f.wrtie(json.dumps(json_info)) with open('b.json','wt',encoding='utf-8') as f: json.dump(json_info,f) # 不带s 封装 write 和 read功能]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shelve模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shelve%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shelve 模块shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型。 case12345678910import shelveuser = &#123;'name':'ooc'&#125;f = shelve.open(r'user_info.shv',writeback = True)f['user'] = userf.close() # 关闭时，把添加的内容写回到原文件中f = shelve.open(r'user_info.shv')print(f['user'])f.close()]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——pickle模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94pickle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[pickle 模块序列化的模块 单机程序 序列化是什么？序列化就是将内存中的数据结构转化成为一种中间格式，并储存到硬盘上。我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。 为什么要序列化？就是为了将数据持久储存，还为了实现跨平台数据交互。 反序列化是什么？把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 case123456789101112131415161718import pickledic = &#123;'name':'ooc','age':23,'gender':'male'&#125;print(type(dic)) # &lt;class 'dict'&gt;a = pickle.dumps(dic) # dumps 直接序列化到文件print(type(a)) # &lt;class 'bytes'&gt;f = open('user_info.pkl','wb') # 因为a是'bytes' ，wb是写入bytesf.write(a) # f.write(pickle.dumps(dic))序列化f.close()f = open('user_info.pkl','rb')info = pickle.loads(f.read()) # 从文件中反序列化print(info['age'])# 23]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——shutil模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94shutil%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[shutil 模块shutil 模块提供了一个易于使用的高级接口，用于处理文件、文件夹、压缩包、处理模块等 1234567891011121314151617181920212223242526272829303132333435363738# 将文件内容拷贝到另一个文件中# shutil.copyfileobj(fsrc,fdst[,length])&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.copyfileobj(open('old.txt','r'),open('new.txt','w'))# 拷贝文件 和 shutil.copyfileobj(fsrc,fdst[,length]) 差不多# shutil.copyfile(src,dst)&gt;&gt;&gt; shutil.copyfile('old.txt','new.txt') # 目标无需存在# 仅拷贝权限，内容、组、用户均不变# shutil.copymode(src,dst)&gt;&gt;&gt; shutil.copymode('old.txt','new.txt') # 目标文件必须存在# 拷贝文件和权限# shutil.copy(src,dst)&gt;&gt;&gt; shutil.copy('old.txt','new.txt')# 拷贝文件和状态信息# shutil.copy2(src,dst)&gt;&gt;&gt; shutil.copy2('old.txt','new.txt')# 压缩文件# 创建压缩包并返回文件路径# shutil.make_archive(base_name, format,...)# base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，# 如：data_bak =&gt;保存至当前路径# 如：/tmp/data_bak =&gt;保存至/tmp/# format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”# root_dir： 要压缩的文件夹路径（默认当前目录）# owner： 用户，默认当前用户# group： 组，默认当前组# logger： 用于记录日志，通常是logging.Logger对象&gt;&gt;&gt; shutil.make_archive('compression','zip',r'\a\b\c')&gt;&gt;&gt; shutil.make_archive('compression1','rar',r'\a\b\c')# shutil直接解压&gt;&gt;&gt; shutil.unpack_archive('\a\b\c\compression.zip')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os.path模块]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E2%80%94%E2%80%94os.path%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os.path 模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; import os# 返回path规范化的绝对路径&gt;&gt;&gt; os.path.abspath('a.txt') '/Users/ooc/makeupstories.github.io/a.txt'# 将path分割成目录和文件名二元组返回&gt;&gt;&gt; os.path.split('/Users/ooc/makeupstories.github.io/a.txt')('/Users/ooc/makeupstories.github.io', 'a.txt')# 返回path的目录。其实就是os.path.split(path)的第一个元素 [0]&gt;&gt;&gt; os.path.dirname('/Users/ooc/makeupstories.github.io/a.txt')'/Users/ooc/makeupstories.github.io'# 返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。# 即os.path.split(path)的第二个元素&gt;&gt;&gt; os.path.basename('/Users/ooc/makeupstories.github.io/a.txt') 'a.txt'# 如果path存在，返回True；如果path不存在，返回False&gt;&gt;&gt; os.path.exists('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 如果path是绝对路径，返回True&gt;&gt;&gt; os.path.isabs('/Users/ooc/makeupstories.github.io/no_exist.txt')True# 如果path是一个存在的文件，返回True。否则返回False&gt;&gt;&gt; os.path.isfile('/Users/ooc/makeupstories.github.io/no_exist.txt')False# 如果path是一个存在的目录，则返回True。否则返回False&gt;&gt;&gt; os.path.isdir('/Users/ooc/makeupstories.github.io/no_exist.txt') False# 将多个名称拼接为路径 &gt;&gt;&gt; os.path.join('a/','b/','c') 'a/b/c'# 返回path所指向的文件或者目录的最后存取时间&gt;&gt;&gt; os.path.getatime('/Users/ooc/makeupstories.github.io')1539767358.083225# 返回path所指向的文件或者目录的最后修改时间&gt;&gt;&gt; os.path.getmtime('/Users/ooc/makeupstories.github.io') 1539500860.4628224# 返回path的大小&gt;&gt;&gt; os.path.getsize('/Users/ooc/makeupstories.github.io') 448]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——os模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块这个模块提供了一种方便的使用操作系统函数的方法。 获取当前的工作目录123&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc' 切换当前工作目录123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'/Users/ooc'&gt;&gt;&gt; os.chdir('/Users/ooc/Desktop/')&gt;&gt;&gt; os.getcwd()'/Users/ooc/Desktop' 当前目录 &amp; 上一级目录12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.curdir # 当前目录 '.''.'&gt;&gt;&gt; os.pardir # 上一级目录 '..''..' 系统环境变量12&gt;&gt;&gt; os.environ # 与sys.path不同的是 sys.path加载的是包的环境变量 # os.environ加载的是系统的环境变量 执行系统命令12&gt;&gt;&gt; os.system('cd') # 会执行括号中的命令，如果命令成功执行，返回0，否则返回10 创建目录123&gt;&gt;&gt; os.mkdir('d') # mkdir 一级一级的创建目录&gt;&gt;&gt; os.mkdir('j/a') # 上一级目录必须存在，否则报错&gt;&gt;&gt; os.makedirs('a/b/c') # 创建目录，可以连同子目录一同创建 删除目录12&gt;&gt;&gt; os.removedirs('a/b/c') # 递归删除，如果文件夹内没有文件就删掉，有文件就保留&gt;&gt;&gt; os.rmdir('d') 删除文件1&gt;&gt;&gt; os.remove(r'/Users/ooc/Desktop/a/b/c.txt') # 仅仅删除文件 列出所有文件和文件夹名称1&gt;&gt;&gt; os.listdir(r'/Users/ooc/Desktop/a/b') # 列出所有文件和文件夹名称 获取当前平台的路径分隔符12&gt;&gt;&gt; os.sep # 不同系统会有所差异/ 获取当前平台换行符12&gt;&gt;&gt; os.linesep'\n']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——random模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94random%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[random 模块Random variable generators. 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; random.random() # 0-1 不包括1 输出一个随机浮点数0.026446419370216523&gt;&gt;&gt; random.random()0.5107952377575242&gt;&gt;&gt; random.random()0.8535785412460167&gt;&gt;&gt; random.randint(1,10) # 取1-10 中的随机一个整数2&gt;&gt;&gt; random.randint(1,10) # 取得到10 因为 return self.randrange(a, b+1)3&gt;&gt;&gt; random.randrange(1,10)# 取1-10 中的随机一个整数6 # 但是取不到10# 原文档# This fixes the problem with randint() which includes the endpoint; in Python this is usually not what you want.&gt;&gt;&gt; random.sample(['1','2','3','4'],2)['3', '4'] #sample(指定一个范围，随机个数)&gt;&gt;&gt; l = ['1','2','3','4'] # 打乱原列表的顺序&gt;&gt;&gt; random.shuffle(l)&gt;&gt;&gt; l['4', '2', '1', '3']&gt;&gt;&gt; random.choice([1,2,3]) # 随机选一个1&gt;&gt;&gt; random.choices([1,2,3,4,5,6,7],k = 2) # 随机选择两个[5, 7] 随机验证码长度自定义 包括0-9 a-z A-Z 123456789101112def get_auth_code(length): res = "" for i in range(length): a = random.randint(0,9) b = chr(random.randint(65,90)) c = chr(random.randint(97,122)) s = random.choice([a,b,c]) res += str(s) return resprint(get_auth_code(4))# 5V3l 输出]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——sys模块]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E2%80%94%E2%80%94sys%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[sys 模块This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter. 环境变量12345&gt;&gt;&gt; import sys # 记住要调用模块 此文章后边不再写&gt;&gt;&gt; sys.path['', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python37.zip', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7', '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload', '/usr/local/lib/python3.7/site-packages']# 环境变量# 可以通过 sys.path.append() 来添加 查看已经加载的模块12&gt;&gt;&gt; sys.modules# 你就可以看到你已经加载的模块，由于我这边加载的模块巨多，不写了 获取终端调用时的参数1234567891011121314151617&gt;&gt;&gt; sys.argv[''] # 这里我在terminal中测试的代码# 在pycharm, file:sys_argv.pyprint(sys.argv) 这里我们可以看到 sys.argv 是一个列表# ['/Users/ooc/Desktop/Python/sys模块.py']print(sys.argv[0])# /Users/ooc/Desktop/Python/sys模块.py# file:sys_argv.py# import sysprint(sys.argv[2])# file: sys_argv.py# file_path: /Users/ooc/Desktop/Python/sys_argv.py# terminaloOCs-MBP:~ ooc$ python3 /Users/ooc/Desktop/Python/sys_argv.py 1 4 9 104 # 获取终端调用时的参数 第一个元素是程序本身路径 获取解释器的版本信息1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.version'3.7.0 (default, Aug 22 2018, 15:22:33) \n[Clang 9.1.0 (clang-902.0.39.2)]'# 当前解释器使用的信息 获取当前平台名称12&gt;&gt;&gt; sys.platformdarwin # MacOS int类型支持的最大值12&gt;&gt;&gt; sys.maxsize # 貌似python2中好像是，sys.maxint9223372036854775807 最大的Unicode值12&gt;&gt;&gt; sys.maxunicode1114111 中间结束程序12345&gt;&gt;&gt; sys.exit() # 默认为0# 执行到这行代码时就退出程序If the status is omitted or None, it defaults to zero (i.e., success).If the status is an integer, it will be used as the system exit status.If it is another kind of object, it will be printed and the system 终端复制文件工具123456789# 原文件路径source = sys.argv[1]# 目标文件路径dispath = sys.argv[2]with open(source,'rb') as f: data = f.read() with open(dispatch,'wb') as f2: f2.write(data)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——datetime模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94datetime%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[datetimedatetime 主要对时间和日期的处理 获取当前详细时间12345678910111213141516171819202122232425262728&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2018, 10, 15, 19, 45, 9, 841259)&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; print(a)2018-10-15 19:45:24.502984 # 获取时间的某一部分&gt;&gt;&gt; print(a.hour)19&gt;&gt;&gt; print(a.year)2018# 替换时间的某一部分&gt;&gt;&gt; a = a.replace(year=2019)&gt;&gt;&gt; print(a)2019-10-15 19:45:24.502984&gt;&gt;&gt; a = datetime.datetime.now()&gt;&gt;&gt; b = datetime.datetime.now()&gt;&gt;&gt; print(a + b) # 不支持的操作类型 + 个人猜测是因为最大只能计算到2038年Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'datetime.datetime' and 'datetime.datetime'&gt;&gt;&gt; print(a - b)-1 day, 23:59:52.248296&gt;&gt;&gt; print(b - a)0:00:07.751704]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——time模块]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94time%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[time与时间相关的一个模块 更多了解：http://www.runoob.com/python3/python3-date-time.html 时间的三类时间戳时间戳是指从 1970年1月1日 0:0:0 开始到现在的秒数，但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。（不知道有没有更新过） 12345678&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1539595862.1039639&gt;&gt;&gt; time1 = time.time()&gt;&gt;&gt; time.sleep(10)&gt;&gt;&gt; time2 = time.time()&gt;&gt;&gt; time2 - time110.00250792503357 结构化时间123456789101112131415161718192021&gt;&gt;&gt; time.localtime()# 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组。time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=18, tm_min=43, tm_sec=5, tm_wday=0, tm_yday=288, tm_isdst=0)# tm_year 年# tm_mon 月# tm_mday 日# tm_hour 小时# tm_min 分钟# tm_sec 0 到 61 (60或61 是闰秒)# tm_wday 0到6 (0是周一) # tm_yday 一年中的第几天# tm_isdst 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的时候， tm_isdst为0；不了解情况时，tm_isdst()为负。# 单独取值&gt;&gt;&gt; time.localtime().tm_year2018&gt;&gt;&gt; time.localtime().tm_mon10&gt;&gt;&gt; time.gmtime() time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=10, tm_min=58, tm_sec=45, tm_wday=0, tm_yday=288, tm_isdst=0)# gmtime() 函数将一个时间戳转换为UTC时区（0时区）的struct_time，可选的参数sec表示从1970年1月1日以来的秒数。其默认值为time.time()，函数返回time.struct_time类型的对象。 格式化字符串时间12345&gt;&gt;&gt; time.strftime('%Y-%m-%d %H:%M:%S %p') # 注意大小写不然会报语法错误'2018-10-15 19:01:40 PM'&gt;&gt;&gt;time.strftime('%Y-%m-%d %X %p')'2018-10-15 19:02:11 PM' 三种格式之间的相互转换123456789101112131415# 时间戳转为结构化&gt;&gt;&gt; time.localtime(time.time())time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=19, tm_min=4, tm_sec=25, tm_wday=0, tm_yday=288, tm_isdst=0)# 结构化转字符串&gt;&gt;&gt; time.strftime('%Y-%m-%d',time.localtime(time.time()))'2018-10-15'# 字符串转为结构化&gt;&gt;&gt; time.strptime('2018-10-15','%Y-%m-%d')time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1)# 结构化转时间戳&gt;&gt;&gt; time.mktime(time.strptime('2018-10-15','%Y-%m-%d'))1539532800.0 格林威治时间123&gt;&gt;&gt; time.altzone # 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。-28800 # 暂时我也不知道有啥用 time.ctime([secs])12&gt;&gt;&gt; time.ctime() # 偏外国友人使用的时间格式'Mon Oct 15 19:12:30 2018']]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——目录规范]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[标准目录规范在学习模块和包之前，就已经写过了ATM和购物车的项目，但是当时我们没有学习模块和包，所以当时是所有的函数功能都写在一个.py文件当中，虽然实现了功能，但是当时就发现，在实际写代码时，过程非常的复杂，看起来比较乱，所以在学习模块和包以后呢，我们应该根据项目，应该分什么文件，分什么样的文件夹，那么在初期呢，我们有一个固定的文件结构，就是今天的要说的开发的标准目录规范。 配置文件e.g. case : ATM 123456789101112131415161718# 此代码块用于表示我的目录# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范标准目录规范 ———————— | # 文件和模块 bin-------------- start.py | config----------- settings.py | core------------- ATM.py | db--------------- db.txt | lib-------------- common.py | log-------------- log.txt | readme.txt（说明文档） 1234567891011121314151617181920212223242526272829303132# file: 'start.py' # 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') start() 在case中，可以发现我们使用到了文件的路径，在之后的功能中，日志文件，或者数据文件等，我们会不止一次的使用到文件路径，那么我们每一次直接将路径写在代码中，效率是非常低的，不可取，因为这只是在我们自己的电脑上用时，路径是这样的，但是当移植到别人的电脑上时，路径就会发生改变，所以我们不可避免的会需要修改这些路径。 所以不要直接写在代码中，我们可以通过定义一个变量，然后在修改的时候只需要修改一次，其次，也简化了书写。 12345678# file: 'start.py'# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt'# 在python中的常量，通常通过全部大写的变量名来定义，但是其本质和一个普通变量没有区别，但是大家统一用全部大写来定义一个常量 ​ 通常这类用于配置程序的变量，我们应该将它们都统一的放到单独的配置文件当中，不应该与我们的函数功能存放在一起。所以更好的做法是新建一个文件，将配置文件放进去。 12345678# 所以我们有了config这个文件夹，并在里边创建一个settings.py文件# file:'settings.py'# 将配置信息写入settings.py# 用户数据路径DB_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt'# 日志路径LOG_PATH = '/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/log/log.txt' 公共模块通常我们还会在很多时候，在进行关键操作之前需要进行验证，也就是说例如在atm功能中，在转账、提现、存款时，无论想要操作哪一步都需要先进行登陆验证，那么这时候这个验证功能的函数，就属于公共模块。 1234# file: 'common.py'# 登陆验证装饰器def login_auth(): pass 日志文件 log.txt 和 数据文件 db.txt区分业务逻辑和启动代码另外我们可以将程序的业务逻辑和启动代码，进行分离，创建一个start.py 和 将业务逻辑模块放入core文件夹中（e.g. ATM.py） 1234567891011121314151617181920212223242526272829303132# file: 'ATM.py'# 登陆def login(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','rt',encoding='utf-8') as read_f: print(read_f.read())# oOC:12345678:10000 (name:password:balance)# 注册def register(): with open('/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/db/db.txt','at',encoding = 'utf-8') as read_f: new_account = input('Enter your new acount: ').strip() read_f.append('\n%s:12345678:0' %new_account) print('Register')# 程序运行入口def start(): while True: print( ''' 1.login 2.register ''') select = input('make your choice： ') if select == '1': login() elif select == '2': register() else: print('Error') # file: 'start.py'start() 执行文件最后start.py就是一个执行文件通常我们放在bin文件夹中，即使有多个执行文件，我们也可以将其统一到bin文件夹中。 定制程序的入口为了给用户提供便利，我们程序的入口应该从core业务逻辑中转移到start.py文件中，所以我们需要将start.py中导入core下的ATM并执行start。 123456789# file:'start.py'import core.ATMcore.ATM.start()# 运行结果Traceback (most recent call last): File "/Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.py", line 16, in &lt;module&gt; import core.ATMModuleNotFoundError: No module named 'core' 很显然这样配置之后，我们以为导入了 ‘core’ 模块，但是运行结果很明确的告诉我们没有找到名字叫 ‘core’ 的模块，所以我们需要导入模块。 1234567891011121314151617# file: 'start.py'import sys,osprint(__file__)# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/bin/start.pyprint(os.path.dirname(__file__))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范/binprint(os.path.dirname(os.path.dirname(__file__)))# /Users/ooc/Desktop/Python 学习笔记/day19/标准目录规范 # 为了能够找到所有模块，把‘标准目录规范’下的下的所有文件夹导入到环境变量中BASE_DIC = os.path.dirname(os.path.dirname(__file__))sys.path.append(BASE_DIC)import core.ATMcore.ATM.start()# 定制程序的入口就结束啦 使用标准目录后引用配置文件在上述的case中，我们把文件的路径等配置文件，放在了 settings.py 文件中，那么我们在ATM中要使用这些配置文件，就需要导入config下的settings.py 12345678910# file: 'ATM.py'# 导入配置文件 settings.pyfrom config import settingsdef login(): with open(settings.DB_PATH,'rt',encoding='utf-8') as read_f: # 这里用settings.DB_PATH来调用读取文件路径 print(read_f.read()) ... 引用自定义模块为之前的功能添加日志功能 12345678910111213141516# file: 'common.py'# 导入配置文件 config 下的 settings 模块from config import settings# 新增一个日志功能def logger(msg): with open(settings.LOG_PATH,'at',encoding='utf-8') as write_f: write_f.write(msg) # file: 'ATM.py'from lib import commondef login(): with open(DB_PATH,'rt',encoding='utf-8') as read_f: print(read_f.read()) print('Login') common.logger('XXX登陆系统\n')]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——字典dict]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8dict%2F</url>
    <content type="text"><![CDATA[什么是字典字典是一种可变容器模型，且可以储存任意类型对象。为什么称之为字典，是因为，在使用过程中就像查字典，你要查 ‘apple’ 这个单词，你通过首字母，会先查找 ‘a’ ——&gt; ‘p’——&gt;’p’ 然后你就找到了 ‘apple’ ,而不需要像列表一样从第一个元素开始找到最后一个元素，所以某种程度上来说，字典要比列表快的多，而 list 越大，查找就越慢。 定义：在{}内用 ‘,’ 分隔开多个 key:value ，通常 key 必须是一个不可变的类型，而通常呢我们使用字符串来表达key，用来描述 value 的特征， 而value可以是任意数据类型。 12345678# e.g.info=&#123; 'name':'David', 'age':18, 'gender':'male', 'height':180, 'hobbies':['programming','read','fitness']&#125; 字典的特性 字典value可以是任何的python对象，但key不行。 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个值会被记住 key必须不可变， 所以可以用数字，字符串或元组充当，而用列表就不行 能存多个值 无序 可变（值可以变，id不变） 不可hash 字典的使用####访问字典里的值 123456789101112131415&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['name'] # 按key取值'David'&gt;&gt;&gt; info['age']18&gt;&gt;&gt; info['hobbies']['programming', 'read', 'fitness']&gt;&gt;&gt; info['hobbies'][2] # 先按key取值，再按列表取值'fitness' 计算字典元素个数，即计算key的总数123456789&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; len(info)5 按key存取值：可存可取123456789101112131415161718&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; info['weight']=130 # 往字典里添加元素&gt;&gt;&gt; info&#123;'name': 'David', 'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness'], 'weight': 130&#125;# get&gt;&gt;&gt; a = info.get('name')&gt;&gt;&gt; a'David'&gt;&gt;&gt; a = info.get('nameXXX') # 取不到值 不会报错 会返回一个None&gt;&gt;&gt; print(a)None 删除元素12345678910111213141516&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; del info['name'] # 直接修改原值&gt;&gt;&gt; info&#123;'age': 18, 'gender': 'male', 'height': 180, 'hobbies': ['programming', 'read', 'fitness']&#125;&gt;&gt;&gt; info.clear() # 清空字典&#123;&#125;&gt;&gt;&gt; del info # 删除字典Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'info' is not defined 成员运算 in 和 not in1234567891011&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; 18 in info # 查看的是key是否在字典中False&gt;&gt;&gt; 'age' in infoTrue 循环12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; for k in info.keys() # 取key... print(k)...nameagegenderheighthobbies&gt;&gt;&gt; for k in info: # 默认输出key... print(k)... nameagegenderheighthobbies# 取value&gt;&gt;&gt; for v in info.values():... print(v)... David18male180['programming', 'read', 'fitness']&gt;&gt;&gt; for k,v in info.items(): # 同时取出key 和 value... print(k,v)...name Davidage 18gender maleheight 180hobbies ['programming', 'read', 'fitness'] 快速创造一个字典123456789# fromkeys:需求是快速新造出一个字典，value的初始值全部都为None# key来自一个列表&gt;&gt;&gt; keys = ['name','age','gender']&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; for k in keys:... d[k] = None&gt;&gt;&gt; d=&#123;&#125;.fromkeys(keys,None)&gt;&gt;&gt; print(d)&#123;'name': None, 'age': None, 'gender': None&#125; setdefault12345678910&gt;&gt;&gt; info=&#123;... 'name':'David',... 'age':18,... 'gender':'male',... 'height':180,... 'hobbies':['programming','read','fitness']... &#125;&gt;&gt;&gt; res = info.setdefault('age', 123456) # 在key存在的情况下不修改值,会返回原值&gt;&gt;&gt; res 18]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python——列表list]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8list%2F</url>
    <content type="text"><![CDATA[1. 什么是列表 list列表 list 是 Python 内置的一种数据类型。在[]用逗号分隔开多个任意类型的值，通常用来描述同一种类型的值，放入列表。 list 的特点： 有序 存多个值 可以按索引村取值 可以随时添加和删除其中的元素 可变类型（可变：值可变，id不变） 不可hash 2. 如何使用列表 list 获取列表 list中元素的个数 12345&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# len() 是 Python 的内置函数之一,主要功能是返回对象的长度或者项目个数# 对象可以是（字符串、列表、元祖、集合、字典）&gt;&gt;&gt; len(name) 4 取列表中重复的元素 123&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose','Nick']&gt;&gt;&gt; name.count('Nick')2 按索引取值 12345678910111213141516&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0] # 按索引来访问list中每一个位置的元素，位置从0开始计算'David'&gt;&gt;&gt; name[1]'Nick'&gt;&gt;&gt; name[-1] # 索引 -1 代表直接取到列表的最后一个值 也就是倒数第一个值'Rose'&gt;&gt;&gt; name[-2] # 依次类推 可以取倒数第二个值'Rachel'&gt;&gt;&gt; name[4] # 当索引取4时，列表索引超过了范围，就会提示你列表索引超过了范围Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range# 最后一个元素的索引可以 可以用 元素个数减1 也可以表示为 len(name)-1 按值找索引 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.index('Rachel')2&gt;&gt;&gt; name.index('Lily')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'Lily' is not in list 添加元素 123456789101112131415161718192021222324252627&gt;&gt;&gt; name = [] # 声明一个空列表# append&gt;&gt;&gt; name.append('David')&gt;&gt;&gt; name # 打印列表['David'] &gt;&gt;&gt; name.append('Nick')&gt;&gt;&gt; name['David', 'Nick'] # .append()追加 在列表最后一个元素后边追加元素&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.append(new_name)['David', 'Nick', ['Jack', 'Lily']]# 我们看到结果是append 将一整个new_name作为一个整体传入name中作为一个元素# extend# 那其实我们还有另外一种添加的方法 .extend()# .extend()可以把new_name中的元素一个一个加入到name中&gt;&gt;&gt; name = ['David','Nick']&gt;&gt;&gt; new_name = ['Jack','Lily']&gt;&gt;&gt; name.extend(new_name)['David', 'Nick', 'Jack', 'Lily']# 那么如果想要在指定位置追加元素呢&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name.insert(1,'Jim') # insert(你想插入的位置，插入的内容)&gt;&gt;&gt; name['David', 'Jim', 'Nick', 'Rachel'] 删除元素 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# pop&gt;&gt;&gt; name.pop() # 默认删除列表最后一个元素 并且有返回值 ‘Rose’ 改变原列表'Rose'&gt;&gt;&gt; name['David', 'Nick', 'Rachel']&gt;&gt;&gt; name.pop(1) # pop写入索引 按索引删除指定位置的元素'Nick'&gt;&gt;&gt; name&gt;&gt;&gt; ['David', 'Rachel']# del&gt;&gt;&gt; del name[0] # 按索引删除 name列表中的元素&gt;&gt;&gt; name['Rachel']# remove&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.remove(0) # 尝试用索引Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# 报错 参数x 不在list中&gt;&gt;&gt; name.remove('Rachel')&gt;&gt;&gt; name # 可以看出remove的参数 传入的必须是是list中的元素内容['David', 'Nick', 'Rose']# clear&gt;&gt;&gt; name.clear() # 不会返回一个列表，而是返回给你一个内存地址 &lt;built-in method clear of list object at 0x1048b0148&gt;&gt;&gt;&gt; name.clear()&gt;&gt;&gt; name[] # 清空列表 替换元素 123456&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[1] = 'Mary' # 将索引[1]位置的元素替换成 'Mary'&gt;&gt;&gt; name['David', 'Mary', 'Rachel', 'Rose']&gt;&gt;&gt; name[-1] = 'Jack' # 同理正反取索引 都以用来替换元素['David', 'Mary', 'Rachel', 'Jack'] 列表的嵌套 1234567891011&gt;&gt;&gt; name = ['David','Nick','Rachel']&gt;&gt;&gt; name_2 = ['Rose', name]&gt;&gt;&gt; name_2['Rose', ['David', 'Nick', 'Rachel']]# 如何取值 取到'Nick'# name_2 = ['Rose', name] 其实就是在name_2的列表中套了一个name# 在这里可以把name看作是name_2中的元素# 我们要取到name中的'Nick' 就需要先取值 取到name_2中的 name元素# 然后再取 name 中的'Nick'元素 所以我们就可以怎么干&gt;&gt;&gt; name_2[1][1]'Nick' 切片（有头，无尾，步长默认为1） 12345678910111213141516171819202122&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[0:3] # 返回值可以通过声明一个变量去接收['David', 'Nick', 'Rachel']# 有头指的是从索引[0]开始，无尾是取不到索引[3]= 'Rose'位置的值&gt;&gt;&gt; name # 不会改变原列表 ['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[0:4:2] # 这里没有报超出索引范围的错误，可以看出只取到了[3]# 默认步长为1，这里改为2，意思就是为 一个 隔 一个 取值['David', 'Rachel']&gt;&gt;&gt; name[0:] # 意思为 从列表的头，取到列表的尾巴，就是取到元素最后一个值['David', 'Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[1:]['Nick', 'Rachel', 'Rose']&gt;&gt;&gt; name[-2:] # 从倒数第二个值开始取，取到列表的尾巴['Rachel', 'Rose']&gt;&gt;&gt; name[:-1] # 从最开头，取到倒数第一个值，有头无尾，所以不会取最后一个值['David', 'Nick', 'Rachel']&gt;&gt;&gt; name[:-2]['David', 'Nick']&gt;&gt;&gt; name[:] # 不传入任何参数，就是从头取到尾['David', 'Nick', 'Rachel', 'Rose'] 成员运算 in和not in 1234567&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; 'David' in name # 判断name这个列表中是否有'David',然后返回一个布尔值True&gt;&gt;&gt; 'Lily' in nameFalse&gt;&gt;&gt; 'Lily' not in name # 判断name这个列表中 没有'Lily',然后返回一个布尔值True 循环 12345678&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; for item in name: ... # for 循环通常用来取值 这里将name列表中的元素一个一个取出来... print(item)DavidNickRachelRose 排序 1234567891011121314151617181920&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']# reverse 反转列表&gt;&gt;&gt; name.reverse() # 直接改变原列表，反转&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name[::-1] # 通过切片的方式反转列表['Rose', 'Rachel', 'Nick', 'David']# sort 对原列表排序&gt;&gt;&gt; name = ['David','Nick','Rachel','Rose']&gt;&gt;&gt; name.sort(reverse = True) # 直接改变原列表，反转，无返回值&gt;&gt;&gt; name['Rose', 'Rachel', 'Nick', 'David']# 默认参数 sort(cmp = None,key = None,reverse = False)# cmp: 按照传入参数的方法进行排序，还没学到# key：主要用来进行排序，只有一个参数，具体的函数参数取自可迭代对象中，指定可迭# 代对象中的一个元素来进行排序（先不管，还没法理解）# reverse = False(默认序列) reverse = True (反转序列)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LoveMyCountry]]></title>
    <url>%2F2018%2F10%2F11%2FLoveMyCountry%2F</url>
    <content type="text"><![CDATA[I Love My Country前言​ 今天讲的这个话题其实可以说比较敏感的，得益于github pages拒绝百度爬虫，让我在这里敢写下这篇blog——关于‘爱国上网’。写这篇帖子的初衷非常简单，希望大家能多用于学习和开拓眼界。 申明须知严格禁止任何人使用海外、国内VPS主机、服务器用于违规、违法用途。严禁个人售卖行为！严禁个人售卖行为！严禁个人售卖行为！重要的事说三遍！正文由于我个人正在使用的服务器是来自Bwh,个人建议是优先选择CN2机房方案，因为联通和电信都是直连，白天和晚上的速度都比较稳定，虽然偶尔也会抽风但是相比普通线路机房会好很多。但是如果我们不追求速度要求的话，普通KVM和OVZ方案也是可以选择的。那么在这篇文章里呢我推荐大家购买kvm，由于前几年都是使用kvm方案，网速并没有什么大碍且在Bwh中性价比极高。其实服务器有很多，但是bwh对于新手和不想深入了解只想自己使用的人而言，无疑非常容易上手，因为它服务器有一键式的ss安装。其实曾今在国内我购买过阿里云的香港服务器，很不幸没活过2个月。 一、新注册搬瓦工账户入口 点击此处进入注册网址 我们可以看到下图所示，看到当前所有的搬瓦工VPS可购买的配置型号。我们直接创建账户是不行的，我们需要先找一个可以购买的机器，Order Now购买，在这里我们选择购买，但是我们最后不付款，只进行注册！不付款！只进行注册！ 下一步 点击Add to Cart 接着点击 Check out 这里不会支付，放心点吧！只是为了假装支付进入他的注册页面，因为正常的注册界面有验证码，无法验收所以必须要曲线救国。 这里就比较关键，我们需要输入新注册账户的个人信息。全部用拼音填写，尽量真实一点，尤其是国家和地区部分需要真实。你乱写容易出现欺诈订单和不通过。其次，也可以看到付款方式有paypal和alipay，相比较而言国内小伙伴应该alipay用的比较多。 在这里我们可以选择好alipay，然后下方的 terms of service打勾，点击complete order，这里回跳转到支付页面只要退出，回到主页就可以通过登陆，登陆新账号啦。 二、选择服务器这里的话，我只推荐Basic VPS - Self-managed - SPECIAL 10G KVM PROMO V3 - LOS ANGELES - CN2大家可以直接点击这个网址进入网址挑选购买，每个月500g的流量，机房是losangeles-cn2，年费为29.99美金/年，对于我上社交软件，查资料，甚至看视频，几乎没有障碍，十分稳定，流量也足够我挥霍。 这里点几Order Now进入购买页面 ————&gt; 下一页面点击Add to Cart 然后进入购物车页面，点击Checkout，记得要登陆后购买！支持支付宝alipay付款 三、配置服务器付款成功后，进入主页，在主页点击client area 点击你的服务器services中 选择 my services 然后你会看见你刚刚购买的服务器，点击KiwiVM Control Panel进入控制台 如果你发现你的operating system和我不一样 不是Centos 6 x86_64 bbr,请点击这个页面中的stop停止你的服务器，然后进入左边Install new OS，找到相印的版本安装。 安装完成后点击 四 配置上网Win10/macos用户看这里： 你获取了你的加密、端口和密钥后，只要进行最后一步配置就可以啦。我们需要下载shadowsocks,那么根据不同用户呢有不同的下载地址，点击下方地址就可以啦。 win10: https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E macos： https://github.com/shadowsocks/ShadowsocksX-NG 至于 安卓和ios下的安装和使用，你可以直接联系我啊！实在是太复杂了，就不一一赘述啦。 看不懂请谷歌百度 下载完成后我们要进行配置啦 大同小异，这里我统一用mac版来做范例了 打开那个纸飞机，它会出现在你的菜单栏上 找到servers——&gt;进入 server preferences 其中ip地址在你的刚刚服务器的控制台的main controls中找的到，ip地址后的端口和其余的都在shadowsocks server中能找到。 当你把所有的东西都弄好后，你就可以享受全世界啦！ Hello world! 然后稍微介绍一下这个小飞机的用途： 它分 PAC模式 和 Global 模式，意思也很简单，pac模式下，国内能打开的网址走国内，打不开的网址走服务器，global模式下所有网址一律走服务器。建议使用pac，有特殊情况使用global，开了global也别忘了关。 有任何问题联系我哦 完结]]></content>
      <categories>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages & Hexo 搭建个人blog]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BAblog%E2%80%94%E2%80%94Github%20Pages%26Hexo%2F</url>
    <content type="text"><![CDATA[前言趁着今天自习的机会，本着想花费一上午的时间来解决github pages&amp;hexo搭建个人blog，结果啊整整花了一天，头一低一抬，8点又8点了。之所以有这个欲望是因为，之前都是用博客园写blog，第一天被学长瞅见，学长：low 逼！我也觉得low，苦在真的没空抽身搭建这个github pages，今天总算是忙里偷闲。 这个真的超级酷！！！！ 其实搭建差不多花了俩三个小时吧，踩了不少坑。不过最让人兴奋的就是搭建好的时候，开始慢慢美化自己的blog的过程，真是美妙啊。那么这次和我一起研究搭建个人blog的呢，还有我的室友Musibii。那么当然不出意外的，我们也是借鉴了许许多多过去的经验贴啊，没想到还是踩了一个又一个的坑啊。好了，废话不多说，那么开始我们的表演吧。 Github注册那么既然我们要使用github pages，肯定就需要一个github的账号。点击 Github 这个进入主页，然后点击右上角 sign up 一通操作后……恭喜你，成为了全球最大的同性交友网站的一员。（建议注册时用户名最好不要有大写字母！） 注册后，你就需要搭建一个库，点击左下方new repository，开始建库。 点击下边的create repository就注册成功啦。 这时候点击右上角的头像，选择your repositories，就可以看见你的库里有一个项目啦。 Hexo这里我和Musibii在Hexo和Jekyll两个最流行的blog框架中，选择了Hexo(js速度比较快吧，其次据说学习成本低，没感觉低) Hexo 基于Nodejs，如果你不是很熟悉这些不知道什么玩意的东西的话呢，暂时也不用深究，接下来的每一步都要小心小心仔细仔细，就ok啦。 安装git $ brew install git // 安装Git brew 是 homebrew 的功能之一，所以你需要install homebrew，这些安装都在你的终端/terminal当中完成，具体的安装homebrew命令官方网站中有。 安装nodejs 安装nodejs呢，需要先安装nvm，nvm是nodejs的版本管理器，用来切换nodejs的版本，这里建议用curl方式安装，homebrew安装的方式会少文件夹，导致后边无法正常安装。 $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装完成后重启你的terimal，再安装nodejs。 $ nvm install 8 需要注意的是后边的8是nodejs的版本号，如果你隔了很久搜到了这篇帖子，请去查寻最新的nodejs的版本，否则会导致你的版本过低而在安装过程中出现warning，最后导致error。 安装hexo 完成以上安装再安装hexo $ sudo npm install hexo-cli -g 到这里呢所有的工具都已经安装好了 编写发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(你的用户名.github.io) 创建博客 下边出现的所有username都需替换成你自己的username $ hexo init username.github.io 成功后会创建出一个名为 username.github.io的文件夹 更改配置 主题安装 我们为了使博客好看点，这里我们需要安装一个主题，在terminal中，进入刚刚生成username.github.io的文件夹目录，安装主题。 $ cd username.github.io $ git clone https://github.com/iissnan/hexo-theme-next themes/next 这是我现在用的主题。 基础配置：我们可以在 文件夹中 打开username.github.io的文件夹 如果你不会vim之类的话，macos就是通过finder，找到username.github.io的文件夹下的_config.yml修改几个基础配置，注意配置的：后必须要有空格 title: MakeUpStories //你博客的名字 author: oOC //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改。 可以先去hexo next官网中，查看官方文档，把基础的看完，你就可以去简书啊之类的查看更加进阶的设置，目前我的设置页十分的基础。 写文章 写文章的话我这里直接用的内置username.github.io/source/_posts下的helloworld.md文件进行测试。 测试 $ hexo s 进行服务器测试，在终端中你会收到返回信息，在https://localhost:4000中你可以查看当前的blog是什么样子的。 安装hero-deployer-git工具 如果之前一切都顺利的话，在这里就可以设置自动部署发布工具啦 $ npm install hexo-deployer-git --save 发布 最后的最后，如果你的测试一切都ok，没有问题的话，我们就生成一个静态网页文件发布至我们的github pages当中啦。 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在输入命令之后，会让你输入github的邮箱！！一定是邮箱和密码，别以为用户名能登陆就用用户名，一定要用邮箱啊！然后你的blog就被上传至github了，以后写完blog，都要执行一下这个命令上传blog。 最后：我的bloghttps://makeupstories.github.io/ 这是我的第一篇blog，之后有空的话，我还会更新如何搭建科学上网，以及在mac系统上比较好用的app和小插件，另外还有我的python学习之路。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
